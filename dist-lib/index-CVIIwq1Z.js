var _m = Object.defineProperty;
var Am = (e, t, n) => t in e ? _m(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var jt = (e, t, n) => Am(e, typeof t != "symbol" ? t + "" : t, n);
import { jsxs as Ke, jsx as De, Fragment as wm } from "react/jsx-runtime";
import { forwardRef as Wd, createElement as Ac, useMemo as xm, useState as Yi, useRef as ch } from "react";
const Vd = {
  "modern-light": {
    name: "ç°ä»£ç®€çº¦",
    bg: "bg-white",
    text: "text-slate-800",
    container: "bg-white shadow-xl border border-slate-100",
    accent: "text-blue-600",
    header: "border-b border-slate-100",
    code: "bg-slate-100 text-pink-600"
  },
  "dark-minimal": {
    name: "æ·±é‚ƒæš—è‰²",
    bg: "bg-zinc-950",
    text: "text-zinc-200",
    container: "bg-zinc-900 shadow-2xl border border-zinc-800",
    accent: "text-emerald-400",
    header: "border-b border-zinc-800",
    code: "bg-zinc-800 text-emerald-300"
  },
  "serif-classic": {
    name: "ç»å…¸è¡¬çº¿",
    bg: "bg-[#fdfbf7]",
    text: "text-stone-800",
    container: "bg-[#fdfbf7] shadow-lg border border-stone-200",
    accent: "text-red-800",
    header: "border-b border-stone-200",
    code: "bg-stone-200 text-stone-900",
    font: "font-serif"
  },
  "gradient-blue": {
    name: "æåœ°å†°å·",
    bg: "bg-gradient-to-br from-blue-500 to-indigo-700 p-8",
    text: "text-slate-800",
    container: "bg-white/95 backdrop-blur shadow-2xl rounded-2xl",
    accent: "text-indigo-600",
    header: "border-b border-blue-100",
    code: "bg-blue-50 text-blue-700"
  },
  "gradient-purple": {
    name: "æš®å…‰ç´«è‰²",
    bg: "bg-gradient-to-tr from-fuchsia-600 to-purple-600 p-8",
    text: "text-slate-800",
    container: "bg-white/95 backdrop-blur shadow-2xl rounded-2xl",
    accent: "text-purple-600",
    header: "border-b border-purple-100",
    code: "bg-purple-50 text-purple-700"
  },
  "gradient-pink-blue": {
    name: "æ£‰èŠ±ç³–",
    bg: "bg-gradient-to-br from-blue-400 via-purple-300 to-pink-300 p-8",
    text: "text-slate-800",
    container: "bg-white/90 backdrop-blur shadow-2xl rounded-2xl border border-white/50",
    accent: "text-pink-500",
    header: "border-b border-pink-100",
    code: "bg-pink-50 text-pink-600"
  }
}, Nm = {
  theme: "modern-light",
  fontSize: 16,
  lineHeight: 1.8,
  padding: 48,
  fontFamily: "sans",
  width: 750,
  showWatermark: !0,
  watermarkText: "ç”± Markdown è§†è§‰å¤§å¸ˆ å¯¼å‡º",
  imageBorderRadius: 12,
  imageShadow: 10,
  imageAlignment: "center",
  imageWidthPercent: 100,
  splitMode: "h1-h2"
}, vm = `# æ¬¢è¿ä½¿ç”¨ Markdown è§†è§‰å¤§å¸ˆ ğŸš€

è¿™æ˜¯ä¸€ä¸ªä¸“ä¸ºåˆ›ä½œè€…è®¾è®¡çš„ **Markdown è½¬å›¾ç‰‡** å·¥å…·ï¼

## æ ¸å¿ƒåŠŸèƒ½
1. **ç²¾ç¾ä¸»é¢˜**ï¼šå†…ç½®ç°ä»£ã€æš—è‰²ã€ç»å…¸åŠæ¸å˜é£æ ¼ã€‚
2. **å±€éƒ¨æ ·å¼**ï¼šç°åœ¨æ”¯æŒè°ƒæ•´ <span style="color: #ef4444; background-color: #fee2e2; padding: 0 4px; border-radius: 4px;">ç‰¹å®šæ–‡å­—çš„é¢œè‰²</span> ä¸ <span style="background-color: #fef08a; padding: 0 4px; border-radius: 4px;">èƒŒæ™¯é«˜äº®</span>ã€‚
3. **æ•°æ®è¡¨æ ¼**ï¼šæ”¯æŒæ ‡å‡†çš„ Markdown è¡¨æ ¼æ¸²æŸ“ã€‚
4. **å›¾ç‰‡è°ƒæ•´**ï¼šæ”¯æŒåœ†è§’ã€é˜´å½±ã€å®½åº¦å’Œå¯¹é½æ–¹å¼çš„å®æ—¶è°ƒèŠ‚ã€‚

---

## æ™ºèƒ½åˆ†é¡µæ¼”ç¤º
è¿™æ˜¯ä¸€ä¸ªæ–°çš„åˆ†é¡µï¼ˆå¦‚æœä½ å¼€å¯äº†åˆ†é¡µæ¨¡å¼å¹¶é€‰æ‹©äº†åˆ†å‰²çº¿æˆ–æ ‡é¢˜åˆ‡å‰²ï¼‰ã€‚

### ä½¿ç”¨æ–¹æ³•
åœ¨ç¼–è¾‘å™¨ä¸­é€‰ä¸­æ–‡å­—ï¼Œä½¿ç”¨ä¸Šæ–¹çš„ **é¢œè‰²é€‰æ‹©å™¨** æŒ‘é€‰é¢œè‰²åç‚¹å‡»å‹¾å·å³å¯ã€‚

### ç¤ºä¾‹å±•ç¤º
- <span style="color: #3b82f6; font-weight: bold;">è“è‰²åŠ ç²—æ–‡æœ¬</span>
- <span style="background-color: #dcfce7; color: #166534; padding: 0 6px; border-radius: 99px;">ç»¿è‰²èƒ¶å›Šæ ‡ç­¾</span>

> â€œè®¾è®¡ä¸ä»…ä»…æ˜¯å¤–è§‚å’Œæ„Ÿè§‰ï¼Œè®¾è®¡æ˜¯å®ƒçš„å·¥ä½œæ–¹å¼ã€‚â€ â€”â€” å²è’‚å¤«Â·ä¹”å¸ƒæ–¯

åœ¨å·¦ä¾§ç¼–è¾‘å™¨ä¸­å¼€å§‹è¾“å…¥ï¼Œå³åˆ»æŸ¥çœ‹å³ä¾§é¢„è§ˆï¼
`;
/**
 * @license lucide-react v0.563.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Gd = (...e) => e.filter((t, n, r) => !!t && t.trim() !== "" && r.indexOf(t) === n).join(" ").trim();
/**
 * @license lucide-react v0.563.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Sm = (e) => e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
/**
 * @license lucide-react v0.563.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Lm = (e) => e.replace(
  /^([A-Z])|[\s-_]+(\w)/g,
  (t, n, r) => r ? r.toUpperCase() : n.toLowerCase()
);
/**
 * @license lucide-react v0.563.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const fh = (e) => {
  const t = Lm(e);
  return t.charAt(0).toUpperCase() + t.slice(1);
};
/**
 * @license lucide-react v0.563.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var km = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.563.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Cm = (e) => {
  for (const t in e)
    if (t.startsWith("aria-") || t === "role" || t === "title")
      return !0;
  return !1;
};
/**
 * @license lucide-react v0.563.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Im = Wd(
  ({
    color: e = "currentColor",
    size: t = 24,
    strokeWidth: n = 2,
    absoluteStrokeWidth: r,
    className: i = "",
    children: a,
    iconNode: s,
    ...o
  }, u) => Ac(
    "svg",
    {
      ref: u,
      ...km,
      width: t,
      height: t,
      stroke: e,
      strokeWidth: r ? Number(n) * 24 / Number(t) : n,
      className: Gd("lucide", i),
      ...!a && !Cm(o) && { "aria-hidden": "true" },
      ...o
    },
    [
      ...s.map(([c, f]) => Ac(c, f)),
      ...Array.isArray(a) ? a : [a]
    ]
  )
);
/**
 * @license lucide-react v0.563.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Nn = (e, t) => {
  const n = Wd(
    ({ className: r, ...i }, a) => Ac(Im, {
      ref: a,
      iconNode: t,
      className: Gd(
        `lucide-${Sm(fh(e))}`,
        `lucide-${e}`,
        r
      ),
      ...i
    })
  );
  return n.displayName = fh(e), n;
};
/**
 * @license lucide-react v0.563.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Pm = [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]], Om = Nn("check", Pm);
/**
 * @license lucide-react v0.563.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Rm = [
  ["path", { d: "M12 15V3", key: "m9g1x1" }],
  ["path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4", key: "ih7n3h" }],
  ["path", { d: "m7 10 5 5 5-5", key: "brsn70" }]
], Dm = Nn("download", Rm);
/**
 * @license lucide-react v0.563.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Mm = [
  [
    "path",
    {
      d: "M2.062 12.348a1 1 0 0 1 0-.696 10.75 10.75 0 0 1 19.876 0 1 1 0 0 1 0 .696 10.75 10.75 0 0 1-19.876 0",
      key: "1nclc0"
    }
  ],
  ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }]
], Fm = Nn("eye", Mm);
/**
 * @license lucide-react v0.563.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Bm = [
  [
    "path",
    {
      d: "M6 22a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h8a2.4 2.4 0 0 1 1.704.706l3.588 3.588A2.4 2.4 0 0 1 20 8v12a2 2 0 0 1-2 2z",
      key: "1oefj6"
    }
  ],
  ["path", { d: "M14 2v5a1 1 0 0 0 1 1h5", key: "wfsgrz" }],
  ["circle", { cx: "10", cy: "12", r: "2", key: "737tya" }],
  ["path", { d: "m20 17-1.296-1.296a2.41 2.41 0 0 0-3.408 0L9 22", key: "wt3hpn" }]
], Um = Nn("file-image", Bm);
/**
 * @license lucide-react v0.563.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Hm = [
  [
    "path",
    {
      d: "M6 22a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h8a2.4 2.4 0 0 1 1.704.706l3.588 3.588A2.4 2.4 0 0 1 20 8v12a2 2 0 0 1-2 2z",
      key: "1oefj6"
    }
  ],
  ["path", { d: "M14 2v5a1 1 0 0 0 1 1h5", key: "wfsgrz" }],
  ["path", { d: "M10 9H8", key: "b1mrlr" }],
  ["path", { d: "M16 13H8", key: "t4e002" }],
  ["path", { d: "M16 17H8", key: "z1uh3a" }]
], $d = Nn("file-text", Hm);
/**
 * @license lucide-react v0.563.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const jm = [
  ["path", { d: "m9 11-6 6v3h9l3-3", key: "1a3l36" }],
  ["path", { d: "m22 12-4.6 4.6a2 2 0 0 1-2.8 0l-5.2-5.2a2 2 0 0 1 0-2.8L14 4", key: "14a9rk" }]
], qm = Nn("highlighter", jm);
/**
 * @license lucide-react v0.563.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const zm = [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", ry: "2", key: "1m3agn" }],
  ["circle", { cx: "9", cy: "9", r: "2", key: "af1f0g" }],
  ["path", { d: "m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21", key: "1xmnt7" }]
], Ym = Nn("image", zm);
/**
 * @license lucide-react v0.563.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Wm = [["path", { d: "M21 12a9 9 0 1 1-6.219-8.56", key: "13zald" }]], hh = Nn("loader-circle", Wm);
/**
 * @license lucide-react v0.563.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Vm = [
  ["path", { d: "M4 5h16", key: "1tepv9" }],
  ["path", { d: "M4 12h16", key: "1lakjw" }],
  ["path", { d: "M4 19h16", key: "1djgab" }]
], Gm = Nn("menu", Vm);
/**
 * @license lucide-react v0.563.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const $m = [
  [
    "path",
    {
      d: "M12 22a1 1 0 0 1 0-20 10 9 0 0 1 10 9 5 5 0 0 1-5 5h-2.25a1.75 1.75 0 0 0-1.4 2.8l.3.4a1.75 1.75 0 0 1-1.4 2.8z",
      key: "e79jfc"
    }
  ],
  ["circle", { cx: "13.5", cy: "6.5", r: ".5", fill: "currentColor", key: "1okk4w" }],
  ["circle", { cx: "17.5", cy: "10.5", r: ".5", fill: "currentColor", key: "f64h9f" }],
  ["circle", { cx: "6.5", cy: "12.5", r: ".5", fill: "currentColor", key: "qy21gx" }],
  ["circle", { cx: "8.5", cy: "7.5", r: ".5", fill: "currentColor", key: "fotxhn" }]
], Xm = Nn("palette", $m);
/**
 * @license lucide-react v0.563.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Km = [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" }],
  ["path", { d: "M3 9h18", key: "1pudct" }],
  ["path", { d: "M9 21V9", key: "1oto5p" }]
], Qm = Nn("panels-top-left", Km);
/**
 * @license lucide-react v0.563.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Jm = [
  [
    "path",
    {
      d: "M15.707 21.293a1 1 0 0 1-1.414 0l-1.586-1.586a1 1 0 0 1 0-1.414l5.586-5.586a1 1 0 0 1 1.414 0l1.586 1.586a1 1 0 0 1 0 1.414z",
      key: "nt11vn"
    }
  ],
  [
    "path",
    {
      d: "m18 13-1.375-6.874a1 1 0 0 0-.746-.776L3.235 2.028a1 1 0 0 0-1.207 1.207L5.35 15.879a1 1 0 0 0 .776.746L13 18",
      key: "15qc1e"
    }
  ],
  ["path", { d: "m2.3 2.3 7.286 7.286", key: "1wuzzi" }],
  ["circle", { cx: "11", cy: "11", r: "2", key: "xmgehs" }]
], Zm = Nn("pen-tool", Jm);
/**
 * @license lucide-react v0.563.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const e5 = [
  ["circle", { cx: "6", cy: "6", r: "3", key: "1lh9wr" }],
  ["path", { d: "M8.12 8.12 12 12", key: "1alkpv" }],
  ["path", { d: "M20 4 8.12 15.88", key: "xgtan2" }],
  ["circle", { cx: "6", cy: "18", r: "3", key: "fqmcym" }],
  ["path", { d: "M14.8 14.8 20 20", key: "ptml3r" }]
], t5 = Nn("scissors", e5);
/**
 * @license lucide-react v0.563.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const n5 = [
  [
    "path",
    {
      d: "M9.671 4.136a2.34 2.34 0 0 1 4.659 0 2.34 2.34 0 0 0 3.319 1.915 2.34 2.34 0 0 1 2.33 4.033 2.34 2.34 0 0 0 0 3.831 2.34 2.34 0 0 1-2.33 4.033 2.34 2.34 0 0 0-3.319 1.915 2.34 2.34 0 0 1-4.659 0 2.34 2.34 0 0 0-3.32-1.915 2.34 2.34 0 0 1-2.33-4.033 2.34 2.34 0 0 0 0-3.831A2.34 2.34 0 0 1 6.35 6.051a2.34 2.34 0 0 0 3.319-1.915",
      key: "1i5ecw"
    }
  ],
  ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }]
], r5 = Nn("settings", n5);
/**
 * @license lucide-react v0.563.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const i5 = [
  ["path", { d: "M16 3h5v5", key: "1806ms" }],
  ["path", { d: "M8 3H3v5", key: "15dfkv" }],
  ["path", { d: "M12 22v-8.3a4 4 0 0 0-1.172-2.872L3 3", key: "1qrqzj" }],
  ["path", { d: "m15 9 6-6", key: "ko1vev" }]
], a5 = Nn("split", i5);
/**
 * @license lucide-react v0.563.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const s5 = [
  ["path", { d: "M21 5H3", key: "1fi0y6" }],
  ["path", { d: "M17 12H7", key: "16if0g" }],
  ["path", { d: "M19 19H5", key: "vjpgq2" }]
], o5 = Nn("text-align-center", s5);
/**
 * @license lucide-react v0.563.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const u5 = [
  ["path", { d: "M21 5H3", key: "1fi0y6" }],
  ["path", { d: "M21 12H9", key: "dn1m92" }],
  ["path", { d: "M21 19H7", key: "4cu937" }]
], l5 = Nn("text-align-end", u5);
/**
 * @license lucide-react v0.563.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const c5 = [
  ["path", { d: "M21 5H3", key: "1fi0y6" }],
  ["path", { d: "M15 12H3", key: "6jk70r" }],
  ["path", { d: "M17 19H3", key: "z6ezky" }]
], f5 = Nn("text-align-start", c5);
/**
 * @license lucide-react v0.563.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const h5 = [
  ["path", { d: "M12 4v16", key: "1654pz" }],
  ["path", { d: "M4 7V5a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1v2", key: "e0r10z" }],
  ["path", { d: "M9 20h6", key: "s66wpe" }]
], Xd = Nn("type", h5), d5 = ({ config: e, onChange: t }) => {
  const n = (i, a) => {
    t({ ...e, [i]: a });
  }, r = [
    { id: "h1-h2", label: "H1/H2 æ ‡é¢˜åˆ‡å‰²", desc: "åœ¨é¡¶çº§æ ‡é¢˜å¤„è‡ªåŠ¨åˆ†é¡µ" },
    { id: "hr", label: "ä»…åˆ†å‰²çº¿åˆ‡å‰²", desc: "ä»…åœ¨ --- å¤„æ‰‹åŠ¨åˆ†é¡µ" },
    { id: "all-headers", label: "æ‰€æœ‰æ ‡é¢˜åˆ‡å‰²", desc: "åœ¨ä»»ä½•çº§åˆ«æ ‡é¢˜å¤„åˆ†é¡µ" },
    { id: "auto", label: "æ™ºèƒ½æ··åˆåˆ‡å‰²", desc: "æ ‡é¢˜ä¸åˆ†å‰²çº¿å‡è§¦å‘åˆ†é¡µ" }
  ];
  return /* @__PURE__ */ Ke("div", { className: "flex flex-col gap-6 p-6 overflow-y-auto h-full", children: [
    /* @__PURE__ */ Ke("div", { className: "flex items-center gap-2 text-slate-800 font-bold mb-2", children: [
      /* @__PURE__ */ De(r5, { size: 20, className: "text-blue-600" }),
      /* @__PURE__ */ De("h2", { children: "é…ç½®é€‰é¡¹" })
    ] }),
    /* @__PURE__ */ Ke("section", { className: "space-y-3", children: [
      /* @__PURE__ */ Ke("label", { className: "flex items-center gap-2 text-sm font-medium text-slate-600", children: [
        /* @__PURE__ */ De(Xm, { size: 16 }),
        " ä¸»é¢˜é£æ ¼"
      ] }),
      /* @__PURE__ */ De("div", { className: "grid grid-cols-1 gap-2", children: Object.entries(Vd).map(([i, a]) => /* @__PURE__ */ De(
        "button",
        {
          onClick: () => n("theme", i),
          className: `text-left px-4 py-3 rounded-lg border transition-all ${e.theme === i ? "border-blue-600 bg-blue-50 text-blue-700 shadow-sm ring-2 ring-blue-100" : "border-slate-200 bg-white hover:bg-slate-50 text-slate-700"}`,
          children: /* @__PURE__ */ De("div", { className: "font-semibold", children: a.name })
        },
        i
      )) })
    ] }),
    /* @__PURE__ */ Ke("section", { className: "space-y-4", children: [
      /* @__PURE__ */ Ke("div", { className: "flex items-center gap-2 text-sm font-medium text-slate-600", children: [
        /* @__PURE__ */ De(t5, { size: 16 }),
        " åˆ†é¡µåˆ‡å‰²æ–¹å¼"
      ] }),
      /* @__PURE__ */ De("div", { className: "space-y-2", children: r.map((i) => /* @__PURE__ */ Ke(
        "button",
        {
          onClick: () => n("splitMode", i.id),
          className: `w-full text-left p-3 rounded-xl border transition-all ${e.splitMode === i.id ? "border-blue-500 bg-blue-50 shadow-sm" : "border-slate-200 bg-white hover:bg-slate-50"}`,
          children: [
            /* @__PURE__ */ De("div", { className: `text-sm font-semibold ${e.splitMode === i.id ? "text-blue-700" : "text-slate-700"}`, children: i.label }),
            /* @__PURE__ */ De("div", { className: "text-[10px] text-slate-500 mt-0.5", children: i.desc })
          ]
        },
        i.id
      )) })
    ] }),
    /* @__PURE__ */ Ke("section", { className: "space-y-4", children: [
      /* @__PURE__ */ Ke("div", { className: "flex items-center gap-2 text-sm font-medium text-slate-600", children: [
        /* @__PURE__ */ De(Qm, { size: 16 }),
        " å¸ƒå±€ä¸å°ºå¯¸"
      ] }),
      /* @__PURE__ */ Ke("div", { className: "space-y-4 bg-white p-4 rounded-xl border border-slate-200 shadow-sm", children: [
        /* @__PURE__ */ Ke("div", { children: [
          /* @__PURE__ */ De("div", { className: "flex justify-between text-xs text-slate-500 mb-1", children: /* @__PURE__ */ Ke("span", { children: [
            "ç”»å¸ƒå®½åº¦: ",
            e.width,
            "px"
          ] }) }),
          /* @__PURE__ */ De(
            "input",
            {
              type: "range",
              min: "400",
              max: "1200",
              step: "50",
              value: e.width,
              onChange: (i) => n("width", parseInt(i.target.value)),
              className: "w-full h-1.5 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-blue-600"
            }
          )
        ] }),
        /* @__PURE__ */ Ke("div", { children: [
          /* @__PURE__ */ De("div", { className: "flex justify-between text-xs text-slate-500 mb-1", children: /* @__PURE__ */ Ke("span", { children: [
            "å†…è¾¹è·: ",
            e.padding,
            "px"
          ] }) }),
          /* @__PURE__ */ De(
            "input",
            {
              type: "range",
              min: "16",
              max: "100",
              step: "4",
              value: e.padding,
              onChange: (i) => n("padding", parseInt(i.target.value)),
              className: "w-full h-1.5 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-blue-600"
            }
          )
        ] })
      ] })
    ] }),
    /* @__PURE__ */ Ke("section", { className: "space-y-4", children: [
      /* @__PURE__ */ Ke("div", { className: "flex items-center gap-2 text-sm font-medium text-slate-600", children: [
        /* @__PURE__ */ De(Ym, { size: 16 }),
        " å›¾ç‰‡è°ƒæ•´"
      ] }),
      /* @__PURE__ */ Ke("div", { className: "space-y-4 bg-white p-4 rounded-xl border border-slate-200 shadow-sm", children: [
        /* @__PURE__ */ Ke("div", { children: [
          /* @__PURE__ */ De("div", { className: "flex justify-between text-xs text-slate-500 mb-1", children: /* @__PURE__ */ Ke("span", { children: [
            "åœ†è§’å¤§å°: ",
            e.imageBorderRadius,
            "px"
          ] }) }),
          /* @__PURE__ */ De(
            "input",
            {
              type: "range",
              min: "0",
              max: "40",
              step: "1",
              value: e.imageBorderRadius,
              onChange: (i) => n("imageBorderRadius", parseInt(i.target.value)),
              className: "w-full h-1.5 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-blue-600"
            }
          )
        ] }),
        /* @__PURE__ */ Ke("div", { children: [
          /* @__PURE__ */ De("div", { className: "flex justify-between text-xs text-slate-500 mb-1", children: /* @__PURE__ */ Ke("span", { children: [
            "é˜´å½±å¼ºåº¦: ",
            e.imageShadow,
            "px"
          ] }) }),
          /* @__PURE__ */ De(
            "input",
            {
              type: "range",
              min: "0",
              max: "30",
              step: "1",
              value: e.imageShadow,
              onChange: (i) => n("imageShadow", parseInt(i.target.value)),
              className: "w-full h-1.5 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-blue-600"
            }
          )
        ] }),
        /* @__PURE__ */ Ke("div", { children: [
          /* @__PURE__ */ De("div", { className: "flex justify-between text-xs text-slate-500 mb-1", children: /* @__PURE__ */ Ke("span", { children: [
            "å›¾ç‰‡æ˜¾ç¤ºå®½åº¦: ",
            e.imageWidthPercent,
            "%"
          ] }) }),
          /* @__PURE__ */ De(
            "input",
            {
              type: "range",
              min: "10",
              max: "100",
              step: "5",
              value: e.imageWidthPercent,
              onChange: (i) => n("imageWidthPercent", parseInt(i.target.value)),
              className: "w-full h-1.5 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-blue-600"
            }
          )
        ] }),
        /* @__PURE__ */ Ke("div", { className: "flex gap-2 pt-1", children: [
          /* @__PURE__ */ De(
            "button",
            {
              onClick: () => n("imageAlignment", "left"),
              className: `flex-1 py-1.5 flex items-center justify-center rounded border transition-colors ${e.imageAlignment === "left" ? "bg-blue-600 text-white border-blue-600" : "bg-white text-slate-600 border-slate-200 hover:bg-slate-50"}`,
              children: /* @__PURE__ */ De(f5, { size: 14 })
            }
          ),
          /* @__PURE__ */ De(
            "button",
            {
              onClick: () => n("imageAlignment", "center"),
              className: `flex-1 py-1.5 flex items-center justify-center rounded border transition-colors ${e.imageAlignment === "center" ? "bg-blue-600 text-white border-blue-600" : "bg-white text-slate-600 border-slate-200 hover:bg-slate-50"}`,
              children: /* @__PURE__ */ De(o5, { size: 14 })
            }
          ),
          /* @__PURE__ */ De(
            "button",
            {
              onClick: () => n("imageAlignment", "right"),
              className: `flex-1 py-1.5 flex items-center justify-center rounded border transition-colors ${e.imageAlignment === "right" ? "bg-blue-600 text-white border-blue-600" : "bg-white text-slate-600 border-slate-200 hover:bg-slate-50"}`,
              children: /* @__PURE__ */ De(l5, { size: 14 })
            }
          )
        ] })
      ] })
    ] }),
    /* @__PURE__ */ Ke("section", { className: "space-y-4", children: [
      /* @__PURE__ */ Ke("div", { className: "flex items-center gap-2 text-sm font-medium text-slate-600", children: [
        /* @__PURE__ */ De(Xd, { size: 16 }),
        " å­—ä½“æ’ç‰ˆ"
      ] }),
      /* @__PURE__ */ Ke("div", { className: "space-y-4 bg-white p-4 rounded-xl border border-slate-200 shadow-sm", children: [
        /* @__PURE__ */ Ke("div", { children: [
          /* @__PURE__ */ De("div", { className: "flex justify-between text-xs text-slate-500 mb-1", children: /* @__PURE__ */ Ke("span", { children: [
            "å­—ä½“å¤§å°: ",
            e.fontSize,
            "px"
          ] }) }),
          /* @__PURE__ */ De(
            "input",
            {
              type: "range",
              min: "12",
              max: "32",
              step: "1",
              value: e.fontSize,
              onChange: (i) => n("fontSize", parseInt(i.target.value)),
              className: "w-full h-1.5 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-blue-600"
            }
          )
        ] }),
        /* @__PURE__ */ Ke("div", { children: [
          /* @__PURE__ */ De("div", { className: "flex justify-between text-xs text-slate-500 mb-1", children: /* @__PURE__ */ Ke("span", { children: [
            "è¡Œé«˜: ",
            e.lineHeight
          ] }) }),
          /* @__PURE__ */ De(
            "input",
            {
              type: "range",
              min: "1",
              max: "2.5",
              step: "0.1",
              value: e.lineHeight,
              onChange: (i) => n("lineHeight", parseFloat(i.target.value)),
              className: "w-full h-1.5 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-blue-600"
            }
          )
        ] }),
        /* @__PURE__ */ De("div", { className: "flex gap-2", children: ["sans", "serif", "mono"].map((i) => /* @__PURE__ */ De(
          "button",
          {
            onClick: () => n("fontFamily", i),
            className: `flex-1 py-1.5 text-xs font-medium rounded border transition-colors ${e.fontFamily === i ? "bg-blue-600 text-white border-blue-600" : "bg-white text-slate-600 border-slate-200 hover:bg-slate-50"}`,
            children: i === "sans" ? "æ— è¡¬çº¿" : i === "serif" ? "è¡¬çº¿ä½“" : "ç­‰å®½ä½“"
          },
          i
        )) })
      ] })
    ] }),
    /* @__PURE__ */ Ke("section", { className: "space-y-3", children: [
      /* @__PURE__ */ Ke("div", { className: "flex items-center justify-between", children: [
        /* @__PURE__ */ Ke("label", { className: "flex items-center gap-2 text-sm font-medium text-slate-600", children: [
          /* @__PURE__ */ De($d, { size: 16 }),
          " æ°´å°è®¾ç½®"
        ] }),
        /* @__PURE__ */ De(
          "input",
          {
            type: "checkbox",
            checked: e.showWatermark,
            onChange: (i) => n("showWatermark", i.target.checked),
            className: "w-4 h-4 rounded text-blue-600 border-slate-300 focus:ring-blue-500 cursor-pointer"
          }
        )
      ] }),
      e.showWatermark && /* @__PURE__ */ De(
        "input",
        {
          type: "text",
          value: e.watermarkText,
          onChange: (i) => n("watermarkText", i.target.value),
          placeholder: "è‡ªå®šä¹‰æ°´å°æ–‡å­—...",
          className: "w-full px-3 py-2 text-sm bg-white border border-slate-200 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 shadow-sm"
        }
      )
    ] })
  ] });
};
function dh(e) {
  const t = [], n = String(e || "");
  let r = n.indexOf(","), i = 0, a = !1;
  for (; !a; ) {
    r === -1 && (r = n.length, a = !0);
    const s = n.slice(i, r).trim();
    (s || !a) && t.push(s), i = r + 1, r = n.indexOf(",", i);
  }
  return t;
}
function Kd(e, t) {
  const n = {};
  return (e[e.length - 1] === "" ? [...e, ""] : e).join(
    (n.padRight ? " " : "") + "," + (n.padLeft === !1 ? "" : " ")
  ).trim();
}
const p5 = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, m5 = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, g5 = {};
function ph(e, t) {
  return (g5.jsx ? m5 : p5).test(e);
}
const b5 = /[ \t\n\f\r]/g;
function E5(e) {
  return typeof e == "object" ? e.type === "text" ? mh(e.value) : !1 : mh(e);
}
function mh(e) {
  return e.replace(b5, "") === "";
}
class Eo {
  /**
   * @param {SchemaType['property']} property
   *   Property.
   * @param {SchemaType['normal']} normal
   *   Normal.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Schema.
   */
  constructor(t, n, r) {
    this.normal = n, this.property = t, r && (this.space = r);
  }
}
Eo.prototype.normal = {};
Eo.prototype.property = {};
Eo.prototype.space = void 0;
function Qd(e, t) {
  const n = {}, r = {};
  for (const i of e)
    Object.assign(n, i.property), Object.assign(r, i.normal);
  return new Eo(n, r, t);
}
function fo(e) {
  return e.toLowerCase();
}
class tr {
  /**
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @returns
   *   Info.
   */
  constructor(t, n) {
    this.attribute = n, this.property = t;
  }
}
tr.prototype.attribute = "";
tr.prototype.booleanish = !1;
tr.prototype.boolean = !1;
tr.prototype.commaOrSpaceSeparated = !1;
tr.prototype.commaSeparated = !1;
tr.prototype.defined = !1;
tr.prototype.mustUseProperty = !1;
tr.prototype.number = !1;
tr.prototype.overloadedBoolean = !1;
tr.prototype.property = "";
tr.prototype.spaceSeparated = !1;
tr.prototype.space = void 0;
let y5 = 0;
const wt = ka(), En = ka(), wc = ka(), Me = ka(), Xt = ka(), is = ka(), dr = ka();
function ka() {
  return 2 ** ++y5;
}
const xc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: wt,
  booleanish: En,
  commaOrSpaceSeparated: dr,
  commaSeparated: is,
  number: Me,
  overloadedBoolean: wc,
  spaceSeparated: Xt
}, Symbol.toStringTag, { value: "Module" })), Dl = (
  /** @type {ReadonlyArray<keyof typeof types>} */
  Object.keys(xc)
);
class Qc extends tr {
  /**
   * @constructor
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @param {number | null | undefined} [mask]
   *   Mask.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Info.
   */
  constructor(t, n, r, i) {
    let a = -1;
    if (super(t, n), gh(this, "space", i), typeof r == "number")
      for (; ++a < Dl.length; ) {
        const s = Dl[a];
        gh(this, Dl[a], (r & xc[s]) === xc[s]);
      }
  }
}
Qc.prototype.defined = !0;
function gh(e, t, n) {
  n && (e[t] = n);
}
function hs(e) {
  const t = {}, n = {};
  for (const [r, i] of Object.entries(e.properties)) {
    const a = new Qc(
      r,
      e.transform(e.attributes || {}, r),
      i,
      e.space
    );
    e.mustUseProperty && e.mustUseProperty.includes(r) && (a.mustUseProperty = !0), t[r] = a, n[fo(r)] = r, n[fo(a.attribute)] = r;
  }
  return new Eo(t, n, e.space);
}
const Jd = hs({
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: En,
    ariaAutoComplete: null,
    ariaBusy: En,
    ariaChecked: En,
    ariaColCount: Me,
    ariaColIndex: Me,
    ariaColSpan: Me,
    ariaControls: Xt,
    ariaCurrent: null,
    ariaDescribedBy: Xt,
    ariaDetails: null,
    ariaDisabled: En,
    ariaDropEffect: Xt,
    ariaErrorMessage: null,
    ariaExpanded: En,
    ariaFlowTo: Xt,
    ariaGrabbed: En,
    ariaHasPopup: null,
    ariaHidden: En,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: Xt,
    ariaLevel: Me,
    ariaLive: null,
    ariaModal: En,
    ariaMultiLine: En,
    ariaMultiSelectable: En,
    ariaOrientation: null,
    ariaOwns: Xt,
    ariaPlaceholder: null,
    ariaPosInSet: Me,
    ariaPressed: En,
    ariaReadOnly: En,
    ariaRelevant: null,
    ariaRequired: En,
    ariaRoleDescription: Xt,
    ariaRowCount: Me,
    ariaRowIndex: Me,
    ariaRowSpan: Me,
    ariaSelected: En,
    ariaSetSize: Me,
    ariaSort: null,
    ariaValueMax: Me,
    ariaValueMin: Me,
    ariaValueNow: Me,
    ariaValueText: null,
    role: null
  },
  transform(e, t) {
    return t === "role" ? t : "aria-" + t.slice(4).toLowerCase();
  }
});
function Zd(e, t) {
  return t in e ? e[t] : t;
}
function e1(e, t) {
  return Zd(e, t.toLowerCase());
}
const T5 = hs({
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: is,
    acceptCharset: Xt,
    accessKey: Xt,
    action: null,
    allow: null,
    allowFullScreen: wt,
    allowPaymentRequest: wt,
    allowUserMedia: wt,
    alt: null,
    as: null,
    async: wt,
    autoCapitalize: null,
    autoComplete: Xt,
    autoFocus: wt,
    autoPlay: wt,
    blocking: Xt,
    capture: null,
    charSet: null,
    checked: wt,
    cite: null,
    className: Xt,
    cols: Me,
    colSpan: null,
    content: null,
    contentEditable: En,
    controls: wt,
    controlsList: Xt,
    coords: Me | is,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: wt,
    defer: wt,
    dir: null,
    dirName: null,
    disabled: wt,
    download: wc,
    draggable: En,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: wt,
    formTarget: null,
    headers: Xt,
    height: Me,
    hidden: wc,
    high: Me,
    href: null,
    hrefLang: null,
    htmlFor: Xt,
    httpEquiv: Xt,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: wt,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: wt,
    itemId: null,
    itemProp: Xt,
    itemRef: Xt,
    itemScope: wt,
    itemType: Xt,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: wt,
    low: Me,
    manifest: null,
    max: null,
    maxLength: Me,
    media: null,
    method: null,
    min: null,
    minLength: Me,
    multiple: wt,
    muted: wt,
    name: null,
    nonce: null,
    noModule: wt,
    noValidate: wt,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: wt,
    optimum: Me,
    pattern: null,
    ping: Xt,
    placeholder: null,
    playsInline: wt,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: wt,
    referrerPolicy: null,
    rel: Xt,
    required: wt,
    reversed: wt,
    rows: Me,
    rowSpan: Me,
    sandbox: Xt,
    scope: null,
    scoped: wt,
    seamless: wt,
    selected: wt,
    shadowRootClonable: wt,
    shadowRootDelegatesFocus: wt,
    shadowRootMode: null,
    shape: null,
    size: Me,
    sizes: null,
    slot: null,
    span: Me,
    spellCheck: En,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: Me,
    step: null,
    style: null,
    tabIndex: Me,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: wt,
    useMap: null,
    value: En,
    width: Me,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: Xt,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: Me,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: Me,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: wt,
    // Lists. Use CSS to reduce space between items instead
    declare: wt,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: Me,
    // `<img>` and `<object>`
    leftMargin: Me,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: Me,
    // `<body>`
    marginWidth: Me,
    // `<body>`
    noResize: wt,
    // `<frame>`
    noHref: wt,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: wt,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: wt,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: Me,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: En,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: Me,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: Me,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: wt,
    disableRemotePlayback: wt,
    prefix: null,
    property: null,
    results: Me,
    security: null,
    unselectable: null
  },
  space: "html",
  transform: e1
}), _5 = hs({
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  properties: {
    about: dr,
    accentHeight: Me,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: Me,
    amplitude: Me,
    arabicForm: null,
    ascent: Me,
    attributeName: null,
    attributeType: null,
    azimuth: Me,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: Me,
    by: null,
    calcMode: null,
    capHeight: Me,
    className: Xt,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: Me,
    diffuseConstant: Me,
    direction: null,
    display: null,
    dur: null,
    divisor: Me,
    dominantBaseline: null,
    download: wt,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: Me,
    enableBackground: null,
    end: null,
    event: null,
    exponent: Me,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: Me,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: is,
    g2: is,
    glyphName: is,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: Me,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: Me,
    horizOriginX: Me,
    horizOriginY: Me,
    id: null,
    ideographic: Me,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: Me,
    k: Me,
    k1: Me,
    k2: Me,
    k3: Me,
    k4: Me,
    kernelMatrix: dr,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: Me,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: Me,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: Me,
    overlineThickness: Me,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: Me,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: Xt,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: Me,
    pointsAtY: Me,
    pointsAtZ: Me,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: dr,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: dr,
    rev: dr,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: dr,
    requiredFeatures: dr,
    requiredFonts: dr,
    requiredFormats: dr,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: Me,
    specularExponent: Me,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: Me,
    strikethroughThickness: Me,
    string: null,
    stroke: null,
    strokeDashArray: dr,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: Me,
    strokeOpacity: Me,
    strokeWidth: null,
    style: null,
    surfaceScale: Me,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: dr,
    tabIndex: Me,
    tableValues: null,
    target: null,
    targetX: Me,
    targetY: Me,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: dr,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: Me,
    underlineThickness: Me,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: Me,
    values: null,
    vAlphabetic: Me,
    vMathematical: Me,
    vectorEffect: null,
    vHanging: Me,
    vIdeographic: Me,
    version: null,
    vertAdvY: Me,
    vertOriginX: Me,
    vertOriginY: Me,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: Me,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  },
  space: "svg",
  transform: Zd
}), t1 = hs({
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  },
  space: "xlink",
  transform(e, t) {
    return "xlink:" + t.slice(5).toLowerCase();
  }
}), n1 = hs({
  attributes: { xmlnsxlink: "xmlns:xlink" },
  properties: { xmlnsXLink: null, xmlns: null },
  space: "xmlns",
  transform: e1
}), r1 = hs({
  properties: { xmlBase: null, xmlLang: null, xmlSpace: null },
  space: "xml",
  transform(e, t) {
    return "xml:" + t.slice(3).toLowerCase();
  }
}), A5 = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
}, w5 = /[A-Z]/g, bh = /-[a-z]/g, x5 = /^data[-\w.:]+$/i;
function qu(e, t) {
  const n = fo(t);
  let r = t, i = tr;
  if (n in e.normal)
    return e.property[e.normal[n]];
  if (n.length > 4 && n.slice(0, 4) === "data" && x5.test(t)) {
    if (t.charAt(4) === "-") {
      const a = t.slice(5).replace(bh, v5);
      r = "data" + a.charAt(0).toUpperCase() + a.slice(1);
    } else {
      const a = t.slice(4);
      if (!bh.test(a)) {
        let s = a.replace(w5, N5);
        s.charAt(0) !== "-" && (s = "-" + s), t = "data" + s;
      }
    }
    i = Qc;
  }
  return new i(r, t);
}
function N5(e) {
  return "-" + e.toLowerCase();
}
function v5(e) {
  return e.charAt(1).toUpperCase();
}
const yo = Qd([Jd, T5, t1, n1, r1], "html"), ea = Qd([Jd, _5, t1, n1, r1], "svg");
function Eh(e) {
  const t = String(e || "").trim();
  return t ? t.split(/[ \t\n\r\f]+/g) : [];
}
function i1(e) {
  return e.join(" ").trim();
}
var I8 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function a1(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Va = {}, Ml, yh;
function S5() {
  if (yh) return Ml;
  yh = 1;
  var e = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, t = /\n/g, n = /^\s*/, r = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, i = /^:\s*/, a = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, s = /^[;\s]*/, o = /^\s+|\s+$/g, u = `
`, c = "/", f = "*", p = "", E = "comment", d = "declaration";
  function A(C, _) {
    if (typeof C != "string")
      throw new TypeError("First argument must be a string");
    if (!C) return [];
    _ = _ || {};
    var U = 1, B = 1;
    function V(Y) {
      var J = Y.match(t);
      J && (U += J.length);
      var ue = Y.lastIndexOf(u);
      B = ~ue ? Y.length - ue : B + Y.length;
    }
    function ie() {
      var Y = { line: U, column: B };
      return function(J) {
        return J.position = new K(Y), z(), J;
      };
    }
    function K(Y) {
      this.start = Y, this.end = { line: U, column: B }, this.source = _.source;
    }
    K.prototype.content = C;
    function fe(Y) {
      var J = new Error(
        _.source + ":" + U + ":" + B + ": " + Y
      );
      if (J.reason = Y, J.filename = _.source, J.line = U, J.column = B, J.source = C, !_.silent) throw J;
    }
    function Z(Y) {
      var J = Y.exec(C);
      if (J) {
        var ue = J[0];
        return V(ue), C = C.slice(ue.length), J;
      }
    }
    function z() {
      Z(n);
    }
    function D(Y) {
      var J;
      for (Y = Y || []; J = N(); )
        J !== !1 && Y.push(J);
      return Y;
    }
    function N() {
      var Y = ie();
      if (!(c != C.charAt(0) || f != C.charAt(1))) {
        for (var J = 2; p != C.charAt(J) && (f != C.charAt(J) || c != C.charAt(J + 1)); )
          ++J;
        if (J += 2, p === C.charAt(J - 1))
          return fe("End of comment missing");
        var ue = C.slice(2, J - 2);
        return B += 2, V(ue), C = C.slice(J), B += 2, Y({
          type: E,
          comment: ue
        });
      }
    }
    function I() {
      var Y = ie(), J = Z(r);
      if (J) {
        if (N(), !Z(i)) return fe("property missing ':'");
        var ue = Z(a), me = Y({
          type: d,
          property: v(J[0].replace(e, p)),
          value: ue ? v(ue[0].replace(e, p)) : p
        });
        return Z(s), me;
      }
    }
    function $() {
      var Y = [];
      D(Y);
      for (var J; J = I(); )
        J !== !1 && (Y.push(J), D(Y));
      return Y;
    }
    return z(), $();
  }
  function v(C) {
    return C ? C.replace(o, p) : p;
  }
  return Ml = A, Ml;
}
var Th;
function L5() {
  if (Th) return Va;
  Th = 1;
  var e = Va && Va.__importDefault || function(r) {
    return r && r.__esModule ? r : { default: r };
  };
  Object.defineProperty(Va, "__esModule", { value: !0 }), Va.default = n;
  const t = e(S5());
  function n(r, i) {
    let a = null;
    if (!r || typeof r != "string")
      return a;
    const s = (0, t.default)(r), o = typeof i == "function";
    return s.forEach((u) => {
      if (u.type !== "declaration")
        return;
      const { property: c, value: f } = u;
      o ? i(c, f, u) : f && (a = a || {}, a[c] = f);
    }), a;
  }
  return Va;
}
var Vs = {}, _h;
function k5() {
  if (_h) return Vs;
  _h = 1, Object.defineProperty(Vs, "__esModule", { value: !0 }), Vs.camelCase = void 0;
  var e = /^--[a-zA-Z0-9_-]+$/, t = /-([a-z])/g, n = /^[^-]+$/, r = /^-(webkit|moz|ms|o|khtml)-/, i = /^-(ms)-/, a = function(c) {
    return !c || n.test(c) || e.test(c);
  }, s = function(c, f) {
    return f.toUpperCase();
  }, o = function(c, f) {
    return "".concat(f, "-");
  }, u = function(c, f) {
    return f === void 0 && (f = {}), a(c) ? c : (c = c.toLowerCase(), f.reactCompat ? c = c.replace(i, o) : c = c.replace(r, o), c.replace(t, s));
  };
  return Vs.camelCase = u, Vs;
}
var Gs, Ah;
function C5() {
  if (Ah) return Gs;
  Ah = 1;
  var e = Gs && Gs.__importDefault || function(i) {
    return i && i.__esModule ? i : { default: i };
  }, t = e(L5()), n = k5();
  function r(i, a) {
    var s = {};
    return !i || typeof i != "string" || (0, t.default)(i, function(o, u) {
      o && u && (s[(0, n.camelCase)(o, a)] = u);
    }), s;
  }
  return r.default = r, Gs = r, Gs;
}
var I5 = C5();
const P5 = /* @__PURE__ */ a1(I5), zu = s1("end"), ni = s1("start");
function s1(e) {
  return t;
  function t(n) {
    const r = n && n.position && n.position[e] || {};
    if (typeof r.line == "number" && r.line > 0 && typeof r.column == "number" && r.column > 0)
      return {
        line: r.line,
        column: r.column,
        offset: typeof r.offset == "number" && r.offset > -1 ? r.offset : void 0
      };
  }
}
function O5(e) {
  const t = ni(e), n = zu(e);
  if (t && n)
    return { start: t, end: n };
}
function to(e) {
  return !e || typeof e != "object" ? "" : "position" in e || "type" in e ? wh(e.position) : "start" in e || "end" in e ? wh(e) : "line" in e || "column" in e ? Nc(e) : "";
}
function Nc(e) {
  return xh(e && e.line) + ":" + xh(e && e.column);
}
function wh(e) {
  return Nc(e && e.start) + "-" + Nc(e && e.end);
}
function xh(e) {
  return e && typeof e == "number" ? e : 1;
}
class zn extends Error {
  /**
   * Create a message for `reason`.
   *
   * > ğŸª¦ **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(t, n, r) {
    super(), typeof n == "string" && (r = n, n = void 0);
    let i = "", a = {}, s = !1;
    if (n && ("line" in n && "column" in n ? a = { place: n } : "start" in n && "end" in n ? a = { place: n } : "type" in n ? a = {
      ancestors: [n],
      place: n.position
    } : a = { ...n }), typeof t == "string" ? i = t : !a.cause && t && (s = !0, i = t.message, a.cause = t), !a.ruleId && !a.source && typeof r == "string") {
      const u = r.indexOf(":");
      u === -1 ? a.ruleId = r : (a.source = r.slice(0, u), a.ruleId = r.slice(u + 1));
    }
    if (!a.place && a.ancestors && a.ancestors) {
      const u = a.ancestors[a.ancestors.length - 1];
      u && (a.place = u.position);
    }
    const o = a.place && "start" in a.place ? a.place.start : a.place;
    this.ancestors = a.ancestors || void 0, this.cause = a.cause || void 0, this.column = o ? o.column : void 0, this.fatal = void 0, this.file = "", this.message = i, this.line = o ? o.line : void 0, this.name = to(a.place) || "1:1", this.place = a.place || void 0, this.reason = this.message, this.ruleId = a.ruleId || void 0, this.source = a.source || void 0, this.stack = s && a.cause && typeof a.cause.stack == "string" ? a.cause.stack : "", this.actual = void 0, this.expected = void 0, this.note = void 0, this.url = void 0;
  }
}
zn.prototype.file = "";
zn.prototype.name = "";
zn.prototype.reason = "";
zn.prototype.message = "";
zn.prototype.stack = "";
zn.prototype.column = void 0;
zn.prototype.line = void 0;
zn.prototype.ancestors = void 0;
zn.prototype.cause = void 0;
zn.prototype.fatal = void 0;
zn.prototype.place = void 0;
zn.prototype.ruleId = void 0;
zn.prototype.source = void 0;
const Jc = {}.hasOwnProperty, R5 = /* @__PURE__ */ new Map(), D5 = /[A-Z]/g, M5 = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]), F5 = /* @__PURE__ */ new Set(["td", "th"]), o1 = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
function B5(e, t) {
  if (!t || t.Fragment === void 0)
    throw new TypeError("Expected `Fragment` in options");
  const n = t.filePath || void 0;
  let r;
  if (t.development) {
    if (typeof t.jsxDEV != "function")
      throw new TypeError(
        "Expected `jsxDEV` in options when `development: true`"
      );
    r = V5(n, t.jsxDEV);
  } else {
    if (typeof t.jsx != "function")
      throw new TypeError("Expected `jsx` in production options");
    if (typeof t.jsxs != "function")
      throw new TypeError("Expected `jsxs` in production options");
    r = W5(n, t.jsx, t.jsxs);
  }
  const i = {
    Fragment: t.Fragment,
    ancestors: [],
    components: t.components || {},
    create: r,
    elementAttributeNameCase: t.elementAttributeNameCase || "react",
    evaluater: t.createEvaluater ? t.createEvaluater() : void 0,
    filePath: n,
    ignoreInvalidStyle: t.ignoreInvalidStyle || !1,
    passKeys: t.passKeys !== !1,
    passNode: t.passNode || !1,
    schema: t.space === "svg" ? ea : yo,
    stylePropertyNameCase: t.stylePropertyNameCase || "dom",
    tableCellAlignToStyle: t.tableCellAlignToStyle !== !1
  }, a = u1(i, e, void 0);
  return a && typeof a != "string" ? a : i.create(
    e,
    i.Fragment,
    { children: a || void 0 },
    void 0
  );
}
function u1(e, t, n) {
  if (t.type === "element")
    return U5(e, t, n);
  if (t.type === "mdxFlowExpression" || t.type === "mdxTextExpression")
    return H5(e, t);
  if (t.type === "mdxJsxFlowElement" || t.type === "mdxJsxTextElement")
    return q5(e, t, n);
  if (t.type === "mdxjsEsm")
    return j5(e, t);
  if (t.type === "root")
    return z5(e, t, n);
  if (t.type === "text")
    return Y5(e, t);
}
function U5(e, t, n) {
  const r = e.schema;
  let i = r;
  t.tagName.toLowerCase() === "svg" && r.space === "html" && (i = ea, e.schema = i), e.ancestors.push(t);
  const a = c1(e, t.tagName, !1), s = G5(e, t);
  let o = ef(e, t);
  return M5.has(t.tagName) && (o = o.filter(function(u) {
    return typeof u == "string" ? !E5(u) : !0;
  })), l1(e, s, a, t), Zc(s, o), e.ancestors.pop(), e.schema = r, e.create(t, a, s, n);
}
function H5(e, t) {
  if (t.data && t.data.estree && e.evaluater) {
    const r = t.data.estree.body[0];
    return r.type, /** @type {Child | undefined} */
    e.evaluater.evaluateExpression(r.expression);
  }
  ho(e, t.position);
}
function j5(e, t) {
  if (t.data && t.data.estree && e.evaluater)
    return (
      /** @type {Child | undefined} */
      e.evaluater.evaluateProgram(t.data.estree)
    );
  ho(e, t.position);
}
function q5(e, t, n) {
  const r = e.schema;
  let i = r;
  t.name === "svg" && r.space === "html" && (i = ea, e.schema = i), e.ancestors.push(t);
  const a = t.name === null ? e.Fragment : c1(e, t.name, !0), s = $5(e, t), o = ef(e, t);
  return l1(e, s, a, t), Zc(s, o), e.ancestors.pop(), e.schema = r, e.create(t, a, s, n);
}
function z5(e, t, n) {
  const r = {};
  return Zc(r, ef(e, t)), e.create(t, e.Fragment, r, n);
}
function Y5(e, t) {
  return t.value;
}
function l1(e, t, n, r) {
  typeof n != "string" && n !== e.Fragment && e.passNode && (t.node = r);
}
function Zc(e, t) {
  if (t.length > 0) {
    const n = t.length > 1 ? t : t[0];
    n && (e.children = n);
  }
}
function W5(e, t, n) {
  return r;
  function r(i, a, s, o) {
    const c = Array.isArray(s.children) ? n : t;
    return o ? c(a, s, o) : c(a, s);
  }
}
function V5(e, t) {
  return n;
  function n(r, i, a, s) {
    const o = Array.isArray(a.children), u = ni(r);
    return t(
      i,
      a,
      s,
      o,
      {
        columnNumber: u ? u.column - 1 : void 0,
        fileName: e,
        lineNumber: u ? u.line : void 0
      },
      void 0
    );
  }
}
function G5(e, t) {
  const n = {};
  let r, i;
  for (i in t.properties)
    if (i !== "children" && Jc.call(t.properties, i)) {
      const a = X5(e, i, t.properties[i]);
      if (a) {
        const [s, o] = a;
        e.tableCellAlignToStyle && s === "align" && typeof o == "string" && F5.has(t.tagName) ? r = o : n[s] = o;
      }
    }
  if (r) {
    const a = (
      /** @type {Style} */
      n.style || (n.style = {})
    );
    a[e.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = r;
  }
  return n;
}
function $5(e, t) {
  const n = {};
  for (const r of t.attributes)
    if (r.type === "mdxJsxExpressionAttribute")
      if (r.data && r.data.estree && e.evaluater) {
        const a = r.data.estree.body[0];
        a.type;
        const s = a.expression;
        s.type;
        const o = s.properties[0];
        o.type, Object.assign(
          n,
          e.evaluater.evaluateExpression(o.argument)
        );
      } else
        ho(e, t.position);
    else {
      const i = r.name;
      let a;
      if (r.value && typeof r.value == "object")
        if (r.value.data && r.value.data.estree && e.evaluater) {
          const o = r.value.data.estree.body[0];
          o.type, a = e.evaluater.evaluateExpression(o.expression);
        } else
          ho(e, t.position);
      else
        a = r.value === null ? !0 : r.value;
      n[i] = /** @type {Props[keyof Props]} */
      a;
    }
  return n;
}
function ef(e, t) {
  const n = [];
  let r = -1;
  const i = e.passKeys ? /* @__PURE__ */ new Map() : R5;
  for (; ++r < t.children.length; ) {
    const a = t.children[r];
    let s;
    if (e.passKeys) {
      const u = a.type === "element" ? a.tagName : a.type === "mdxJsxFlowElement" || a.type === "mdxJsxTextElement" ? a.name : void 0;
      if (u) {
        const c = i.get(u) || 0;
        s = u + "-" + c, i.set(u, c + 1);
      }
    }
    const o = u1(e, a, s);
    o !== void 0 && n.push(o);
  }
  return n;
}
function X5(e, t, n) {
  const r = qu(e.schema, t);
  if (!(n == null || typeof n == "number" && Number.isNaN(n))) {
    if (Array.isArray(n) && (n = r.commaSeparated ? Kd(n) : i1(n)), r.property === "style") {
      let i = typeof n == "object" ? n : K5(e, String(n));
      return e.stylePropertyNameCase === "css" && (i = Q5(i)), ["style", i];
    }
    return [
      e.elementAttributeNameCase === "react" && r.space ? A5[r.property] || r.property : r.attribute,
      n
    ];
  }
}
function K5(e, t) {
  try {
    return P5(t, { reactCompat: !0 });
  } catch (n) {
    if (e.ignoreInvalidStyle)
      return {};
    const r = (
      /** @type {Error} */
      n
    ), i = new zn("Cannot parse `style` attribute", {
      ancestors: e.ancestors,
      cause: r,
      ruleId: "style",
      source: "hast-util-to-jsx-runtime"
    });
    throw i.file = e.filePath || void 0, i.url = o1 + "#cannot-parse-style-attribute", i;
  }
}
function c1(e, t, n) {
  let r;
  if (!n)
    r = { type: "Literal", value: t };
  else if (t.includes(".")) {
    const i = t.split(".");
    let a = -1, s;
    for (; ++a < i.length; ) {
      const o = ph(i[a]) ? { type: "Identifier", name: i[a] } : { type: "Literal", value: i[a] };
      s = s ? {
        type: "MemberExpression",
        object: s,
        property: o,
        computed: !!(a && o.type === "Literal"),
        optional: !1
      } : o;
    }
    r = s;
  } else
    r = ph(t) && !/^[a-z]/.test(t) ? { type: "Identifier", name: t } : { type: "Literal", value: t };
  if (r.type === "Literal") {
    const i = (
      /** @type {string | number} */
      r.value
    );
    return Jc.call(e.components, i) ? e.components[i] : i;
  }
  if (e.evaluater)
    return e.evaluater.evaluateExpression(r);
  ho(e);
}
function ho(e, t) {
  const n = new zn(
    "Cannot handle MDX estrees without `createEvaluater`",
    {
      ancestors: e.ancestors,
      place: t,
      ruleId: "mdx-estree",
      source: "hast-util-to-jsx-runtime"
    }
  );
  throw n.file = e.filePath || void 0, n.url = o1 + "#cannot-handle-mdx-estrees-without-createevaluater", n;
}
function Q5(e) {
  const t = {};
  let n;
  for (n in e)
    Jc.call(e, n) && (t[J5(n)] = e[n]);
  return t;
}
function J5(e) {
  let t = e.replace(D5, Z5);
  return t.slice(0, 3) === "ms-" && (t = "-" + t), t;
}
function Z5(e) {
  return "-" + e.toLowerCase();
}
const Fl = {
  action: ["form"],
  cite: ["blockquote", "del", "ins", "q"],
  data: ["object"],
  formAction: ["button", "input"],
  href: ["a", "area", "base", "link"],
  icon: ["menuitem"],
  itemId: null,
  manifest: ["html"],
  ping: ["a", "area"],
  poster: ["video"],
  src: [
    "audio",
    "embed",
    "iframe",
    "img",
    "input",
    "script",
    "source",
    "track",
    "video"
  ]
}, eg = {};
function tf(e, t) {
  const n = eg, r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0, i = typeof n.includeHtml == "boolean" ? n.includeHtml : !0;
  return f1(e, r, i);
}
function f1(e, t, n) {
  if (tg(e)) {
    if ("value" in e)
      return e.type === "html" && !n ? "" : e.value;
    if (t && "alt" in e && e.alt)
      return e.alt;
    if ("children" in e)
      return Nh(e.children, t, n);
  }
  return Array.isArray(e) ? Nh(e, t, n) : "";
}
function Nh(e, t, n) {
  const r = [];
  let i = -1;
  for (; ++i < e.length; )
    r[i] = f1(e[i], t, n);
  return r.join("");
}
function tg(e) {
  return !!(e && typeof e == "object");
}
const vh = document.createElement("i");
function nf(e) {
  const t = "&" + e + ";";
  vh.innerHTML = t;
  const n = vh.textContent;
  return n.charCodeAt(n.length - 1) === 59 && e !== "semi" || n === t ? !1 : n;
}
function mr(e, t, n, r) {
  const i = e.length;
  let a = 0, s;
  if (t < 0 ? t = -t > i ? 0 : i + t : t = t > i ? i : t, n = n > 0 ? n : 0, r.length < 1e4)
    s = Array.from(r), s.unshift(t, n), e.splice(...s);
  else
    for (n && e.splice(t, n); a < r.length; )
      s = r.slice(a, a + 1e4), s.unshift(t, 0), e.splice(...s), a += 1e4, t += 1e4;
}
function Nr(e, t) {
  return e.length > 0 ? (mr(e, e.length, 0, t), e) : t;
}
const Sh = {}.hasOwnProperty;
function h1(e) {
  const t = {};
  let n = -1;
  for (; ++n < e.length; )
    ng(t, e[n]);
  return t;
}
function ng(e, t) {
  let n;
  for (n in t) {
    const i = (Sh.call(e, n) ? e[n] : void 0) || (e[n] = {}), a = t[n];
    let s;
    if (a)
      for (s in a) {
        Sh.call(i, s) || (i[s] = []);
        const o = a[s];
        rg(
          // @ts-expect-error Looks like a list.
          i[s],
          Array.isArray(o) ? o : o ? [o] : []
        );
      }
  }
}
function rg(e, t) {
  let n = -1;
  const r = [];
  for (; ++n < t.length; )
    (t[n].add === "after" ? e : r).push(t[n]);
  mr(e, 0, 0, r);
}
function d1(e, t) {
  const n = Number.parseInt(e, t);
  return (
    // C0 except for HT, LF, FF, CR, space.
    n < 9 || n === 11 || n > 13 && n < 32 || // Control character (DEL) of C0, and C1 controls.
    n > 126 && n < 160 || // Lone high surrogates and low surrogates.
    n > 55295 && n < 57344 || // Noncharacters.
    n > 64975 && n < 65008 || /* eslint-disable no-bitwise */
    (n & 65535) === 65535 || (n & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    n > 1114111 ? "ï¿½" : String.fromCodePoint(n)
  );
}
function Fr(e) {
  return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const Xn = ta(/[A-Za-z]/), qn = ta(/[\dA-Za-z]/), ig = ta(/[#-'*+\--9=?A-Z^-~]/);
function Cu(e) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    e !== null && (e < 32 || e === 127)
  );
}
const vc = ta(/\d/), ag = ta(/[\dA-Fa-f]/), sg = ta(/[!-/:-@[-`{-~]/);
function st(e) {
  return e !== null && e < -2;
}
function Vt(e) {
  return e !== null && (e < 0 || e === 32);
}
function Lt(e) {
  return e === -2 || e === -1 || e === 32;
}
const Yu = ta(new RegExp("\\p{P}|\\p{S}", "u")), va = ta(/\s/);
function ta(e) {
  return t;
  function t(n) {
    return n !== null && n > -1 && e.test(String.fromCharCode(n));
  }
}
function ds(e) {
  const t = [];
  let n = -1, r = 0, i = 0;
  for (; ++n < e.length; ) {
    const a = e.charCodeAt(n);
    let s = "";
    if (a === 37 && qn(e.charCodeAt(n + 1)) && qn(e.charCodeAt(n + 2)))
      i = 2;
    else if (a < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(a)) || (s = String.fromCharCode(a));
    else if (a > 55295 && a < 57344) {
      const o = e.charCodeAt(n + 1);
      a < 56320 && o > 56319 && o < 57344 ? (s = String.fromCharCode(a, o), i = 1) : s = "ï¿½";
    } else
      s = String.fromCharCode(a);
    s && (t.push(e.slice(r, n), encodeURIComponent(s)), r = n + i + 1, s = ""), i && (n += i, i = 0);
  }
  return t.join("") + e.slice(r);
}
function Pt(e, t, n, r) {
  const i = r ? r - 1 : Number.POSITIVE_INFINITY;
  let a = 0;
  return s;
  function s(u) {
    return Lt(u) ? (e.enter(n), o(u)) : t(u);
  }
  function o(u) {
    return Lt(u) && a++ < i ? (e.consume(u), o) : (e.exit(n), t(u));
  }
}
const og = {
  tokenize: ug
};
function ug(e) {
  const t = e.attempt(this.parser.constructs.contentInitial, r, i);
  let n;
  return t;
  function r(o) {
    if (o === null) {
      e.consume(o);
      return;
    }
    return e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), Pt(e, t, "linePrefix");
  }
  function i(o) {
    return e.enter("paragraph"), a(o);
  }
  function a(o) {
    const u = e.enter("chunkText", {
      contentType: "text",
      previous: n
    });
    return n && (n.next = u), n = u, s(o);
  }
  function s(o) {
    if (o === null) {
      e.exit("chunkText"), e.exit("paragraph"), e.consume(o);
      return;
    }
    return st(o) ? (e.consume(o), e.exit("chunkText"), a) : (e.consume(o), s);
  }
}
const lg = {
  tokenize: cg
}, Lh = {
  tokenize: fg
};
function cg(e) {
  const t = this, n = [];
  let r = 0, i, a, s;
  return o;
  function o(B) {
    if (r < n.length) {
      const V = n[r];
      return t.containerState = V[1], e.attempt(V[0].continuation, u, c)(B);
    }
    return c(B);
  }
  function u(B) {
    if (r++, t.containerState._closeFlow) {
      t.containerState._closeFlow = void 0, i && U();
      const V = t.events.length;
      let ie = V, K;
      for (; ie--; )
        if (t.events[ie][0] === "exit" && t.events[ie][1].type === "chunkFlow") {
          K = t.events[ie][1].end;
          break;
        }
      _(r);
      let fe = V;
      for (; fe < t.events.length; )
        t.events[fe][1].end = {
          ...K
        }, fe++;
      return mr(t.events, ie + 1, 0, t.events.slice(V)), t.events.length = fe, c(B);
    }
    return o(B);
  }
  function c(B) {
    if (r === n.length) {
      if (!i)
        return E(B);
      if (i.currentConstruct && i.currentConstruct.concrete)
        return A(B);
      t.interrupt = !!(i.currentConstruct && !i._gfmTableDynamicInterruptHack);
    }
    return t.containerState = {}, e.check(Lh, f, p)(B);
  }
  function f(B) {
    return i && U(), _(r), E(B);
  }
  function p(B) {
    return t.parser.lazy[t.now().line] = r !== n.length, s = t.now().offset, A(B);
  }
  function E(B) {
    return t.containerState = {}, e.attempt(Lh, d, A)(B);
  }
  function d(B) {
    return r++, n.push([t.currentConstruct, t.containerState]), E(B);
  }
  function A(B) {
    if (B === null) {
      i && U(), _(0), e.consume(B);
      return;
    }
    return i = i || t.parser.flow(t.now()), e.enter("chunkFlow", {
      _tokenizer: i,
      contentType: "flow",
      previous: a
    }), v(B);
  }
  function v(B) {
    if (B === null) {
      C(e.exit("chunkFlow"), !0), _(0), e.consume(B);
      return;
    }
    return st(B) ? (e.consume(B), C(e.exit("chunkFlow")), r = 0, t.interrupt = void 0, o) : (e.consume(B), v);
  }
  function C(B, V) {
    const ie = t.sliceStream(B);
    if (V && ie.push(null), B.previous = a, a && (a.next = B), a = B, i.defineSkip(B.start), i.write(ie), t.parser.lazy[B.start.line]) {
      let K = i.events.length;
      for (; K--; )
        if (
          // The token starts before the line endingâ€¦
          i.events[K][1].start.offset < s && // â€¦and either is not ended yetâ€¦
          (!i.events[K][1].end || // â€¦or ends after it.
          i.events[K][1].end.offset > s)
        )
          return;
      const fe = t.events.length;
      let Z = fe, z, D;
      for (; Z--; )
        if (t.events[Z][0] === "exit" && t.events[Z][1].type === "chunkFlow") {
          if (z) {
            D = t.events[Z][1].end;
            break;
          }
          z = !0;
        }
      for (_(r), K = fe; K < t.events.length; )
        t.events[K][1].end = {
          ...D
        }, K++;
      mr(t.events, Z + 1, 0, t.events.slice(fe)), t.events.length = K;
    }
  }
  function _(B) {
    let V = n.length;
    for (; V-- > B; ) {
      const ie = n[V];
      t.containerState = ie[1], ie[0].exit.call(t, e);
    }
    n.length = B;
  }
  function U() {
    i.write([null]), a = void 0, i = void 0, t.containerState._closeFlow = void 0;
  }
}
function fg(e, t, n) {
  return Pt(e, e.attempt(this.parser.constructs.document, t, n), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
}
function ls(e) {
  if (e === null || Vt(e) || va(e))
    return 1;
  if (Yu(e))
    return 2;
}
function Wu(e, t, n) {
  const r = [];
  let i = -1;
  for (; ++i < e.length; ) {
    const a = e[i].resolveAll;
    a && !r.includes(a) && (t = a(t, n), r.push(a));
  }
  return t;
}
const Sc = {
  name: "attention",
  resolveAll: hg,
  tokenize: dg
};
function hg(e, t) {
  let n = -1, r, i, a, s, o, u, c, f;
  for (; ++n < e.length; )
    if (e[n][0] === "enter" && e[n][1].type === "attentionSequence" && e[n][1]._close) {
      for (r = n; r--; )
        if (e[r][0] === "exit" && e[r][1].type === "attentionSequence" && e[r][1]._open && // If the markers are the same:
        t.sliceSerialize(e[r][1]).charCodeAt(0) === t.sliceSerialize(e[n][1]).charCodeAt(0)) {
          if ((e[r][1]._close || e[n][1]._open) && (e[n][1].end.offset - e[n][1].start.offset) % 3 && !((e[r][1].end.offset - e[r][1].start.offset + e[n][1].end.offset - e[n][1].start.offset) % 3))
            continue;
          u = e[r][1].end.offset - e[r][1].start.offset > 1 && e[n][1].end.offset - e[n][1].start.offset > 1 ? 2 : 1;
          const p = {
            ...e[r][1].end
          }, E = {
            ...e[n][1].start
          };
          kh(p, -u), kh(E, u), s = {
            type: u > 1 ? "strongSequence" : "emphasisSequence",
            start: p,
            end: {
              ...e[r][1].end
            }
          }, o = {
            type: u > 1 ? "strongSequence" : "emphasisSequence",
            start: {
              ...e[n][1].start
            },
            end: E
          }, a = {
            type: u > 1 ? "strongText" : "emphasisText",
            start: {
              ...e[r][1].end
            },
            end: {
              ...e[n][1].start
            }
          }, i = {
            type: u > 1 ? "strong" : "emphasis",
            start: {
              ...s.start
            },
            end: {
              ...o.end
            }
          }, e[r][1].end = {
            ...s.start
          }, e[n][1].start = {
            ...o.end
          }, c = [], e[r][1].end.offset - e[r][1].start.offset && (c = Nr(c, [["enter", e[r][1], t], ["exit", e[r][1], t]])), c = Nr(c, [["enter", i, t], ["enter", s, t], ["exit", s, t], ["enter", a, t]]), c = Nr(c, Wu(t.parser.constructs.insideSpan.null, e.slice(r + 1, n), t)), c = Nr(c, [["exit", a, t], ["enter", o, t], ["exit", o, t], ["exit", i, t]]), e[n][1].end.offset - e[n][1].start.offset ? (f = 2, c = Nr(c, [["enter", e[n][1], t], ["exit", e[n][1], t]])) : f = 0, mr(e, r - 1, n - r + 3, c), n = r + c.length - f - 2;
          break;
        }
    }
  for (n = -1; ++n < e.length; )
    e[n][1].type === "attentionSequence" && (e[n][1].type = "data");
  return e;
}
function dg(e, t) {
  const n = this.parser.constructs.attentionMarkers.null, r = this.previous, i = ls(r);
  let a;
  return s;
  function s(u) {
    return a = u, e.enter("attentionSequence"), o(u);
  }
  function o(u) {
    if (u === a)
      return e.consume(u), o;
    const c = e.exit("attentionSequence"), f = ls(u), p = !f || f === 2 && i || n.includes(u), E = !i || i === 2 && f || n.includes(r);
    return c._open = !!(a === 42 ? p : p && (i || !E)), c._close = !!(a === 42 ? E : E && (f || !p)), t(u);
  }
}
function kh(e, t) {
  e.column += t, e.offset += t, e._bufferIndex += t;
}
const pg = {
  name: "autolink",
  tokenize: mg
};
function mg(e, t, n) {
  let r = 0;
  return i;
  function i(d) {
    return e.enter("autolink"), e.enter("autolinkMarker"), e.consume(d), e.exit("autolinkMarker"), e.enter("autolinkProtocol"), a;
  }
  function a(d) {
    return Xn(d) ? (e.consume(d), s) : d === 64 ? n(d) : c(d);
  }
  function s(d) {
    return d === 43 || d === 45 || d === 46 || qn(d) ? (r = 1, o(d)) : c(d);
  }
  function o(d) {
    return d === 58 ? (e.consume(d), r = 0, u) : (d === 43 || d === 45 || d === 46 || qn(d)) && r++ < 32 ? (e.consume(d), o) : (r = 0, c(d));
  }
  function u(d) {
    return d === 62 ? (e.exit("autolinkProtocol"), e.enter("autolinkMarker"), e.consume(d), e.exit("autolinkMarker"), e.exit("autolink"), t) : d === null || d === 32 || d === 60 || Cu(d) ? n(d) : (e.consume(d), u);
  }
  function c(d) {
    return d === 64 ? (e.consume(d), f) : ig(d) ? (e.consume(d), c) : n(d);
  }
  function f(d) {
    return qn(d) ? p(d) : n(d);
  }
  function p(d) {
    return d === 46 ? (e.consume(d), r = 0, f) : d === 62 ? (e.exit("autolinkProtocol").type = "autolinkEmail", e.enter("autolinkMarker"), e.consume(d), e.exit("autolinkMarker"), e.exit("autolink"), t) : E(d);
  }
  function E(d) {
    if ((d === 45 || qn(d)) && r++ < 63) {
      const A = d === 45 ? E : p;
      return e.consume(d), A;
    }
    return n(d);
  }
}
const To = {
  partial: !0,
  tokenize: gg
};
function gg(e, t, n) {
  return r;
  function r(a) {
    return Lt(a) ? Pt(e, i, "linePrefix")(a) : i(a);
  }
  function i(a) {
    return a === null || st(a) ? t(a) : n(a);
  }
}
const p1 = {
  continuation: {
    tokenize: Eg
  },
  exit: yg,
  name: "blockQuote",
  tokenize: bg
};
function bg(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    if (s === 62) {
      const o = r.containerState;
      return o.open || (e.enter("blockQuote", {
        _container: !0
      }), o.open = !0), e.enter("blockQuotePrefix"), e.enter("blockQuoteMarker"), e.consume(s), e.exit("blockQuoteMarker"), a;
    }
    return n(s);
  }
  function a(s) {
    return Lt(s) ? (e.enter("blockQuotePrefixWhitespace"), e.consume(s), e.exit("blockQuotePrefixWhitespace"), e.exit("blockQuotePrefix"), t) : (e.exit("blockQuotePrefix"), t(s));
  }
}
function Eg(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return Lt(s) ? Pt(e, a, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(s) : a(s);
  }
  function a(s) {
    return e.attempt(p1, t, n)(s);
  }
}
function yg(e) {
  e.exit("blockQuote");
}
const m1 = {
  name: "characterEscape",
  tokenize: Tg
};
function Tg(e, t, n) {
  return r;
  function r(a) {
    return e.enter("characterEscape"), e.enter("escapeMarker"), e.consume(a), e.exit("escapeMarker"), i;
  }
  function i(a) {
    return sg(a) ? (e.enter("characterEscapeValue"), e.consume(a), e.exit("characterEscapeValue"), e.exit("characterEscape"), t) : n(a);
  }
}
const g1 = {
  name: "characterReference",
  tokenize: _g
};
function _g(e, t, n) {
  const r = this;
  let i = 0, a, s;
  return o;
  function o(p) {
    return e.enter("characterReference"), e.enter("characterReferenceMarker"), e.consume(p), e.exit("characterReferenceMarker"), u;
  }
  function u(p) {
    return p === 35 ? (e.enter("characterReferenceMarkerNumeric"), e.consume(p), e.exit("characterReferenceMarkerNumeric"), c) : (e.enter("characterReferenceValue"), a = 31, s = qn, f(p));
  }
  function c(p) {
    return p === 88 || p === 120 ? (e.enter("characterReferenceMarkerHexadecimal"), e.consume(p), e.exit("characterReferenceMarkerHexadecimal"), e.enter("characterReferenceValue"), a = 6, s = ag, f) : (e.enter("characterReferenceValue"), a = 7, s = vc, f(p));
  }
  function f(p) {
    if (p === 59 && i) {
      const E = e.exit("characterReferenceValue");
      return s === qn && !nf(r.sliceSerialize(E)) ? n(p) : (e.enter("characterReferenceMarker"), e.consume(p), e.exit("characterReferenceMarker"), e.exit("characterReference"), t);
    }
    return s(p) && i++ < a ? (e.consume(p), f) : n(p);
  }
}
const Ch = {
  partial: !0,
  tokenize: wg
}, Ih = {
  concrete: !0,
  name: "codeFenced",
  tokenize: Ag
};
function Ag(e, t, n) {
  const r = this, i = {
    partial: !0,
    tokenize: ie
  };
  let a = 0, s = 0, o;
  return u;
  function u(K) {
    return c(K);
  }
  function c(K) {
    const fe = r.events[r.events.length - 1];
    return a = fe && fe[1].type === "linePrefix" ? fe[2].sliceSerialize(fe[1], !0).length : 0, o = K, e.enter("codeFenced"), e.enter("codeFencedFence"), e.enter("codeFencedFenceSequence"), f(K);
  }
  function f(K) {
    return K === o ? (s++, e.consume(K), f) : s < 3 ? n(K) : (e.exit("codeFencedFenceSequence"), Lt(K) ? Pt(e, p, "whitespace")(K) : p(K));
  }
  function p(K) {
    return K === null || st(K) ? (e.exit("codeFencedFence"), r.interrupt ? t(K) : e.check(Ch, v, V)(K)) : (e.enter("codeFencedFenceInfo"), e.enter("chunkString", {
      contentType: "string"
    }), E(K));
  }
  function E(K) {
    return K === null || st(K) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), p(K)) : Lt(K) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), Pt(e, d, "whitespace")(K)) : K === 96 && K === o ? n(K) : (e.consume(K), E);
  }
  function d(K) {
    return K === null || st(K) ? p(K) : (e.enter("codeFencedFenceMeta"), e.enter("chunkString", {
      contentType: "string"
    }), A(K));
  }
  function A(K) {
    return K === null || st(K) ? (e.exit("chunkString"), e.exit("codeFencedFenceMeta"), p(K)) : K === 96 && K === o ? n(K) : (e.consume(K), A);
  }
  function v(K) {
    return e.attempt(i, V, C)(K);
  }
  function C(K) {
    return e.enter("lineEnding"), e.consume(K), e.exit("lineEnding"), _;
  }
  function _(K) {
    return a > 0 && Lt(K) ? Pt(e, U, "linePrefix", a + 1)(K) : U(K);
  }
  function U(K) {
    return K === null || st(K) ? e.check(Ch, v, V)(K) : (e.enter("codeFlowValue"), B(K));
  }
  function B(K) {
    return K === null || st(K) ? (e.exit("codeFlowValue"), U(K)) : (e.consume(K), B);
  }
  function V(K) {
    return e.exit("codeFenced"), t(K);
  }
  function ie(K, fe, Z) {
    let z = 0;
    return D;
    function D(J) {
      return K.enter("lineEnding"), K.consume(J), K.exit("lineEnding"), N;
    }
    function N(J) {
      return K.enter("codeFencedFence"), Lt(J) ? Pt(K, I, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(J) : I(J);
    }
    function I(J) {
      return J === o ? (K.enter("codeFencedFenceSequence"), $(J)) : Z(J);
    }
    function $(J) {
      return J === o ? (z++, K.consume(J), $) : z >= s ? (K.exit("codeFencedFenceSequence"), Lt(J) ? Pt(K, Y, "whitespace")(J) : Y(J)) : Z(J);
    }
    function Y(J) {
      return J === null || st(J) ? (K.exit("codeFencedFence"), fe(J)) : Z(J);
    }
  }
}
function wg(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return s === null ? n(s) : (e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), a);
  }
  function a(s) {
    return r.parser.lazy[r.now().line] ? n(s) : t(s);
  }
}
const Bl = {
  name: "codeIndented",
  tokenize: Ng
}, xg = {
  partial: !0,
  tokenize: vg
};
function Ng(e, t, n) {
  const r = this;
  return i;
  function i(c) {
    return e.enter("codeIndented"), Pt(e, a, "linePrefix", 5)(c);
  }
  function a(c) {
    const f = r.events[r.events.length - 1];
    return f && f[1].type === "linePrefix" && f[2].sliceSerialize(f[1], !0).length >= 4 ? s(c) : n(c);
  }
  function s(c) {
    return c === null ? u(c) : st(c) ? e.attempt(xg, s, u)(c) : (e.enter("codeFlowValue"), o(c));
  }
  function o(c) {
    return c === null || st(c) ? (e.exit("codeFlowValue"), s(c)) : (e.consume(c), o);
  }
  function u(c) {
    return e.exit("codeIndented"), t(c);
  }
}
function vg(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return r.parser.lazy[r.now().line] ? n(s) : st(s) ? (e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), i) : Pt(e, a, "linePrefix", 5)(s);
  }
  function a(s) {
    const o = r.events[r.events.length - 1];
    return o && o[1].type === "linePrefix" && o[2].sliceSerialize(o[1], !0).length >= 4 ? t(s) : st(s) ? i(s) : n(s);
  }
}
const Sg = {
  name: "codeText",
  previous: kg,
  resolve: Lg,
  tokenize: Cg
};
function Lg(e) {
  let t = e.length - 4, n = 3, r, i;
  if ((e[n][1].type === "lineEnding" || e[n][1].type === "space") && (e[t][1].type === "lineEnding" || e[t][1].type === "space")) {
    for (r = n; ++r < t; )
      if (e[r][1].type === "codeTextData") {
        e[n][1].type = "codeTextPadding", e[t][1].type = "codeTextPadding", n += 2, t -= 2;
        break;
      }
  }
  for (r = n - 1, t++; ++r <= t; )
    i === void 0 ? r !== t && e[r][1].type !== "lineEnding" && (i = r) : (r === t || e[r][1].type === "lineEnding") && (e[i][1].type = "codeTextData", r !== i + 2 && (e[i][1].end = e[r - 1][1].end, e.splice(i + 2, r - i - 2), t -= r - i - 2, r = i + 2), i = void 0);
  return e;
}
function kg(e) {
  return e !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function Cg(e, t, n) {
  let r = 0, i, a;
  return s;
  function s(p) {
    return e.enter("codeText"), e.enter("codeTextSequence"), o(p);
  }
  function o(p) {
    return p === 96 ? (e.consume(p), r++, o) : (e.exit("codeTextSequence"), u(p));
  }
  function u(p) {
    return p === null ? n(p) : p === 32 ? (e.enter("space"), e.consume(p), e.exit("space"), u) : p === 96 ? (a = e.enter("codeTextSequence"), i = 0, f(p)) : st(p) ? (e.enter("lineEnding"), e.consume(p), e.exit("lineEnding"), u) : (e.enter("codeTextData"), c(p));
  }
  function c(p) {
    return p === null || p === 32 || p === 96 || st(p) ? (e.exit("codeTextData"), u(p)) : (e.consume(p), c);
  }
  function f(p) {
    return p === 96 ? (e.consume(p), i++, f) : i === r ? (e.exit("codeTextSequence"), e.exit("codeText"), t(p)) : (a.type = "codeTextData", c(p));
  }
}
class Ig {
  /**
   * @param {ReadonlyArray<T> | null | undefined} [initial]
   *   Initial items (optional).
   * @returns
   *   Splice buffer.
   */
  constructor(t) {
    this.left = t ? [...t] : [], this.right = [];
  }
  /**
   * Array access;
   * does not move the cursor.
   *
   * @param {number} index
   *   Index.
   * @return {T}
   *   Item.
   */
  get(t) {
    if (t < 0 || t >= this.left.length + this.right.length)
      throw new RangeError("Cannot access index `" + t + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
    return t < this.left.length ? this.left[t] : this.right[this.right.length - t + this.left.length - 1];
  }
  /**
   * The length of the splice buffer, one greater than the largest index in the
   * array.
   */
  get length() {
    return this.left.length + this.right.length;
  }
  /**
   * Remove and return `list[0]`;
   * moves the cursor to `0`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  shift() {
    return this.setCursor(0), this.right.pop();
  }
  /**
   * Slice the buffer to get an array;
   * does not move the cursor.
   *
   * @param {number} start
   *   Start.
   * @param {number | null | undefined} [end]
   *   End (optional).
   * @returns {Array<T>}
   *   Array of items.
   */
  slice(t, n) {
    const r = n ?? Number.POSITIVE_INFINITY;
    return r < this.left.length ? this.left.slice(t, r) : t > this.left.length ? this.right.slice(this.right.length - r + this.left.length, this.right.length - t + this.left.length).reverse() : this.left.slice(t).concat(this.right.slice(this.right.length - r + this.left.length).reverse());
  }
  /**
   * Mimics the behavior of Array.prototype.splice() except for the change of
   * interface necessary to avoid segfaults when patching in very large arrays.
   *
   * This operation moves cursor is moved to `start` and results in the cursor
   * placed after any inserted items.
   *
   * @param {number} start
   *   Start;
   *   zero-based index at which to start changing the array;
   *   negative numbers count backwards from the end of the array and values
   *   that are out-of bounds are clamped to the appropriate end of the array.
   * @param {number | null | undefined} [deleteCount=0]
   *   Delete count (default: `0`);
   *   maximum number of elements to delete, starting from start.
   * @param {Array<T> | null | undefined} [items=[]]
   *   Items to include in place of the deleted items (default: `[]`).
   * @return {Array<T>}
   *   Any removed items.
   */
  splice(t, n, r) {
    const i = n || 0;
    this.setCursor(Math.trunc(t));
    const a = this.right.splice(this.right.length - i, Number.POSITIVE_INFINITY);
    return r && $s(this.left, r), a.reverse();
  }
  /**
   * Remove and return the highest-numbered item in the array, so
   * `list[list.length - 1]`;
   * Moves the cursor to `length`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  pop() {
    return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop();
  }
  /**
   * Inserts a single item to the high-numbered side of the array;
   * moves the cursor to `length`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  push(t) {
    this.setCursor(Number.POSITIVE_INFINITY), this.left.push(t);
  }
  /**
   * Inserts many items to the high-numbered side of the array.
   * Moves the cursor to `length`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  pushMany(t) {
    this.setCursor(Number.POSITIVE_INFINITY), $s(this.left, t);
  }
  /**
   * Inserts a single item to the low-numbered side of the array;
   * Moves the cursor to `0`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  unshift(t) {
    this.setCursor(0), this.right.push(t);
  }
  /**
   * Inserts many items to the low-numbered side of the array;
   * moves the cursor to `0`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  unshiftMany(t) {
    this.setCursor(0), $s(this.right, t.reverse());
  }
  /**
   * Move the cursor to a specific position in the array. Requires
   * time proportional to the distance moved.
   *
   * If `n < 0`, the cursor will end up at the beginning.
   * If `n > length`, the cursor will end up at the end.
   *
   * @param {number} n
   *   Position.
   * @return {undefined}
   *   Nothing.
   */
  setCursor(t) {
    if (!(t === this.left.length || t > this.left.length && this.right.length === 0 || t < 0 && this.left.length === 0))
      if (t < this.left.length) {
        const n = this.left.splice(t, Number.POSITIVE_INFINITY);
        $s(this.right, n.reverse());
      } else {
        const n = this.right.splice(this.left.length + this.right.length - t, Number.POSITIVE_INFINITY);
        $s(this.left, n.reverse());
      }
  }
}
function $s(e, t) {
  let n = 0;
  if (t.length < 1e4)
    e.push(...t);
  else
    for (; n < t.length; )
      e.push(...t.slice(n, n + 1e4)), n += 1e4;
}
function b1(e) {
  const t = {};
  let n = -1, r, i, a, s, o, u, c;
  const f = new Ig(e);
  for (; ++n < f.length; ) {
    for (; n in t; )
      n = t[n];
    if (r = f.get(n), n && r[1].type === "chunkFlow" && f.get(n - 1)[1].type === "listItemPrefix" && (u = r[1]._tokenizer.events, a = 0, a < u.length && u[a][1].type === "lineEndingBlank" && (a += 2), a < u.length && u[a][1].type === "content"))
      for (; ++a < u.length && u[a][1].type !== "content"; )
        u[a][1].type === "chunkText" && (u[a][1]._isInFirstContentOfListItem = !0, a++);
    if (r[0] === "enter")
      r[1].contentType && (Object.assign(t, Pg(f, n)), n = t[n], c = !0);
    else if (r[1]._container) {
      for (a = n, i = void 0; a--; )
        if (s = f.get(a), s[1].type === "lineEnding" || s[1].type === "lineEndingBlank")
          s[0] === "enter" && (i && (f.get(i)[1].type = "lineEndingBlank"), s[1].type = "lineEnding", i = a);
        else if (!(s[1].type === "linePrefix" || s[1].type === "listItemIndent")) break;
      i && (r[1].end = {
        ...f.get(i)[1].start
      }, o = f.slice(i, n), o.unshift(r), f.splice(i, n - i + 1, o));
    }
  }
  return mr(e, 0, Number.POSITIVE_INFINITY, f.slice(0)), !c;
}
function Pg(e, t) {
  const n = e.get(t)[1], r = e.get(t)[2];
  let i = t - 1;
  const a = [];
  let s = n._tokenizer;
  s || (s = r.parser[n.contentType](n.start), n._contentTypeTextTrailing && (s._contentTypeTextTrailing = !0));
  const o = s.events, u = [], c = {};
  let f, p, E = -1, d = n, A = 0, v = 0;
  const C = [v];
  for (; d; ) {
    for (; e.get(++i)[1] !== d; )
      ;
    a.push(i), d._tokenizer || (f = r.sliceStream(d), d.next || f.push(null), p && s.defineSkip(d.start), d._isInFirstContentOfListItem && (s._gfmTasklistFirstContentOfListItem = !0), s.write(f), d._isInFirstContentOfListItem && (s._gfmTasklistFirstContentOfListItem = void 0)), p = d, d = d.next;
  }
  for (d = n; ++E < o.length; )
    // Find a void token that includes a break.
    o[E][0] === "exit" && o[E - 1][0] === "enter" && o[E][1].type === o[E - 1][1].type && o[E][1].start.line !== o[E][1].end.line && (v = E + 1, C.push(v), d._tokenizer = void 0, d.previous = void 0, d = d.next);
  for (s.events = [], d ? (d._tokenizer = void 0, d.previous = void 0) : C.pop(), E = C.length; E--; ) {
    const _ = o.slice(C[E], C[E + 1]), U = a.pop();
    u.push([U, U + _.length - 1]), e.splice(U, 2, _);
  }
  for (u.reverse(), E = -1; ++E < u.length; )
    c[A + u[E][0]] = A + u[E][1], A += u[E][1] - u[E][0] - 1;
  return c;
}
const Og = {
  resolve: Dg,
  tokenize: Mg
}, Rg = {
  partial: !0,
  tokenize: Fg
};
function Dg(e) {
  return b1(e), e;
}
function Mg(e, t) {
  let n;
  return r;
  function r(o) {
    return e.enter("content"), n = e.enter("chunkContent", {
      contentType: "content"
    }), i(o);
  }
  function i(o) {
    return o === null ? a(o) : st(o) ? e.check(Rg, s, a)(o) : (e.consume(o), i);
  }
  function a(o) {
    return e.exit("chunkContent"), e.exit("content"), t(o);
  }
  function s(o) {
    return e.consume(o), e.exit("chunkContent"), n.next = e.enter("chunkContent", {
      contentType: "content",
      previous: n
    }), n = n.next, i;
  }
}
function Fg(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return e.exit("chunkContent"), e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), Pt(e, a, "linePrefix");
  }
  function a(s) {
    if (s === null || st(s))
      return n(s);
    const o = r.events[r.events.length - 1];
    return !r.parser.constructs.disable.null.includes("codeIndented") && o && o[1].type === "linePrefix" && o[2].sliceSerialize(o[1], !0).length >= 4 ? t(s) : e.interrupt(r.parser.constructs.flow, n, t)(s);
  }
}
function E1(e, t, n, r, i, a, s, o, u) {
  const c = u || Number.POSITIVE_INFINITY;
  let f = 0;
  return p;
  function p(_) {
    return _ === 60 ? (e.enter(r), e.enter(i), e.enter(a), e.consume(_), e.exit(a), E) : _ === null || _ === 32 || _ === 41 || Cu(_) ? n(_) : (e.enter(r), e.enter(s), e.enter(o), e.enter("chunkString", {
      contentType: "string"
    }), v(_));
  }
  function E(_) {
    return _ === 62 ? (e.enter(a), e.consume(_), e.exit(a), e.exit(i), e.exit(r), t) : (e.enter(o), e.enter("chunkString", {
      contentType: "string"
    }), d(_));
  }
  function d(_) {
    return _ === 62 ? (e.exit("chunkString"), e.exit(o), E(_)) : _ === null || _ === 60 || st(_) ? n(_) : (e.consume(_), _ === 92 ? A : d);
  }
  function A(_) {
    return _ === 60 || _ === 62 || _ === 92 ? (e.consume(_), d) : d(_);
  }
  function v(_) {
    return !f && (_ === null || _ === 41 || Vt(_)) ? (e.exit("chunkString"), e.exit(o), e.exit(s), e.exit(r), t(_)) : f < c && _ === 40 ? (e.consume(_), f++, v) : _ === 41 ? (e.consume(_), f--, v) : _ === null || _ === 32 || _ === 40 || Cu(_) ? n(_) : (e.consume(_), _ === 92 ? C : v);
  }
  function C(_) {
    return _ === 40 || _ === 41 || _ === 92 ? (e.consume(_), v) : v(_);
  }
}
function y1(e, t, n, r, i, a) {
  const s = this;
  let o = 0, u;
  return c;
  function c(d) {
    return e.enter(r), e.enter(i), e.consume(d), e.exit(i), e.enter(a), f;
  }
  function f(d) {
    return o > 999 || d === null || d === 91 || d === 93 && !u || // To do: remove in the future once weâ€™ve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesnâ€™t need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    d === 94 && !o && "_hiddenFootnoteSupport" in s.parser.constructs ? n(d) : d === 93 ? (e.exit(a), e.enter(i), e.consume(d), e.exit(i), e.exit(r), t) : st(d) ? (e.enter("lineEnding"), e.consume(d), e.exit("lineEnding"), f) : (e.enter("chunkString", {
      contentType: "string"
    }), p(d));
  }
  function p(d) {
    return d === null || d === 91 || d === 93 || st(d) || o++ > 999 ? (e.exit("chunkString"), f(d)) : (e.consume(d), u || (u = !Lt(d)), d === 92 ? E : p);
  }
  function E(d) {
    return d === 91 || d === 92 || d === 93 ? (e.consume(d), o++, p) : p(d);
  }
}
function T1(e, t, n, r, i, a) {
  let s;
  return o;
  function o(E) {
    return E === 34 || E === 39 || E === 40 ? (e.enter(r), e.enter(i), e.consume(E), e.exit(i), s = E === 40 ? 41 : E, u) : n(E);
  }
  function u(E) {
    return E === s ? (e.enter(i), e.consume(E), e.exit(i), e.exit(r), t) : (e.enter(a), c(E));
  }
  function c(E) {
    return E === s ? (e.exit(a), u(s)) : E === null ? n(E) : st(E) ? (e.enter("lineEnding"), e.consume(E), e.exit("lineEnding"), Pt(e, c, "linePrefix")) : (e.enter("chunkString", {
      contentType: "string"
    }), f(E));
  }
  function f(E) {
    return E === s || E === null || st(E) ? (e.exit("chunkString"), c(E)) : (e.consume(E), E === 92 ? p : f);
  }
  function p(E) {
    return E === s || E === 92 ? (e.consume(E), f) : f(E);
  }
}
function no(e, t) {
  let n;
  return r;
  function r(i) {
    return st(i) ? (e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), n = !0, r) : Lt(i) ? Pt(e, r, n ? "linePrefix" : "lineSuffix")(i) : t(i);
  }
}
const Bg = {
  name: "definition",
  tokenize: Hg
}, Ug = {
  partial: !0,
  tokenize: jg
};
function Hg(e, t, n) {
  const r = this;
  let i;
  return a;
  function a(d) {
    return e.enter("definition"), s(d);
  }
  function s(d) {
    return y1.call(
      r,
      e,
      o,
      // Note: we donâ€™t need to reset the way `markdown-rs` does.
      n,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(d);
  }
  function o(d) {
    return i = Fr(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)), d === 58 ? (e.enter("definitionMarker"), e.consume(d), e.exit("definitionMarker"), u) : n(d);
  }
  function u(d) {
    return Vt(d) ? no(e, c)(d) : c(d);
  }
  function c(d) {
    return E1(
      e,
      f,
      // Note: we donâ€™t need to reset the way `markdown-rs` does.
      n,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(d);
  }
  function f(d) {
    return e.attempt(Ug, p, p)(d);
  }
  function p(d) {
    return Lt(d) ? Pt(e, E, "whitespace")(d) : E(d);
  }
  function E(d) {
    return d === null || st(d) ? (e.exit("definition"), r.parser.defined.push(i), t(d)) : n(d);
  }
}
function jg(e, t, n) {
  return r;
  function r(o) {
    return Vt(o) ? no(e, i)(o) : n(o);
  }
  function i(o) {
    return T1(e, a, n, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(o);
  }
  function a(o) {
    return Lt(o) ? Pt(e, s, "whitespace")(o) : s(o);
  }
  function s(o) {
    return o === null || st(o) ? t(o) : n(o);
  }
}
const qg = {
  name: "hardBreakEscape",
  tokenize: zg
};
function zg(e, t, n) {
  return r;
  function r(a) {
    return e.enter("hardBreakEscape"), e.consume(a), i;
  }
  function i(a) {
    return st(a) ? (e.exit("hardBreakEscape"), t(a)) : n(a);
  }
}
const Yg = {
  name: "headingAtx",
  resolve: Wg,
  tokenize: Vg
};
function Wg(e, t) {
  let n = e.length - 2, r = 3, i, a;
  return e[r][1].type === "whitespace" && (r += 2), n - 2 > r && e[n][1].type === "whitespace" && (n -= 2), e[n][1].type === "atxHeadingSequence" && (r === n - 1 || n - 4 > r && e[n - 2][1].type === "whitespace") && (n -= r + 1 === n ? 2 : 4), n > r && (i = {
    type: "atxHeadingText",
    start: e[r][1].start,
    end: e[n][1].end
  }, a = {
    type: "chunkText",
    start: e[r][1].start,
    end: e[n][1].end,
    contentType: "text"
  }, mr(e, r, n - r + 1, [["enter", i, t], ["enter", a, t], ["exit", a, t], ["exit", i, t]])), e;
}
function Vg(e, t, n) {
  let r = 0;
  return i;
  function i(f) {
    return e.enter("atxHeading"), a(f);
  }
  function a(f) {
    return e.enter("atxHeadingSequence"), s(f);
  }
  function s(f) {
    return f === 35 && r++ < 6 ? (e.consume(f), s) : f === null || Vt(f) ? (e.exit("atxHeadingSequence"), o(f)) : n(f);
  }
  function o(f) {
    return f === 35 ? (e.enter("atxHeadingSequence"), u(f)) : f === null || st(f) ? (e.exit("atxHeading"), t(f)) : Lt(f) ? Pt(e, o, "whitespace")(f) : (e.enter("atxHeadingText"), c(f));
  }
  function u(f) {
    return f === 35 ? (e.consume(f), u) : (e.exit("atxHeadingSequence"), o(f));
  }
  function c(f) {
    return f === null || f === 35 || Vt(f) ? (e.exit("atxHeadingText"), o(f)) : (e.consume(f), c);
  }
}
const Gg = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], Ph = ["pre", "script", "style", "textarea"], $g = {
  concrete: !0,
  name: "htmlFlow",
  resolveTo: Qg,
  tokenize: Jg
}, Xg = {
  partial: !0,
  tokenize: eb
}, Kg = {
  partial: !0,
  tokenize: Zg
};
function Qg(e) {
  let t = e.length;
  for (; t-- && !(e[t][0] === "enter" && e[t][1].type === "htmlFlow"); )
    ;
  return t > 1 && e[t - 2][1].type === "linePrefix" && (e[t][1].start = e[t - 2][1].start, e[t + 1][1].start = e[t - 2][1].start, e.splice(t - 2, 2)), e;
}
function Jg(e, t, n) {
  const r = this;
  let i, a, s, o, u;
  return c;
  function c(T) {
    return f(T);
  }
  function f(T) {
    return e.enter("htmlFlow"), e.enter("htmlFlowData"), e.consume(T), p;
  }
  function p(T) {
    return T === 33 ? (e.consume(T), E) : T === 47 ? (e.consume(T), a = !0, v) : T === 63 ? (e.consume(T), i = 3, r.interrupt ? t : M) : Xn(T) ? (e.consume(T), s = String.fromCharCode(T), C) : n(T);
  }
  function E(T) {
    return T === 45 ? (e.consume(T), i = 2, d) : T === 91 ? (e.consume(T), i = 5, o = 0, A) : Xn(T) ? (e.consume(T), i = 4, r.interrupt ? t : M) : n(T);
  }
  function d(T) {
    return T === 45 ? (e.consume(T), r.interrupt ? t : M) : n(T);
  }
  function A(T) {
    const G = "CDATA[";
    return T === G.charCodeAt(o++) ? (e.consume(T), o === G.length ? r.interrupt ? t : I : A) : n(T);
  }
  function v(T) {
    return Xn(T) ? (e.consume(T), s = String.fromCharCode(T), C) : n(T);
  }
  function C(T) {
    if (T === null || T === 47 || T === 62 || Vt(T)) {
      const G = T === 47, ee = s.toLowerCase();
      return !G && !a && Ph.includes(ee) ? (i = 1, r.interrupt ? t(T) : I(T)) : Gg.includes(s.toLowerCase()) ? (i = 6, G ? (e.consume(T), _) : r.interrupt ? t(T) : I(T)) : (i = 7, r.interrupt && !r.parser.lazy[r.now().line] ? n(T) : a ? U(T) : B(T));
    }
    return T === 45 || qn(T) ? (e.consume(T), s += String.fromCharCode(T), C) : n(T);
  }
  function _(T) {
    return T === 62 ? (e.consume(T), r.interrupt ? t : I) : n(T);
  }
  function U(T) {
    return Lt(T) ? (e.consume(T), U) : D(T);
  }
  function B(T) {
    return T === 47 ? (e.consume(T), D) : T === 58 || T === 95 || Xn(T) ? (e.consume(T), V) : Lt(T) ? (e.consume(T), B) : D(T);
  }
  function V(T) {
    return T === 45 || T === 46 || T === 58 || T === 95 || qn(T) ? (e.consume(T), V) : ie(T);
  }
  function ie(T) {
    return T === 61 ? (e.consume(T), K) : Lt(T) ? (e.consume(T), ie) : B(T);
  }
  function K(T) {
    return T === null || T === 60 || T === 61 || T === 62 || T === 96 ? n(T) : T === 34 || T === 39 ? (e.consume(T), u = T, fe) : Lt(T) ? (e.consume(T), K) : Z(T);
  }
  function fe(T) {
    return T === u ? (e.consume(T), u = null, z) : T === null || st(T) ? n(T) : (e.consume(T), fe);
  }
  function Z(T) {
    return T === null || T === 34 || T === 39 || T === 47 || T === 60 || T === 61 || T === 62 || T === 96 || Vt(T) ? ie(T) : (e.consume(T), Z);
  }
  function z(T) {
    return T === 47 || T === 62 || Lt(T) ? B(T) : n(T);
  }
  function D(T) {
    return T === 62 ? (e.consume(T), N) : n(T);
  }
  function N(T) {
    return T === null || st(T) ? I(T) : Lt(T) ? (e.consume(T), N) : n(T);
  }
  function I(T) {
    return T === 45 && i === 2 ? (e.consume(T), ue) : T === 60 && i === 1 ? (e.consume(T), me) : T === 62 && i === 4 ? (e.consume(T), xe) : T === 63 && i === 3 ? (e.consume(T), M) : T === 93 && i === 5 ? (e.consume(T), Ee) : st(T) && (i === 6 || i === 7) ? (e.exit("htmlFlowData"), e.check(Xg, L, $)(T)) : T === null || st(T) ? (e.exit("htmlFlowData"), $(T)) : (e.consume(T), I);
  }
  function $(T) {
    return e.check(Kg, Y, L)(T);
  }
  function Y(T) {
    return e.enter("lineEnding"), e.consume(T), e.exit("lineEnding"), J;
  }
  function J(T) {
    return T === null || st(T) ? $(T) : (e.enter("htmlFlowData"), I(T));
  }
  function ue(T) {
    return T === 45 ? (e.consume(T), M) : I(T);
  }
  function me(T) {
    return T === 47 ? (e.consume(T), s = "", se) : I(T);
  }
  function se(T) {
    if (T === 62) {
      const G = s.toLowerCase();
      return Ph.includes(G) ? (e.consume(T), xe) : I(T);
    }
    return Xn(T) && s.length < 8 ? (e.consume(T), s += String.fromCharCode(T), se) : I(T);
  }
  function Ee(T) {
    return T === 93 ? (e.consume(T), M) : I(T);
  }
  function M(T) {
    return T === 62 ? (e.consume(T), xe) : T === 45 && i === 2 ? (e.consume(T), M) : I(T);
  }
  function xe(T) {
    return T === null || st(T) ? (e.exit("htmlFlowData"), L(T)) : (e.consume(T), xe);
  }
  function L(T) {
    return e.exit("htmlFlow"), t(T);
  }
}
function Zg(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return st(s) ? (e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), a) : n(s);
  }
  function a(s) {
    return r.parser.lazy[r.now().line] ? n(s) : t(s);
  }
}
function eb(e, t, n) {
  return r;
  function r(i) {
    return e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), e.attempt(To, t, n);
  }
}
const tb = {
  name: "htmlText",
  tokenize: nb
};
function nb(e, t, n) {
  const r = this;
  let i, a, s;
  return o;
  function o(M) {
    return e.enter("htmlText"), e.enter("htmlTextData"), e.consume(M), u;
  }
  function u(M) {
    return M === 33 ? (e.consume(M), c) : M === 47 ? (e.consume(M), ie) : M === 63 ? (e.consume(M), B) : Xn(M) ? (e.consume(M), Z) : n(M);
  }
  function c(M) {
    return M === 45 ? (e.consume(M), f) : M === 91 ? (e.consume(M), a = 0, A) : Xn(M) ? (e.consume(M), U) : n(M);
  }
  function f(M) {
    return M === 45 ? (e.consume(M), d) : n(M);
  }
  function p(M) {
    return M === null ? n(M) : M === 45 ? (e.consume(M), E) : st(M) ? (s = p, me(M)) : (e.consume(M), p);
  }
  function E(M) {
    return M === 45 ? (e.consume(M), d) : p(M);
  }
  function d(M) {
    return M === 62 ? ue(M) : M === 45 ? E(M) : p(M);
  }
  function A(M) {
    const xe = "CDATA[";
    return M === xe.charCodeAt(a++) ? (e.consume(M), a === xe.length ? v : A) : n(M);
  }
  function v(M) {
    return M === null ? n(M) : M === 93 ? (e.consume(M), C) : st(M) ? (s = v, me(M)) : (e.consume(M), v);
  }
  function C(M) {
    return M === 93 ? (e.consume(M), _) : v(M);
  }
  function _(M) {
    return M === 62 ? ue(M) : M === 93 ? (e.consume(M), _) : v(M);
  }
  function U(M) {
    return M === null || M === 62 ? ue(M) : st(M) ? (s = U, me(M)) : (e.consume(M), U);
  }
  function B(M) {
    return M === null ? n(M) : M === 63 ? (e.consume(M), V) : st(M) ? (s = B, me(M)) : (e.consume(M), B);
  }
  function V(M) {
    return M === 62 ? ue(M) : B(M);
  }
  function ie(M) {
    return Xn(M) ? (e.consume(M), K) : n(M);
  }
  function K(M) {
    return M === 45 || qn(M) ? (e.consume(M), K) : fe(M);
  }
  function fe(M) {
    return st(M) ? (s = fe, me(M)) : Lt(M) ? (e.consume(M), fe) : ue(M);
  }
  function Z(M) {
    return M === 45 || qn(M) ? (e.consume(M), Z) : M === 47 || M === 62 || Vt(M) ? z(M) : n(M);
  }
  function z(M) {
    return M === 47 ? (e.consume(M), ue) : M === 58 || M === 95 || Xn(M) ? (e.consume(M), D) : st(M) ? (s = z, me(M)) : Lt(M) ? (e.consume(M), z) : ue(M);
  }
  function D(M) {
    return M === 45 || M === 46 || M === 58 || M === 95 || qn(M) ? (e.consume(M), D) : N(M);
  }
  function N(M) {
    return M === 61 ? (e.consume(M), I) : st(M) ? (s = N, me(M)) : Lt(M) ? (e.consume(M), N) : z(M);
  }
  function I(M) {
    return M === null || M === 60 || M === 61 || M === 62 || M === 96 ? n(M) : M === 34 || M === 39 ? (e.consume(M), i = M, $) : st(M) ? (s = I, me(M)) : Lt(M) ? (e.consume(M), I) : (e.consume(M), Y);
  }
  function $(M) {
    return M === i ? (e.consume(M), i = void 0, J) : M === null ? n(M) : st(M) ? (s = $, me(M)) : (e.consume(M), $);
  }
  function Y(M) {
    return M === null || M === 34 || M === 39 || M === 60 || M === 61 || M === 96 ? n(M) : M === 47 || M === 62 || Vt(M) ? z(M) : (e.consume(M), Y);
  }
  function J(M) {
    return M === 47 || M === 62 || Vt(M) ? z(M) : n(M);
  }
  function ue(M) {
    return M === 62 ? (e.consume(M), e.exit("htmlTextData"), e.exit("htmlText"), t) : n(M);
  }
  function me(M) {
    return e.exit("htmlTextData"), e.enter("lineEnding"), e.consume(M), e.exit("lineEnding"), se;
  }
  function se(M) {
    return Lt(M) ? Pt(e, Ee, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(M) : Ee(M);
  }
  function Ee(M) {
    return e.enter("htmlTextData"), s(M);
  }
}
const rf = {
  name: "labelEnd",
  resolveAll: sb,
  resolveTo: ob,
  tokenize: ub
}, rb = {
  tokenize: lb
}, ib = {
  tokenize: cb
}, ab = {
  tokenize: fb
};
function sb(e) {
  let t = -1;
  const n = [];
  for (; ++t < e.length; ) {
    const r = e[t][1];
    if (n.push(e[t]), r.type === "labelImage" || r.type === "labelLink" || r.type === "labelEnd") {
      const i = r.type === "labelImage" ? 4 : 2;
      r.type = "data", t += i;
    }
  }
  return e.length !== n.length && mr(e, 0, e.length, n), e;
}
function ob(e, t) {
  let n = e.length, r = 0, i, a, s, o;
  for (; n--; )
    if (i = e[n][1], a) {
      if (i.type === "link" || i.type === "labelLink" && i._inactive)
        break;
      e[n][0] === "enter" && i.type === "labelLink" && (i._inactive = !0);
    } else if (s) {
      if (e[n][0] === "enter" && (i.type === "labelImage" || i.type === "labelLink") && !i._balanced && (a = n, i.type !== "labelLink")) {
        r = 2;
        break;
      }
    } else i.type === "labelEnd" && (s = n);
  const u = {
    type: e[a][1].type === "labelLink" ? "link" : "image",
    start: {
      ...e[a][1].start
    },
    end: {
      ...e[e.length - 1][1].end
    }
  }, c = {
    type: "label",
    start: {
      ...e[a][1].start
    },
    end: {
      ...e[s][1].end
    }
  }, f = {
    type: "labelText",
    start: {
      ...e[a + r + 2][1].end
    },
    end: {
      ...e[s - 2][1].start
    }
  };
  return o = [["enter", u, t], ["enter", c, t]], o = Nr(o, e.slice(a + 1, a + r + 3)), o = Nr(o, [["enter", f, t]]), o = Nr(o, Wu(t.parser.constructs.insideSpan.null, e.slice(a + r + 4, s - 3), t)), o = Nr(o, [["exit", f, t], e[s - 2], e[s - 1], ["exit", c, t]]), o = Nr(o, e.slice(s + 1)), o = Nr(o, [["exit", u, t]]), mr(e, a, e.length, o), e;
}
function ub(e, t, n) {
  const r = this;
  let i = r.events.length, a, s;
  for (; i--; )
    if ((r.events[i][1].type === "labelImage" || r.events[i][1].type === "labelLink") && !r.events[i][1]._balanced) {
      a = r.events[i][1];
      break;
    }
  return o;
  function o(E) {
    return a ? a._inactive ? p(E) : (s = r.parser.defined.includes(Fr(r.sliceSerialize({
      start: a.end,
      end: r.now()
    }))), e.enter("labelEnd"), e.enter("labelMarker"), e.consume(E), e.exit("labelMarker"), e.exit("labelEnd"), u) : n(E);
  }
  function u(E) {
    return E === 40 ? e.attempt(rb, f, s ? f : p)(E) : E === 91 ? e.attempt(ib, f, s ? c : p)(E) : s ? f(E) : p(E);
  }
  function c(E) {
    return e.attempt(ab, f, p)(E);
  }
  function f(E) {
    return t(E);
  }
  function p(E) {
    return a._balanced = !0, n(E);
  }
}
function lb(e, t, n) {
  return r;
  function r(p) {
    return e.enter("resource"), e.enter("resourceMarker"), e.consume(p), e.exit("resourceMarker"), i;
  }
  function i(p) {
    return Vt(p) ? no(e, a)(p) : a(p);
  }
  function a(p) {
    return p === 41 ? f(p) : E1(e, s, o, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(p);
  }
  function s(p) {
    return Vt(p) ? no(e, u)(p) : f(p);
  }
  function o(p) {
    return n(p);
  }
  function u(p) {
    return p === 34 || p === 39 || p === 40 ? T1(e, c, n, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(p) : f(p);
  }
  function c(p) {
    return Vt(p) ? no(e, f)(p) : f(p);
  }
  function f(p) {
    return p === 41 ? (e.enter("resourceMarker"), e.consume(p), e.exit("resourceMarker"), e.exit("resource"), t) : n(p);
  }
}
function cb(e, t, n) {
  const r = this;
  return i;
  function i(o) {
    return y1.call(r, e, a, s, "reference", "referenceMarker", "referenceString")(o);
  }
  function a(o) {
    return r.parser.defined.includes(Fr(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1))) ? t(o) : n(o);
  }
  function s(o) {
    return n(o);
  }
}
function fb(e, t, n) {
  return r;
  function r(a) {
    return e.enter("reference"), e.enter("referenceMarker"), e.consume(a), e.exit("referenceMarker"), i;
  }
  function i(a) {
    return a === 93 ? (e.enter("referenceMarker"), e.consume(a), e.exit("referenceMarker"), e.exit("reference"), t) : n(a);
  }
}
const hb = {
  name: "labelStartImage",
  resolveAll: rf.resolveAll,
  tokenize: db
};
function db(e, t, n) {
  const r = this;
  return i;
  function i(o) {
    return e.enter("labelImage"), e.enter("labelImageMarker"), e.consume(o), e.exit("labelImageMarker"), a;
  }
  function a(o) {
    return o === 91 ? (e.enter("labelMarker"), e.consume(o), e.exit("labelMarker"), e.exit("labelImage"), s) : n(o);
  }
  function s(o) {
    return o === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(o) : t(o);
  }
}
const pb = {
  name: "labelStartLink",
  resolveAll: rf.resolveAll,
  tokenize: mb
};
function mb(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return e.enter("labelLink"), e.enter("labelMarker"), e.consume(s), e.exit("labelMarker"), e.exit("labelLink"), a;
  }
  function a(s) {
    return s === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(s) : t(s);
  }
}
const Ul = {
  name: "lineEnding",
  tokenize: gb
};
function gb(e, t) {
  return n;
  function n(r) {
    return e.enter("lineEnding"), e.consume(r), e.exit("lineEnding"), Pt(e, t, "linePrefix");
  }
}
const _u = {
  name: "thematicBreak",
  tokenize: bb
};
function bb(e, t, n) {
  let r = 0, i;
  return a;
  function a(c) {
    return e.enter("thematicBreak"), s(c);
  }
  function s(c) {
    return i = c, o(c);
  }
  function o(c) {
    return c === i ? (e.enter("thematicBreakSequence"), u(c)) : r >= 3 && (c === null || st(c)) ? (e.exit("thematicBreak"), t(c)) : n(c);
  }
  function u(c) {
    return c === i ? (e.consume(c), r++, u) : (e.exit("thematicBreakSequence"), Lt(c) ? Pt(e, o, "whitespace")(c) : o(c));
  }
}
const Zn = {
  continuation: {
    tokenize: _b
  },
  exit: wb,
  name: "list",
  tokenize: Tb
}, Eb = {
  partial: !0,
  tokenize: xb
}, yb = {
  partial: !0,
  tokenize: Ab
};
function Tb(e, t, n) {
  const r = this, i = r.events[r.events.length - 1];
  let a = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], !0).length : 0, s = 0;
  return o;
  function o(d) {
    const A = r.containerState.type || (d === 42 || d === 43 || d === 45 ? "listUnordered" : "listOrdered");
    if (A === "listUnordered" ? !r.containerState.marker || d === r.containerState.marker : vc(d)) {
      if (r.containerState.type || (r.containerState.type = A, e.enter(A, {
        _container: !0
      })), A === "listUnordered")
        return e.enter("listItemPrefix"), d === 42 || d === 45 ? e.check(_u, n, c)(d) : c(d);
      if (!r.interrupt || d === 49)
        return e.enter("listItemPrefix"), e.enter("listItemValue"), u(d);
    }
    return n(d);
  }
  function u(d) {
    return vc(d) && ++s < 10 ? (e.consume(d), u) : (!r.interrupt || s < 2) && (r.containerState.marker ? d === r.containerState.marker : d === 41 || d === 46) ? (e.exit("listItemValue"), c(d)) : n(d);
  }
  function c(d) {
    return e.enter("listItemMarker"), e.consume(d), e.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || d, e.check(
      To,
      // Canâ€™t be empty when interrupting.
      r.interrupt ? n : f,
      e.attempt(Eb, E, p)
    );
  }
  function f(d) {
    return r.containerState.initialBlankLine = !0, a++, E(d);
  }
  function p(d) {
    return Lt(d) ? (e.enter("listItemPrefixWhitespace"), e.consume(d), e.exit("listItemPrefixWhitespace"), E) : n(d);
  }
  function E(d) {
    return r.containerState.size = a + r.sliceSerialize(e.exit("listItemPrefix"), !0).length, t(d);
  }
}
function _b(e, t, n) {
  const r = this;
  return r.containerState._closeFlow = void 0, e.check(To, i, a);
  function i(o) {
    return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, Pt(e, t, "listItemIndent", r.containerState.size + 1)(o);
  }
  function a(o) {
    return r.containerState.furtherBlankLines || !Lt(o) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, s(o)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, e.attempt(yb, t, s)(o));
  }
  function s(o) {
    return r.containerState._closeFlow = !0, r.interrupt = void 0, Pt(e, e.attempt(Zn, t, n), "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(o);
  }
}
function Ab(e, t, n) {
  const r = this;
  return Pt(e, i, "listItemIndent", r.containerState.size + 1);
  function i(a) {
    const s = r.events[r.events.length - 1];
    return s && s[1].type === "listItemIndent" && s[2].sliceSerialize(s[1], !0).length === r.containerState.size ? t(a) : n(a);
  }
}
function wb(e) {
  e.exit(this.containerState.type);
}
function xb(e, t, n) {
  const r = this;
  return Pt(e, i, "listItemPrefixWhitespace", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5);
  function i(a) {
    const s = r.events[r.events.length - 1];
    return !Lt(a) && s && s[1].type === "listItemPrefixWhitespace" ? t(a) : n(a);
  }
}
const Oh = {
  name: "setextUnderline",
  resolveTo: Nb,
  tokenize: vb
};
function Nb(e, t) {
  let n = e.length, r, i, a;
  for (; n--; )
    if (e[n][0] === "enter") {
      if (e[n][1].type === "content") {
        r = n;
        break;
      }
      e[n][1].type === "paragraph" && (i = n);
    } else
      e[n][1].type === "content" && e.splice(n, 1), !a && e[n][1].type === "definition" && (a = n);
  const s = {
    type: "setextHeading",
    start: {
      ...e[r][1].start
    },
    end: {
      ...e[e.length - 1][1].end
    }
  };
  return e[i][1].type = "setextHeadingText", a ? (e.splice(i, 0, ["enter", s, t]), e.splice(a + 1, 0, ["exit", e[r][1], t]), e[r][1].end = {
    ...e[a][1].end
  }) : e[r][1] = s, e.push(["exit", s, t]), e;
}
function vb(e, t, n) {
  const r = this;
  let i;
  return a;
  function a(c) {
    let f = r.events.length, p;
    for (; f--; )
      if (r.events[f][1].type !== "lineEnding" && r.events[f][1].type !== "linePrefix" && r.events[f][1].type !== "content") {
        p = r.events[f][1].type === "paragraph";
        break;
      }
    return !r.parser.lazy[r.now().line] && (r.interrupt || p) ? (e.enter("setextHeadingLine"), i = c, s(c)) : n(c);
  }
  function s(c) {
    return e.enter("setextHeadingLineSequence"), o(c);
  }
  function o(c) {
    return c === i ? (e.consume(c), o) : (e.exit("setextHeadingLineSequence"), Lt(c) ? Pt(e, u, "lineSuffix")(c) : u(c));
  }
  function u(c) {
    return c === null || st(c) ? (e.exit("setextHeadingLine"), t(c)) : n(c);
  }
}
const Sb = {
  tokenize: Lb
};
function Lb(e) {
  const t = this, n = e.attempt(
    // Try to parse a blank line.
    To,
    r,
    // Try to parse initial flow (essentially, only code).
    e.attempt(this.parser.constructs.flowInitial, i, Pt(e, e.attempt(this.parser.constructs.flow, i, e.attempt(Og, i)), "linePrefix"))
  );
  return n;
  function r(a) {
    if (a === null) {
      e.consume(a);
      return;
    }
    return e.enter("lineEndingBlank"), e.consume(a), e.exit("lineEndingBlank"), t.currentConstruct = void 0, n;
  }
  function i(a) {
    if (a === null) {
      e.consume(a);
      return;
    }
    return e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), t.currentConstruct = void 0, n;
  }
}
const kb = {
  resolveAll: A1()
}, Cb = _1("string"), Ib = _1("text");
function _1(e) {
  return {
    resolveAll: A1(e === "text" ? Pb : void 0),
    tokenize: t
  };
  function t(n) {
    const r = this, i = this.parser.constructs[e], a = n.attempt(i, s, o);
    return s;
    function s(f) {
      return c(f) ? a(f) : o(f);
    }
    function o(f) {
      if (f === null) {
        n.consume(f);
        return;
      }
      return n.enter("data"), n.consume(f), u;
    }
    function u(f) {
      return c(f) ? (n.exit("data"), a(f)) : (n.consume(f), u);
    }
    function c(f) {
      if (f === null)
        return !0;
      const p = i[f];
      let E = -1;
      if (p)
        for (; ++E < p.length; ) {
          const d = p[E];
          if (!d.previous || d.previous.call(r, r.previous))
            return !0;
        }
      return !1;
    }
  }
}
function A1(e) {
  return t;
  function t(n, r) {
    let i = -1, a;
    for (; ++i <= n.length; )
      a === void 0 ? n[i] && n[i][1].type === "data" && (a = i, i++) : (!n[i] || n[i][1].type !== "data") && (i !== a + 2 && (n[a][1].end = n[i - 1][1].end, n.splice(a + 2, i - a - 2), i = a + 2), a = void 0);
    return e ? e(n, r) : n;
  }
}
function Pb(e, t) {
  let n = 0;
  for (; ++n <= e.length; )
    if ((n === e.length || e[n][1].type === "lineEnding") && e[n - 1][1].type === "data") {
      const r = e[n - 1][1], i = t.sliceStream(r);
      let a = i.length, s = -1, o = 0, u;
      for (; a--; ) {
        const c = i[a];
        if (typeof c == "string") {
          for (s = c.length; c.charCodeAt(s - 1) === 32; )
            o++, s--;
          if (s) break;
          s = -1;
        } else if (c === -2)
          u = !0, o++;
        else if (c !== -1) {
          a++;
          break;
        }
      }
      if (t._contentTypeTextTrailing && n === e.length && (o = 0), o) {
        const c = {
          type: n === e.length || u || o < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            _bufferIndex: a ? s : r.start._bufferIndex + s,
            _index: r.start._index + a,
            line: r.end.line,
            column: r.end.column - o,
            offset: r.end.offset - o
          },
          end: {
            ...r.end
          }
        };
        r.end = {
          ...c.start
        }, r.start.offset === r.end.offset ? Object.assign(r, c) : (e.splice(n, 0, ["enter", c, t], ["exit", c, t]), n += 2);
      }
      n++;
    }
  return e;
}
const Ob = {
  42: Zn,
  43: Zn,
  45: Zn,
  48: Zn,
  49: Zn,
  50: Zn,
  51: Zn,
  52: Zn,
  53: Zn,
  54: Zn,
  55: Zn,
  56: Zn,
  57: Zn,
  62: p1
}, Rb = {
  91: Bg
}, Db = {
  [-2]: Bl,
  [-1]: Bl,
  32: Bl
}, Mb = {
  35: Yg,
  42: _u,
  45: [Oh, _u],
  60: $g,
  61: Oh,
  95: _u,
  96: Ih,
  126: Ih
}, Fb = {
  38: g1,
  92: m1
}, Bb = {
  [-5]: Ul,
  [-4]: Ul,
  [-3]: Ul,
  33: hb,
  38: g1,
  42: Sc,
  60: [pg, tb],
  91: pb,
  92: [qg, m1],
  93: rf,
  95: Sc,
  96: Sg
}, Ub = {
  null: [Sc, kb]
}, Hb = {
  null: [42, 95]
}, jb = {
  null: []
}, qb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers: Hb,
  contentInitial: Rb,
  disable: jb,
  document: Ob,
  flow: Mb,
  flowInitial: Db,
  insideSpan: Ub,
  string: Fb,
  text: Bb
}, Symbol.toStringTag, { value: "Module" }));
function zb(e, t, n) {
  let r = {
    _bufferIndex: -1,
    _index: 0,
    line: n && n.line || 1,
    column: n && n.column || 1,
    offset: n && n.offset || 0
  };
  const i = {}, a = [];
  let s = [], o = [];
  const u = {
    attempt: fe(ie),
    check: fe(K),
    consume: U,
    enter: B,
    exit: V,
    interrupt: fe(K, {
      interrupt: !0
    })
  }, c = {
    code: null,
    containerState: {},
    defineSkip: v,
    events: [],
    now: A,
    parser: e,
    previous: null,
    sliceSerialize: E,
    sliceStream: d,
    write: p
  };
  let f = t.tokenize.call(c, u);
  return t.resolveAll && a.push(t), c;
  function p(N) {
    return s = Nr(s, N), C(), s[s.length - 1] !== null ? [] : (Z(t, 0), c.events = Wu(a, c.events, c), c.events);
  }
  function E(N, I) {
    return Wb(d(N), I);
  }
  function d(N) {
    return Yb(s, N);
  }
  function A() {
    const {
      _bufferIndex: N,
      _index: I,
      line: $,
      column: Y,
      offset: J
    } = r;
    return {
      _bufferIndex: N,
      _index: I,
      line: $,
      column: Y,
      offset: J
    };
  }
  function v(N) {
    i[N.line] = N.column, D();
  }
  function C() {
    let N;
    for (; r._index < s.length; ) {
      const I = s[r._index];
      if (typeof I == "string")
        for (N = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === N && r._bufferIndex < I.length; )
          _(I.charCodeAt(r._bufferIndex));
      else
        _(I);
    }
  }
  function _(N) {
    f = f(N);
  }
  function U(N) {
    st(N) ? (r.line++, r.column = 1, r.offset += N === -3 ? 2 : 1, D()) : N !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === // Points w/ non-negative `_bufferIndex` reference
    // strings.
    /** @type {string} */
    s[r._index].length && (r._bufferIndex = -1, r._index++)), c.previous = N;
  }
  function B(N, I) {
    const $ = I || {};
    return $.type = N, $.start = A(), c.events.push(["enter", $, c]), o.push($), $;
  }
  function V(N) {
    const I = o.pop();
    return I.end = A(), c.events.push(["exit", I, c]), I;
  }
  function ie(N, I) {
    Z(N, I.from);
  }
  function K(N, I) {
    I.restore();
  }
  function fe(N, I) {
    return $;
    function $(Y, J, ue) {
      let me, se, Ee, M;
      return Array.isArray(Y) ? (
        /* c8 ignore next 1 */
        L(Y)
      ) : "tokenize" in Y ? (
        // Looks like a construct.
        L([
          /** @type {Construct} */
          Y
        ])
      ) : xe(Y);
      function xe(te) {
        return le;
        function le(ge) {
          const be = ge !== null && te[ge], Ae = ge !== null && te.null, Ie = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(be) ? be : be ? [be] : [],
            ...Array.isArray(Ae) ? Ae : Ae ? [Ae] : []
          ];
          return L(Ie)(ge);
        }
      }
      function L(te) {
        return me = te, se = 0, te.length === 0 ? ue : T(te[se]);
      }
      function T(te) {
        return le;
        function le(ge) {
          return M = z(), Ee = te, te.partial || (c.currentConstruct = te), te.name && c.parser.constructs.disable.null.includes(te.name) ? ee() : te.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a â€œlive bindingâ€, which is needed for `interrupt`.
            I ? Object.assign(Object.create(c), I) : c,
            u,
            G,
            ee
          )(ge);
        }
      }
      function G(te) {
        return N(Ee, M), J;
      }
      function ee(te) {
        return M.restore(), ++se < me.length ? T(me[se]) : ue;
      }
    }
  }
  function Z(N, I) {
    N.resolveAll && !a.includes(N) && a.push(N), N.resolve && mr(c.events, I, c.events.length - I, N.resolve(c.events.slice(I), c)), N.resolveTo && (c.events = N.resolveTo(c.events, c));
  }
  function z() {
    const N = A(), I = c.previous, $ = c.currentConstruct, Y = c.events.length, J = Array.from(o);
    return {
      from: Y,
      restore: ue
    };
    function ue() {
      r = N, c.previous = I, c.currentConstruct = $, c.events.length = Y, o = J, D();
    }
  }
  function D() {
    r.line in i && r.column < 2 && (r.column = i[r.line], r.offset += i[r.line] - 1);
  }
}
function Yb(e, t) {
  const n = t.start._index, r = t.start._bufferIndex, i = t.end._index, a = t.end._bufferIndex;
  let s;
  if (n === i)
    s = [e[n].slice(r, a)];
  else {
    if (s = e.slice(n, i), r > -1) {
      const o = s[0];
      typeof o == "string" ? s[0] = o.slice(r) : s.shift();
    }
    a > 0 && s.push(e[i].slice(0, a));
  }
  return s;
}
function Wb(e, t) {
  let n = -1;
  const r = [];
  let i;
  for (; ++n < e.length; ) {
    const a = e[n];
    let s;
    if (typeof a == "string")
      s = a;
    else switch (a) {
      case -5: {
        s = "\r";
        break;
      }
      case -4: {
        s = `
`;
        break;
      }
      case -3: {
        s = `\r
`;
        break;
      }
      case -2: {
        s = t ? " " : "	";
        break;
      }
      case -1: {
        if (!t && i) continue;
        s = " ";
        break;
      }
      default:
        s = String.fromCharCode(a);
    }
    i = a === -2, r.push(s);
  }
  return r.join("");
}
function Vb(e) {
  const r = {
    constructs: (
      /** @type {FullNormalizedExtension} */
      h1([qb, ...(e || {}).extensions || []])
    ),
    content: i(og),
    defined: [],
    document: i(lg),
    flow: i(Sb),
    lazy: {},
    string: i(Cb),
    text: i(Ib)
  };
  return r;
  function i(a) {
    return s;
    function s(o) {
      return zb(r, a, o);
    }
  }
}
function Gb(e) {
  for (; !b1(e); )
    ;
  return e;
}
const Rh = /[\0\t\n\r]/g;
function $b() {
  let e = 1, t = "", n = !0, r;
  return i;
  function i(a, s, o) {
    const u = [];
    let c, f, p, E, d;
    for (a = t + (typeof a == "string" ? a.toString() : new TextDecoder(s || void 0).decode(a)), p = 0, t = "", n && (a.charCodeAt(0) === 65279 && p++, n = void 0); p < a.length; ) {
      if (Rh.lastIndex = p, c = Rh.exec(a), E = c && c.index !== void 0 ? c.index : a.length, d = a.charCodeAt(E), !c) {
        t = a.slice(p);
        break;
      }
      if (d === 10 && p === E && r)
        u.push(-3), r = void 0;
      else
        switch (r && (u.push(-5), r = void 0), p < E && (u.push(a.slice(p, E)), e += E - p), d) {
          case 0: {
            u.push(65533), e++;
            break;
          }
          case 9: {
            for (f = Math.ceil(e / 4) * 4, u.push(-2); e++ < f; ) u.push(-1);
            break;
          }
          case 10: {
            u.push(-4), e = 1;
            break;
          }
          default:
            r = !0, e = 1;
        }
      p = E + 1;
    }
    return o && (r && u.push(-5), t && u.push(t), u.push(null)), u;
  }
}
const Xb = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function Kb(e) {
  return e.replace(Xb, Qb);
}
function Qb(e, t, n) {
  if (t)
    return t;
  if (n.charCodeAt(0) === 35) {
    const i = n.charCodeAt(1), a = i === 120 || i === 88;
    return d1(n.slice(a ? 2 : 1), a ? 16 : 10);
  }
  return nf(n) || e;
}
const w1 = {}.hasOwnProperty;
function Jb(e, t, n) {
  return typeof t != "string" && (n = t, t = void 0), Zb(n)(Gb(Vb(n).document().write($b()(e, t, !0))));
}
function Zb(e) {
  const t = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: a(ke),
      autolinkProtocol: z,
      autolinkEmail: z,
      atxHeading: a(F),
      blockQuote: a(Ae),
      characterEscape: z,
      characterReference: z,
      codeFenced: a(Ie),
      codeFencedFenceInfo: s,
      codeFencedFenceMeta: s,
      codeIndented: a(Ie, s),
      codeText: a(je, s),
      codeTextData: z,
      data: z,
      codeFlowValue: z,
      definition: a(He),
      definitionDestinationString: s,
      definitionLabelString: s,
      definitionTitleString: s,
      emphasis: a(tt),
      hardBreakEscape: a(Ue),
      hardBreakTrailing: a(Ue),
      htmlFlow: a(gt, s),
      htmlFlowData: z,
      htmlText: a(gt, s),
      htmlTextData: z,
      image: a(at),
      label: s,
      link: a(ke),
      listItem: a(Ye),
      listItemValue: E,
      listOrdered: a(rt, p),
      listUnordered: a(rt),
      paragraph: a(it),
      reference: T,
      referenceString: s,
      resourceDestinationString: s,
      resourceTitleString: s,
      setextHeading: a(F),
      strong: a(nt),
      thematicBreak: a(xt)
    },
    exit: {
      atxHeading: u(),
      atxHeadingSequence: ie,
      autolink: u(),
      autolinkEmail: be,
      autolinkProtocol: ge,
      blockQuote: u(),
      characterEscapeValue: D,
      characterReferenceMarkerHexadecimal: ee,
      characterReferenceMarkerNumeric: ee,
      characterReferenceValue: te,
      characterReference: le,
      codeFenced: u(C),
      codeFencedFence: v,
      codeFencedFenceInfo: d,
      codeFencedFenceMeta: A,
      codeFlowValue: D,
      codeIndented: u(_),
      codeText: u(J),
      codeTextData: D,
      data: D,
      definition: u(),
      definitionDestinationString: V,
      definitionLabelString: U,
      definitionTitleString: B,
      emphasis: u(),
      hardBreakEscape: u(I),
      hardBreakTrailing: u(I),
      htmlFlow: u($),
      htmlFlowData: D,
      htmlText: u(Y),
      htmlTextData: D,
      image: u(me),
      label: Ee,
      labelText: se,
      lineEnding: N,
      link: u(ue),
      listItem: u(),
      listOrdered: u(),
      listUnordered: u(),
      paragraph: u(),
      referenceString: G,
      resourceDestinationString: M,
      resourceTitleString: xe,
      resource: L,
      setextHeading: u(Z),
      setextHeadingLineSequence: fe,
      setextHeadingText: K,
      strong: u(),
      thematicBreak: u()
    }
  };
  x1(t, (e || {}).mdastExtensions || []);
  const n = {};
  return r;
  function r(he) {
    let ve = {
      type: "root",
      children: []
    };
    const Fe = {
      stack: [ve],
      tokenStack: [],
      config: t,
      enter: o,
      exit: c,
      buffer: s,
      resume: f,
      data: n
    }, Re = [];
    let qe = -1;
    for (; ++qe < he.length; )
      if (he[qe][1].type === "listOrdered" || he[qe][1].type === "listUnordered")
        if (he[qe][0] === "enter")
          Re.push(qe);
        else {
          const ze = Re.pop();
          qe = i(he, ze, qe);
        }
    for (qe = -1; ++qe < he.length; ) {
      const ze = t[he[qe][0]];
      w1.call(ze, he[qe][1].type) && ze[he[qe][1].type].call(Object.assign({
        sliceSerialize: he[qe][2].sliceSerialize
      }, Fe), he[qe][1]);
    }
    if (Fe.tokenStack.length > 0) {
      const ze = Fe.tokenStack[Fe.tokenStack.length - 1];
      (ze[1] || Dh).call(Fe, void 0, ze[0]);
    }
    for (ve.position = {
      start: Wi(he.length > 0 ? he[0][1].start : {
        line: 1,
        column: 1,
        offset: 0
      }),
      end: Wi(he.length > 0 ? he[he.length - 2][1].end : {
        line: 1,
        column: 1,
        offset: 0
      })
    }, qe = -1; ++qe < t.transforms.length; )
      ve = t.transforms[qe](ve) || ve;
    return ve;
  }
  function i(he, ve, Fe) {
    let Re = ve - 1, qe = -1, ze = !1, Bt, bt, ht, dt;
    for (; ++Re <= Fe; ) {
      const Nt = he[Re];
      switch (Nt[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          Nt[0] === "enter" ? qe++ : qe--, dt = void 0;
          break;
        }
        case "lineEndingBlank": {
          Nt[0] === "enter" && (Bt && !dt && !qe && !ht && (ht = Re), dt = void 0);
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace":
          break;
        default:
          dt = void 0;
      }
      if (!qe && Nt[0] === "enter" && Nt[1].type === "listItemPrefix" || qe === -1 && Nt[0] === "exit" && (Nt[1].type === "listUnordered" || Nt[1].type === "listOrdered")) {
        if (Bt) {
          let Qe = Re;
          for (bt = void 0; Qe--; ) {
            const kt = he[Qe];
            if (kt[1].type === "lineEnding" || kt[1].type === "lineEndingBlank") {
              if (kt[0] === "exit") continue;
              bt && (he[bt][1].type = "lineEndingBlank", ze = !0), kt[1].type = "lineEnding", bt = Qe;
            } else if (!(kt[1].type === "linePrefix" || kt[1].type === "blockQuotePrefix" || kt[1].type === "blockQuotePrefixWhitespace" || kt[1].type === "blockQuoteMarker" || kt[1].type === "listItemIndent")) break;
          }
          ht && (!bt || ht < bt) && (Bt._spread = !0), Bt.end = Object.assign({}, bt ? he[bt][1].start : Nt[1].end), he.splice(bt || Re, 0, ["exit", Bt, Nt[2]]), Re++, Fe++;
        }
        if (Nt[1].type === "listItemPrefix") {
          const Qe = {
            type: "listItem",
            _spread: !1,
            start: Object.assign({}, Nt[1].start),
            // @ts-expect-error: weâ€™ll add `end` in a second.
            end: void 0
          };
          Bt = Qe, he.splice(Re, 0, ["enter", Qe, Nt[2]]), Re++, Fe++, ht = void 0, dt = !0;
        }
      }
    }
    return he[ve][1]._spread = ze, Fe;
  }
  function a(he, ve) {
    return Fe;
    function Fe(Re) {
      o.call(this, he(Re), Re), ve && ve.call(this, Re);
    }
  }
  function s() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function o(he, ve, Fe) {
    this.stack[this.stack.length - 1].children.push(he), this.stack.push(he), this.tokenStack.push([ve, Fe || void 0]), he.position = {
      start: Wi(ve.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function u(he) {
    return ve;
    function ve(Fe) {
      he && he.call(this, Fe), c.call(this, Fe);
    }
  }
  function c(he, ve) {
    const Fe = this.stack.pop(), Re = this.tokenStack.pop();
    if (Re)
      Re[0].type !== he.type && (ve ? ve.call(this, he, Re[0]) : (Re[1] || Dh).call(this, he, Re[0]));
    else throw new Error("Cannot close `" + he.type + "` (" + to({
      start: he.start,
      end: he.end
    }) + "): itâ€™s not open");
    Fe.position.end = Wi(he.end);
  }
  function f() {
    return tf(this.stack.pop());
  }
  function p() {
    this.data.expectingFirstListItemValue = !0;
  }
  function E(he) {
    if (this.data.expectingFirstListItemValue) {
      const ve = this.stack[this.stack.length - 2];
      ve.start = Number.parseInt(this.sliceSerialize(he), 10), this.data.expectingFirstListItemValue = void 0;
    }
  }
  function d() {
    const he = this.resume(), ve = this.stack[this.stack.length - 1];
    ve.lang = he;
  }
  function A() {
    const he = this.resume(), ve = this.stack[this.stack.length - 1];
    ve.meta = he;
  }
  function v() {
    this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0);
  }
  function C() {
    const he = this.resume(), ve = this.stack[this.stack.length - 1];
    ve.value = he.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
  }
  function _() {
    const he = this.resume(), ve = this.stack[this.stack.length - 1];
    ve.value = he.replace(/(\r?\n|\r)$/g, "");
  }
  function U(he) {
    const ve = this.resume(), Fe = this.stack[this.stack.length - 1];
    Fe.label = ve, Fe.identifier = Fr(this.sliceSerialize(he)).toLowerCase();
  }
  function B() {
    const he = this.resume(), ve = this.stack[this.stack.length - 1];
    ve.title = he;
  }
  function V() {
    const he = this.resume(), ve = this.stack[this.stack.length - 1];
    ve.url = he;
  }
  function ie(he) {
    const ve = this.stack[this.stack.length - 1];
    if (!ve.depth) {
      const Fe = this.sliceSerialize(he).length;
      ve.depth = Fe;
    }
  }
  function K() {
    this.data.setextHeadingSlurpLineEnding = !0;
  }
  function fe(he) {
    const ve = this.stack[this.stack.length - 1];
    ve.depth = this.sliceSerialize(he).codePointAt(0) === 61 ? 1 : 2;
  }
  function Z() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function z(he) {
    const Fe = this.stack[this.stack.length - 1].children;
    let Re = Fe[Fe.length - 1];
    (!Re || Re.type !== "text") && (Re = Dt(), Re.position = {
      start: Wi(he.start),
      // @ts-expect-error: weâ€™ll add `end` later.
      end: void 0
    }, Fe.push(Re)), this.stack.push(Re);
  }
  function D(he) {
    const ve = this.stack.pop();
    ve.value += this.sliceSerialize(he), ve.position.end = Wi(he.end);
  }
  function N(he) {
    const ve = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const Fe = ve.children[ve.children.length - 1];
      Fe.position.end = Wi(he.end), this.data.atHardBreak = void 0;
      return;
    }
    !this.data.setextHeadingSlurpLineEnding && t.canContainEols.includes(ve.type) && (z.call(this, he), D.call(this, he));
  }
  function I() {
    this.data.atHardBreak = !0;
  }
  function $() {
    const he = this.resume(), ve = this.stack[this.stack.length - 1];
    ve.value = he;
  }
  function Y() {
    const he = this.resume(), ve = this.stack[this.stack.length - 1];
    ve.value = he;
  }
  function J() {
    const he = this.resume(), ve = this.stack[this.stack.length - 1];
    ve.value = he;
  }
  function ue() {
    const he = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const ve = this.data.referenceType || "shortcut";
      he.type += "Reference", he.referenceType = ve, delete he.url, delete he.title;
    } else
      delete he.identifier, delete he.label;
    this.data.referenceType = void 0;
  }
  function me() {
    const he = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const ve = this.data.referenceType || "shortcut";
      he.type += "Reference", he.referenceType = ve, delete he.url, delete he.title;
    } else
      delete he.identifier, delete he.label;
    this.data.referenceType = void 0;
  }
  function se(he) {
    const ve = this.sliceSerialize(he), Fe = this.stack[this.stack.length - 2];
    Fe.label = Kb(ve), Fe.identifier = Fr(ve).toLowerCase();
  }
  function Ee() {
    const he = this.stack[this.stack.length - 1], ve = this.resume(), Fe = this.stack[this.stack.length - 1];
    if (this.data.inReference = !0, Fe.type === "link") {
      const Re = he.children;
      Fe.children = Re;
    } else
      Fe.alt = ve;
  }
  function M() {
    const he = this.resume(), ve = this.stack[this.stack.length - 1];
    ve.url = he;
  }
  function xe() {
    const he = this.resume(), ve = this.stack[this.stack.length - 1];
    ve.title = he;
  }
  function L() {
    this.data.inReference = void 0;
  }
  function T() {
    this.data.referenceType = "collapsed";
  }
  function G(he) {
    const ve = this.resume(), Fe = this.stack[this.stack.length - 1];
    Fe.label = ve, Fe.identifier = Fr(this.sliceSerialize(he)).toLowerCase(), this.data.referenceType = "full";
  }
  function ee(he) {
    this.data.characterReferenceType = he.type;
  }
  function te(he) {
    const ve = this.sliceSerialize(he), Fe = this.data.characterReferenceType;
    let Re;
    Fe ? (Re = d1(ve, Fe === "characterReferenceMarkerNumeric" ? 10 : 16), this.data.characterReferenceType = void 0) : Re = nf(ve);
    const qe = this.stack[this.stack.length - 1];
    qe.value += Re;
  }
  function le(he) {
    const ve = this.stack.pop();
    ve.position.end = Wi(he.end);
  }
  function ge(he) {
    D.call(this, he);
    const ve = this.stack[this.stack.length - 1];
    ve.url = this.sliceSerialize(he);
  }
  function be(he) {
    D.call(this, he);
    const ve = this.stack[this.stack.length - 1];
    ve.url = "mailto:" + this.sliceSerialize(he);
  }
  function Ae() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function Ie() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function je() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function He() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function tt() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function F() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function Ue() {
    return {
      type: "break"
    };
  }
  function gt() {
    return {
      type: "html",
      value: ""
    };
  }
  function at() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function ke() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function rt(he) {
    return {
      type: "list",
      ordered: he.type === "listOrdered",
      start: null,
      spread: he._spread,
      children: []
    };
  }
  function Ye(he) {
    return {
      type: "listItem",
      spread: he._spread,
      checked: null,
      children: []
    };
  }
  function it() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function nt() {
    return {
      type: "strong",
      children: []
    };
  }
  function Dt() {
    return {
      type: "text",
      value: ""
    };
  }
  function xt() {
    return {
      type: "thematicBreak"
    };
  }
}
function Wi(e) {
  return {
    line: e.line,
    column: e.column,
    offset: e.offset
  };
}
function x1(e, t) {
  let n = -1;
  for (; ++n < t.length; ) {
    const r = t[n];
    Array.isArray(r) ? x1(e, r) : e3(e, r);
  }
}
function e3(e, t) {
  let n;
  for (n in t)
    if (w1.call(t, n))
      switch (n) {
        case "canContainEols": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "transforms": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "enter":
        case "exit": {
          const r = t[n];
          r && Object.assign(e[n], r);
          break;
        }
      }
}
function Dh(e, t) {
  throw e ? new Error("Cannot close `" + e.type + "` (" + to({
    start: e.start,
    end: e.end
  }) + "): a different token (`" + t.type + "`, " + to({
    start: t.start,
    end: t.end
  }) + ") is open") : new Error("Cannot close document, a token (`" + t.type + "`, " + to({
    start: t.start,
    end: t.end
  }) + ") is still open");
}
function t3(e) {
  const t = this;
  t.parser = n;
  function n(r) {
    return Jb(r, {
      ...t.data("settings"),
      ...e,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: t.data("micromarkExtensions") || [],
      mdastExtensions: t.data("fromMarkdownExtensions") || []
    });
  }
}
function n3(e, t) {
  const n = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: e.wrap(e.all(t), !0)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function r3(e, t) {
  const n = { type: "element", tagName: "br", properties: {}, children: [] };
  return e.patch(t, n), [e.applyData(t, n), { type: "text", value: `
` }];
}
function i3(e, t) {
  const n = t.value ? t.value + `
` : "", r = {}, i = t.lang ? t.lang.split(/\s+/) : [];
  i.length > 0 && (r.className = ["language-" + i[0]]);
  let a = {
    type: "element",
    tagName: "code",
    properties: r,
    children: [{ type: "text", value: n }]
  };
  return t.meta && (a.data = { meta: t.meta }), e.patch(t, a), a = e.applyData(t, a), a = { type: "element", tagName: "pre", properties: {}, children: [a] }, e.patch(t, a), a;
}
function a3(e, t) {
  const n = {
    type: "element",
    tagName: "del",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function s3(e, t) {
  const n = {
    type: "element",
    tagName: "em",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function o3(e, t) {
  const n = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", r = String(t.identifier).toUpperCase(), i = ds(r.toLowerCase()), a = e.footnoteOrder.indexOf(r);
  let s, o = e.footnoteCounts.get(r);
  o === void 0 ? (o = 0, e.footnoteOrder.push(r), s = e.footnoteOrder.length) : s = a + 1, o += 1, e.footnoteCounts.set(r, o);
  const u = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + n + "fn-" + i,
      id: n + "fnref-" + i + (o > 1 ? "-" + o : ""),
      dataFootnoteRef: !0,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(s) }]
  };
  e.patch(t, u);
  const c = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [u]
  };
  return e.patch(t, c), e.applyData(t, c);
}
function u3(e, t) {
  const n = {
    type: "element",
    tagName: "h" + t.depth,
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function l3(e, t) {
  if (e.options.allowDangerousHtml) {
    const n = { type: "raw", value: t.value };
    return e.patch(t, n), e.applyData(t, n);
  }
}
function N1(e, t) {
  const n = t.referenceType;
  let r = "]";
  if (n === "collapsed" ? r += "[]" : n === "full" && (r += "[" + (t.label || t.identifier) + "]"), t.type === "imageReference")
    return [{ type: "text", value: "![" + t.alt + r }];
  const i = e.all(t), a = i[0];
  a && a.type === "text" ? a.value = "[" + a.value : i.unshift({ type: "text", value: "[" });
  const s = i[i.length - 1];
  return s && s.type === "text" ? s.value += r : i.push({ type: "text", value: r }), i;
}
function c3(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return N1(e, t);
  const i = { src: ds(r.url || ""), alt: t.alt };
  r.title !== null && r.title !== void 0 && (i.title = r.title);
  const a = { type: "element", tagName: "img", properties: i, children: [] };
  return e.patch(t, a), e.applyData(t, a);
}
function f3(e, t) {
  const n = { src: ds(t.url) };
  t.alt !== null && t.alt !== void 0 && (n.alt = t.alt), t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = { type: "element", tagName: "img", properties: n, children: [] };
  return e.patch(t, r), e.applyData(t, r);
}
function h3(e, t) {
  const n = { type: "text", value: t.value.replace(/\r?\n|\r/g, " ") };
  e.patch(t, n);
  const r = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [n]
  };
  return e.patch(t, r), e.applyData(t, r);
}
function d3(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return N1(e, t);
  const i = { href: ds(r.url || "") };
  r.title !== null && r.title !== void 0 && (i.title = r.title);
  const a = {
    type: "element",
    tagName: "a",
    properties: i,
    children: e.all(t)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function p3(e, t) {
  const n = { href: ds(t.url) };
  t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = {
    type: "element",
    tagName: "a",
    properties: n,
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function m3(e, t, n) {
  const r = e.all(t), i = n ? g3(n) : v1(t), a = {}, s = [];
  if (typeof t.checked == "boolean") {
    const f = r[0];
    let p;
    f && f.type === "element" && f.tagName === "p" ? p = f : (p = { type: "element", tagName: "p", properties: {}, children: [] }, r.unshift(p)), p.children.length > 0 && p.children.unshift({ type: "text", value: " " }), p.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: t.checked, disabled: !0 },
      children: []
    }), a.className = ["task-list-item"];
  }
  let o = -1;
  for (; ++o < r.length; ) {
    const f = r[o];
    (i || o !== 0 || f.type !== "element" || f.tagName !== "p") && s.push({ type: "text", value: `
` }), f.type === "element" && f.tagName === "p" && !i ? s.push(...f.children) : s.push(f);
  }
  const u = r[r.length - 1];
  u && (i || u.type !== "element" || u.tagName !== "p") && s.push({ type: "text", value: `
` });
  const c = { type: "element", tagName: "li", properties: a, children: s };
  return e.patch(t, c), e.applyData(t, c);
}
function g3(e) {
  let t = !1;
  if (e.type === "list") {
    t = e.spread || !1;
    const n = e.children;
    let r = -1;
    for (; !t && ++r < n.length; )
      t = v1(n[r]);
  }
  return t;
}
function v1(e) {
  const t = e.spread;
  return t ?? e.children.length > 1;
}
function b3(e, t) {
  const n = {}, r = e.all(t);
  let i = -1;
  for (typeof t.start == "number" && t.start !== 1 && (n.start = t.start); ++i < r.length; ) {
    const s = r[i];
    if (s.type === "element" && s.tagName === "li" && s.properties && Array.isArray(s.properties.className) && s.properties.className.includes("task-list-item")) {
      n.className = ["contains-task-list"];
      break;
    }
  }
  const a = {
    type: "element",
    tagName: t.ordered ? "ol" : "ul",
    properties: n,
    children: e.wrap(r, !0)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function E3(e, t) {
  const n = {
    type: "element",
    tagName: "p",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function y3(e, t) {
  const n = { type: "root", children: e.wrap(e.all(t)) };
  return e.patch(t, n), e.applyData(t, n);
}
function T3(e, t) {
  const n = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function _3(e, t) {
  const n = e.all(t), r = n.shift(), i = [];
  if (r) {
    const s = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: e.wrap([r], !0)
    };
    e.patch(t.children[0], s), i.push(s);
  }
  if (n.length > 0) {
    const s = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: e.wrap(n, !0)
    }, o = ni(t.children[1]), u = zu(t.children[t.children.length - 1]);
    o && u && (s.position = { start: o, end: u }), i.push(s);
  }
  const a = {
    type: "element",
    tagName: "table",
    properties: {},
    children: e.wrap(i, !0)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function A3(e, t, n) {
  const r = n ? n.children : void 0, a = (r ? r.indexOf(t) : 1) === 0 ? "th" : "td", s = n && n.type === "table" ? n.align : void 0, o = s ? s.length : t.children.length;
  let u = -1;
  const c = [];
  for (; ++u < o; ) {
    const p = t.children[u], E = {}, d = s ? s[u] : void 0;
    d && (E.align = d);
    let A = { type: "element", tagName: a, properties: E, children: [] };
    p && (A.children = e.all(p), e.patch(p, A), A = e.applyData(p, A)), c.push(A);
  }
  const f = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: e.wrap(c, !0)
  };
  return e.patch(t, f), e.applyData(t, f);
}
function w3(e, t) {
  const n = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
const Mh = 9, Fh = 32;
function x3(e) {
  const t = String(e), n = /\r?\n|\r/g;
  let r = n.exec(t), i = 0;
  const a = [];
  for (; r; )
    a.push(
      Bh(t.slice(i, r.index), i > 0, !0),
      r[0]
    ), i = r.index + r[0].length, r = n.exec(t);
  return a.push(Bh(t.slice(i), i > 0, !1)), a.join("");
}
function Bh(e, t, n) {
  let r = 0, i = e.length;
  if (t) {
    let a = e.codePointAt(r);
    for (; a === Mh || a === Fh; )
      r++, a = e.codePointAt(r);
  }
  if (n) {
    let a = e.codePointAt(i - 1);
    for (; a === Mh || a === Fh; )
      i--, a = e.codePointAt(i - 1);
  }
  return i > r ? e.slice(r, i) : "";
}
function N3(e, t) {
  const n = { type: "text", value: x3(String(t.value)) };
  return e.patch(t, n), e.applyData(t, n);
}
function v3(e, t) {
  const n = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  return e.patch(t, n), e.applyData(t, n);
}
const S3 = {
  blockquote: n3,
  break: r3,
  code: i3,
  delete: a3,
  emphasis: s3,
  footnoteReference: o3,
  heading: u3,
  html: l3,
  imageReference: c3,
  image: f3,
  inlineCode: h3,
  linkReference: d3,
  link: p3,
  listItem: m3,
  list: b3,
  paragraph: E3,
  // @ts-expect-error: root is different, but hard to type.
  root: y3,
  strong: T3,
  table: _3,
  tableCell: w3,
  tableRow: A3,
  text: N3,
  thematicBreak: v3,
  toml: ou,
  yaml: ou,
  definition: ou,
  footnoteDefinition: ou
};
function ou() {
}
const S1 = -1, Vu = 0, ro = 1, Iu = 2, af = 3, sf = 4, of = 5, uf = 6, L1 = 7, k1 = 8, Uh = typeof self == "object" ? self : globalThis, L3 = (e, t) => {
  const n = (i, a) => (e.set(a, i), i), r = (i) => {
    if (e.has(i))
      return e.get(i);
    const [a, s] = t[i];
    switch (a) {
      case Vu:
      case S1:
        return n(s, i);
      case ro: {
        const o = n([], i);
        for (const u of s)
          o.push(r(u));
        return o;
      }
      case Iu: {
        const o = n({}, i);
        for (const [u, c] of s)
          o[r(u)] = r(c);
        return o;
      }
      case af:
        return n(new Date(s), i);
      case sf: {
        const { source: o, flags: u } = s;
        return n(new RegExp(o, u), i);
      }
      case of: {
        const o = n(/* @__PURE__ */ new Map(), i);
        for (const [u, c] of s)
          o.set(r(u), r(c));
        return o;
      }
      case uf: {
        const o = n(/* @__PURE__ */ new Set(), i);
        for (const u of s)
          o.add(r(u));
        return o;
      }
      case L1: {
        const { name: o, message: u } = s;
        return n(new Uh[o](u), i);
      }
      case k1:
        return n(BigInt(s), i);
      case "BigInt":
        return n(Object(BigInt(s)), i);
      case "ArrayBuffer":
        return n(new Uint8Array(s).buffer, s);
      case "DataView": {
        const { buffer: o } = new Uint8Array(s);
        return n(new DataView(o), s);
      }
    }
    return n(new Uh[a](s), i);
  };
  return r;
}, Hh = (e) => L3(/* @__PURE__ */ new Map(), e)(0), Ga = "", { toString: k3 } = {}, { keys: C3 } = Object, Xs = (e) => {
  const t = typeof e;
  if (t !== "object" || !e)
    return [Vu, t];
  const n = k3.call(e).slice(8, -1);
  switch (n) {
    case "Array":
      return [ro, Ga];
    case "Object":
      return [Iu, Ga];
    case "Date":
      return [af, Ga];
    case "RegExp":
      return [sf, Ga];
    case "Map":
      return [of, Ga];
    case "Set":
      return [uf, Ga];
    case "DataView":
      return [ro, n];
  }
  return n.includes("Array") ? [ro, n] : n.includes("Error") ? [L1, n] : [Iu, n];
}, uu = ([e, t]) => e === Vu && (t === "function" || t === "symbol"), I3 = (e, t, n, r) => {
  const i = (s, o) => {
    const u = r.push(s) - 1;
    return n.set(o, u), u;
  }, a = (s) => {
    if (n.has(s))
      return n.get(s);
    let [o, u] = Xs(s);
    switch (o) {
      case Vu: {
        let f = s;
        switch (u) {
          case "bigint":
            o = k1, f = s.toString();
            break;
          case "function":
          case "symbol":
            if (e)
              throw new TypeError("unable to serialize " + u);
            f = null;
            break;
          case "undefined":
            return i([S1], s);
        }
        return i([o, f], s);
      }
      case ro: {
        if (u) {
          let E = s;
          return u === "DataView" ? E = new Uint8Array(s.buffer) : u === "ArrayBuffer" && (E = new Uint8Array(s)), i([u, [...E]], s);
        }
        const f = [], p = i([o, f], s);
        for (const E of s)
          f.push(a(E));
        return p;
      }
      case Iu: {
        if (u)
          switch (u) {
            case "BigInt":
              return i([u, s.toString()], s);
            case "Boolean":
            case "Number":
            case "String":
              return i([u, s.valueOf()], s);
          }
        if (t && "toJSON" in s)
          return a(s.toJSON());
        const f = [], p = i([o, f], s);
        for (const E of C3(s))
          (e || !uu(Xs(s[E]))) && f.push([a(E), a(s[E])]);
        return p;
      }
      case af:
        return i([o, s.toISOString()], s);
      case sf: {
        const { source: f, flags: p } = s;
        return i([o, { source: f, flags: p }], s);
      }
      case of: {
        const f = [], p = i([o, f], s);
        for (const [E, d] of s)
          (e || !(uu(Xs(E)) || uu(Xs(d)))) && f.push([a(E), a(d)]);
        return p;
      }
      case uf: {
        const f = [], p = i([o, f], s);
        for (const E of s)
          (e || !uu(Xs(E))) && f.push(a(E));
        return p;
      }
    }
    const { message: c } = s;
    return i([o, { name: u, message: c }], s);
  };
  return a;
}, jh = (e, { json: t, lossy: n } = {}) => {
  const r = [];
  return I3(!(t || n), !!t, /* @__PURE__ */ new Map(), r)(e), r;
}, cs = typeof structuredClone == "function" ? (
  /* c8 ignore start */
  (e, t) => t && ("json" in t || "lossy" in t) ? Hh(jh(e, t)) : structuredClone(e)
) : (e, t) => Hh(jh(e, t));
function P3(e, t) {
  const n = [{ type: "text", value: "â†©" }];
  return t > 1 && n.push({
    type: "element",
    tagName: "sup",
    properties: {},
    children: [{ type: "text", value: String(t) }]
  }), n;
}
function O3(e, t) {
  return "Back to reference " + (e + 1) + (t > 1 ? "-" + t : "");
}
function R3(e) {
  const t = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", n = e.options.footnoteBackContent || P3, r = e.options.footnoteBackLabel || O3, i = e.options.footnoteLabel || "Footnotes", a = e.options.footnoteLabelTagName || "h2", s = e.options.footnoteLabelProperties || {
    className: ["sr-only"]
  }, o = [];
  let u = -1;
  for (; ++u < e.footnoteOrder.length; ) {
    const c = e.footnoteById.get(
      e.footnoteOrder[u]
    );
    if (!c)
      continue;
    const f = e.all(c), p = String(c.identifier).toUpperCase(), E = ds(p.toLowerCase());
    let d = 0;
    const A = [], v = e.footnoteCounts.get(p);
    for (; v !== void 0 && ++d <= v; ) {
      A.length > 0 && A.push({ type: "text", value: " " });
      let U = typeof n == "string" ? n : n(u, d);
      typeof U == "string" && (U = { type: "text", value: U }), A.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + t + "fnref-" + E + (d > 1 ? "-" + d : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof r == "string" ? r : r(u, d),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(U) ? U : [U]
      });
    }
    const C = f[f.length - 1];
    if (C && C.type === "element" && C.tagName === "p") {
      const U = C.children[C.children.length - 1];
      U && U.type === "text" ? U.value += " " : C.children.push({ type: "text", value: " " }), C.children.push(...A);
    } else
      f.push(...A);
    const _ = {
      type: "element",
      tagName: "li",
      properties: { id: t + "fn-" + E },
      children: e.wrap(f, !0)
    };
    e.patch(c, _), o.push(_);
  }
  if (o.length !== 0)
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: !0, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: a,
          properties: {
            ...cs(s),
            id: "footnote-label"
          },
          children: [{ type: "text", value: i }]
        },
        { type: "text", value: `
` },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: e.wrap(o, !0)
        },
        { type: "text", value: `
` }
      ]
    };
}
const Gu = (
  // Note: overloads in JSDoc canâ€™t yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  (function(e) {
    if (e == null)
      return B3;
    if (typeof e == "function")
      return $u(e);
    if (typeof e == "object")
      return Array.isArray(e) ? D3(e) : (
        // Cast because `ReadonlyArray` goes into the above but `isArray`
        // narrows to `Array`.
        M3(
          /** @type {Props} */
          e
        )
      );
    if (typeof e == "string")
      return F3(e);
    throw new Error("Expected function, string, or object as test");
  })
);
function D3(e) {
  const t = [];
  let n = -1;
  for (; ++n < e.length; )
    t[n] = Gu(e[n]);
  return $u(r);
  function r(...i) {
    let a = -1;
    for (; ++a < t.length; )
      if (t[a].apply(this, i)) return !0;
    return !1;
  }
}
function M3(e) {
  const t = (
    /** @type {Record<string, unknown>} */
    e
  );
  return $u(n);
  function n(r) {
    const i = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      r
    );
    let a;
    for (a in e)
      if (i[a] !== t[a]) return !1;
    return !0;
  }
}
function F3(e) {
  return $u(t);
  function t(n) {
    return n && n.type === e;
  }
}
function $u(e) {
  return t;
  function t(n, r, i) {
    return !!(U3(n) && e.call(
      this,
      n,
      typeof r == "number" ? r : void 0,
      i || void 0
    ));
  }
}
function B3() {
  return !0;
}
function U3(e) {
  return e !== null && typeof e == "object" && "type" in e;
}
const C1 = [], H3 = !0, Lc = !1, j3 = "skip";
function I1(e, t, n, r) {
  let i;
  typeof t == "function" && typeof n != "function" ? (r = n, n = t) : i = t;
  const a = Gu(i), s = r ? -1 : 1;
  o(e, void 0, [])();
  function o(u, c, f) {
    const p = (
      /** @type {Record<string, unknown>} */
      u && typeof u == "object" ? u : {}
    );
    if (typeof p.type == "string") {
      const d = (
        // `hast`
        typeof p.tagName == "string" ? p.tagName : (
          // `xast`
          typeof p.name == "string" ? p.name : void 0
        )
      );
      Object.defineProperty(E, "name", {
        value: "node (" + (u.type + (d ? "<" + d + ">" : "")) + ")"
      });
    }
    return E;
    function E() {
      let d = C1, A, v, C;
      if ((!t || a(u, c, f[f.length - 1] || void 0)) && (d = q3(n(u, f)), d[0] === Lc))
        return d;
      if ("children" in u && u.children) {
        const _ = (
          /** @type {UnistParent} */
          u
        );
        if (_.children && d[0] !== j3)
          for (v = (r ? _.children.length : -1) + s, C = f.concat(_); v > -1 && v < _.children.length; ) {
            const U = _.children[v];
            if (A = o(U, v, C)(), A[0] === Lc)
              return A;
            v = typeof A[1] == "number" ? A[1] : v + s;
          }
      }
      return d;
    }
  }
}
function q3(e) {
  return Array.isArray(e) ? e : typeof e == "number" ? [H3, e] : e == null ? C1 : [e];
}
function Xu(e, t, n, r) {
  let i, a, s;
  typeof t == "function" && typeof n != "function" ? (a = void 0, s = t, i = n) : (a = t, s = n, i = r), I1(e, a, o, i);
  function o(u, c) {
    const f = c[c.length - 1], p = f ? f.children.indexOf(u) : void 0;
    return s(u, p, f);
  }
}
const kc = {}.hasOwnProperty, z3 = {};
function Y3(e, t) {
  const n = t || z3, r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map(), s = { ...S3, ...n.handlers }, o = {
    all: c,
    applyData: V3,
    definitionById: r,
    footnoteById: i,
    footnoteCounts: a,
    footnoteOrder: [],
    handlers: s,
    one: u,
    options: n,
    patch: W3,
    wrap: $3
  };
  return Xu(e, function(f) {
    if (f.type === "definition" || f.type === "footnoteDefinition") {
      const p = f.type === "definition" ? r : i, E = String(f.identifier).toUpperCase();
      p.has(E) || p.set(E, f);
    }
  }), o;
  function u(f, p) {
    const E = f.type, d = o.handlers[E];
    if (kc.call(o.handlers, E) && d)
      return d(o, f, p);
    if (o.options.passThrough && o.options.passThrough.includes(E)) {
      if ("children" in f) {
        const { children: v, ...C } = f, _ = cs(C);
        return _.children = o.all(f), _;
      }
      return cs(f);
    }
    return (o.options.unknownHandler || G3)(o, f, p);
  }
  function c(f) {
    const p = [];
    if ("children" in f) {
      const E = f.children;
      let d = -1;
      for (; ++d < E.length; ) {
        const A = o.one(E[d], f);
        if (A) {
          if (d && E[d - 1].type === "break" && (!Array.isArray(A) && A.type === "text" && (A.value = qh(A.value)), !Array.isArray(A) && A.type === "element")) {
            const v = A.children[0];
            v && v.type === "text" && (v.value = qh(v.value));
          }
          Array.isArray(A) ? p.push(...A) : p.push(A);
        }
      }
    }
    return p;
  }
}
function W3(e, t) {
  e.position && (t.position = O5(e));
}
function V3(e, t) {
  let n = t;
  if (e && e.data) {
    const r = e.data.hName, i = e.data.hChildren, a = e.data.hProperties;
    if (typeof r == "string")
      if (n.type === "element")
        n.tagName = r;
      else {
        const s = "children" in n ? n.children : [n];
        n = { type: "element", tagName: r, properties: {}, children: s };
      }
    n.type === "element" && a && Object.assign(n.properties, cs(a)), "children" in n && n.children && i !== null && i !== void 0 && (n.children = i);
  }
  return n;
}
function G3(e, t) {
  const n = t.data || {}, r = "value" in t && !(kc.call(n, "hProperties") || kc.call(n, "hChildren")) ? { type: "text", value: t.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function $3(e, t) {
  const n = [];
  let r = -1;
  for (t && n.push({ type: "text", value: `
` }); ++r < e.length; )
    r && n.push({ type: "text", value: `
` }), n.push(e[r]);
  return t && e.length > 0 && n.push({ type: "text", value: `
` }), n;
}
function qh(e) {
  let t = 0, n = e.charCodeAt(t);
  for (; n === 9 || n === 32; )
    t++, n = e.charCodeAt(t);
  return e.slice(t);
}
function zh(e, t) {
  const n = Y3(e, t), r = n.one(e, void 0), i = R3(n), a = Array.isArray(r) ? { type: "root", children: r } : r || { type: "root", children: [] };
  return i && a.children.push({ type: "text", value: `
` }, i), a;
}
function X3(e, t) {
  return e && "run" in e ? async function(n, r) {
    const i = (
      /** @type {HastRoot} */
      zh(n, { file: r, ...t })
    );
    await e.run(i, r);
  } : function(n, r) {
    return (
      /** @type {HastRoot} */
      zh(n, { file: r, ...e || t })
    );
  };
}
function Yh(e) {
  if (e)
    throw e;
}
var Hl, Wh;
function K3() {
  if (Wh) return Hl;
  Wh = 1;
  var e = Object.prototype.hasOwnProperty, t = Object.prototype.toString, n = Object.defineProperty, r = Object.getOwnPropertyDescriptor, i = function(c) {
    return typeof Array.isArray == "function" ? Array.isArray(c) : t.call(c) === "[object Array]";
  }, a = function(c) {
    if (!c || t.call(c) !== "[object Object]")
      return !1;
    var f = e.call(c, "constructor"), p = c.constructor && c.constructor.prototype && e.call(c.constructor.prototype, "isPrototypeOf");
    if (c.constructor && !f && !p)
      return !1;
    var E;
    for (E in c)
      ;
    return typeof E > "u" || e.call(c, E);
  }, s = function(c, f) {
    n && f.name === "__proto__" ? n(c, f.name, {
      enumerable: !0,
      configurable: !0,
      value: f.newValue,
      writable: !0
    }) : c[f.name] = f.newValue;
  }, o = function(c, f) {
    if (f === "__proto__")
      if (e.call(c, f)) {
        if (r)
          return r(c, f).value;
      } else return;
    return c[f];
  };
  return Hl = function u() {
    var c, f, p, E, d, A, v = arguments[0], C = 1, _ = arguments.length, U = !1;
    for (typeof v == "boolean" && (U = v, v = arguments[1] || {}, C = 2), (v == null || typeof v != "object" && typeof v != "function") && (v = {}); C < _; ++C)
      if (c = arguments[C], c != null)
        for (f in c)
          p = o(v, f), E = o(c, f), v !== E && (U && E && (a(E) || (d = i(E))) ? (d ? (d = !1, A = p && i(p) ? p : []) : A = p && a(p) ? p : {}, s(v, { name: f, newValue: u(U, A, E) })) : typeof E < "u" && s(v, { name: f, newValue: E }));
    return v;
  }, Hl;
}
var Q3 = K3();
const jl = /* @__PURE__ */ a1(Q3);
function Cc(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function J3() {
  const e = [], t = { run: n, use: r };
  return t;
  function n(...i) {
    let a = -1;
    const s = i.pop();
    if (typeof s != "function")
      throw new TypeError("Expected function as last argument, not " + s);
    o(null, ...i);
    function o(u, ...c) {
      const f = e[++a];
      let p = -1;
      if (u) {
        s(u);
        return;
      }
      for (; ++p < i.length; )
        (c[p] === null || c[p] === void 0) && (c[p] = i[p]);
      i = c, f ? Z3(f, o)(...c) : s(null, ...c);
    }
  }
  function r(i) {
    if (typeof i != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + i
      );
    return e.push(i), t;
  }
}
function Z3(e, t) {
  let n;
  return r;
  function r(...s) {
    const o = e.length > s.length;
    let u;
    o && s.push(i);
    try {
      u = e.apply(this, s);
    } catch (c) {
      const f = (
        /** @type {Error} */
        c
      );
      if (o && n)
        throw f;
      return i(f);
    }
    o || (u && u.then && typeof u.then == "function" ? u.then(a, i) : u instanceof Error ? i(u) : a(u));
  }
  function i(s, ...o) {
    n || (n = !0, t(s, ...o));
  }
  function a(s) {
    i(null, s);
  }
}
const Zr = { basename: e4, dirname: t4, extname: n4, join: r4, sep: "/" };
function e4(e, t) {
  if (t !== void 0 && typeof t != "string")
    throw new TypeError('"ext" argument must be a string');
  _o(e);
  let n = 0, r = -1, i = e.length, a;
  if (t === void 0 || t.length === 0 || t.length > e.length) {
    for (; i--; )
      if (e.codePointAt(i) === 47) {
        if (a) {
          n = i + 1;
          break;
        }
      } else r < 0 && (a = !0, r = i + 1);
    return r < 0 ? "" : e.slice(n, r);
  }
  if (t === e)
    return "";
  let s = -1, o = t.length - 1;
  for (; i--; )
    if (e.codePointAt(i) === 47) {
      if (a) {
        n = i + 1;
        break;
      }
    } else
      s < 0 && (a = !0, s = i + 1), o > -1 && (e.codePointAt(i) === t.codePointAt(o--) ? o < 0 && (r = i) : (o = -1, r = s));
  return n === r ? r = s : r < 0 && (r = e.length), e.slice(n, r);
}
function t4(e) {
  if (_o(e), e.length === 0)
    return ".";
  let t = -1, n = e.length, r;
  for (; --n; )
    if (e.codePointAt(n) === 47) {
      if (r) {
        t = n;
        break;
      }
    } else r || (r = !0);
  return t < 0 ? e.codePointAt(0) === 47 ? "/" : "." : t === 1 && e.codePointAt(0) === 47 ? "//" : e.slice(0, t);
}
function n4(e) {
  _o(e);
  let t = e.length, n = -1, r = 0, i = -1, a = 0, s;
  for (; t--; ) {
    const o = e.codePointAt(t);
    if (o === 47) {
      if (s) {
        r = t + 1;
        break;
      }
      continue;
    }
    n < 0 && (s = !0, n = t + 1), o === 46 ? i < 0 ? i = t : a !== 1 && (a = 1) : i > -1 && (a = -1);
  }
  return i < 0 || n < 0 || // We saw a non-dot character immediately before the dot.
  a === 0 || // The (right-most) trimmed path component is exactly `..`.
  a === 1 && i === n - 1 && i === r + 1 ? "" : e.slice(i, n);
}
function r4(...e) {
  let t = -1, n;
  for (; ++t < e.length; )
    _o(e[t]), e[t] && (n = n === void 0 ? e[t] : n + "/" + e[t]);
  return n === void 0 ? "." : i4(n);
}
function i4(e) {
  _o(e);
  const t = e.codePointAt(0) === 47;
  let n = a4(e, !t);
  return n.length === 0 && !t && (n = "."), n.length > 0 && e.codePointAt(e.length - 1) === 47 && (n += "/"), t ? "/" + n : n;
}
function a4(e, t) {
  let n = "", r = 0, i = -1, a = 0, s = -1, o, u;
  for (; ++s <= e.length; ) {
    if (s < e.length)
      o = e.codePointAt(s);
    else {
      if (o === 47)
        break;
      o = 47;
    }
    if (o === 47) {
      if (!(i === s - 1 || a === 1)) if (i !== s - 1 && a === 2) {
        if (n.length < 2 || r !== 2 || n.codePointAt(n.length - 1) !== 46 || n.codePointAt(n.length - 2) !== 46) {
          if (n.length > 2) {
            if (u = n.lastIndexOf("/"), u !== n.length - 1) {
              u < 0 ? (n = "", r = 0) : (n = n.slice(0, u), r = n.length - 1 - n.lastIndexOf("/")), i = s, a = 0;
              continue;
            }
          } else if (n.length > 0) {
            n = "", r = 0, i = s, a = 0;
            continue;
          }
        }
        t && (n = n.length > 0 ? n + "/.." : "..", r = 2);
      } else
        n.length > 0 ? n += "/" + e.slice(i + 1, s) : n = e.slice(i + 1, s), r = s - i - 1;
      i = s, a = 0;
    } else o === 46 && a > -1 ? a++ : a = -1;
  }
  return n;
}
function _o(e) {
  if (typeof e != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(e)
    );
}
const s4 = { cwd: o4 };
function o4() {
  return "/";
}
function Ic(e) {
  return !!(e !== null && typeof e == "object" && "href" in e && e.href && "protocol" in e && e.protocol && // @ts-expect-error: indexing is fine.
  e.auth === void 0);
}
function u4(e) {
  if (typeof e == "string")
    e = new URL(e);
  else if (!Ic(e)) {
    const t = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + e + "`"
    );
    throw t.code = "ERR_INVALID_ARG_TYPE", t;
  }
  if (e.protocol !== "file:") {
    const t = new TypeError("The URL must be of scheme file");
    throw t.code = "ERR_INVALID_URL_SCHEME", t;
  }
  return l4(e);
}
function l4(e) {
  if (e.hostname !== "") {
    const r = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw r.code = "ERR_INVALID_FILE_URL_HOST", r;
  }
  const t = e.pathname;
  let n = -1;
  for (; ++n < t.length; )
    if (t.codePointAt(n) === 37 && t.codePointAt(n + 1) === 50) {
      const r = t.codePointAt(n + 2);
      if (r === 70 || r === 102) {
        const i = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw i.code = "ERR_INVALID_FILE_URL_PATH", i;
      }
    }
  return decodeURIComponent(t);
}
const ql = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
class P1 {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array` â€” `{value: options}`
   * *   `URL` â€” `{path: options}`
   * *   `VFile` â€” shallow copies its data over to the new file
   * *   `object` â€” all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(t) {
    let n;
    t ? Ic(t) ? n = { path: t } : typeof t == "string" || c4(t) ? n = { value: t } : n = t : n = {}, this.cwd = "cwd" in n ? "" : s4.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
    let r = -1;
    for (; ++r < ql.length; ) {
      const a = ql[r];
      a in n && n[a] !== void 0 && n[a] !== null && (this[a] = a === "history" ? [...n[a]] : n[a]);
    }
    let i;
    for (i in n)
      ql.includes(i) || (this[i] = n[i]);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path == "string" ? Zr.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(t) {
    Yl(t, "basename"), zl(t, "basename"), this.path = Zr.join(this.dirname || "", t);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path == "string" ? Zr.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if thereâ€™s no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(t) {
    Vh(this.basename, "dirname"), this.path = Zr.join(t || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path == "string" ? Zr.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if thereâ€™s no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(t) {
    if (zl(t, "extname"), Vh(this.dirname, "extname"), t) {
      if (t.codePointAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (t.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = Zr.join(this.dirname, this.stem + (t || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(t) {
    Ic(t) && (t = u4(t)), Yl(t, "path"), this.path !== t && this.history.push(t);
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path == "string" ? Zr.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(t) {
    Yl(t, "stem"), zl(t, "stem"), this.path = Zr.join(this.dirname || "", t + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > ğŸª¦ **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(t, n, r) {
    const i = this.message(t, n, r);
    throw i.fatal = !0, i;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > ğŸª¦ **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(t, n, r) {
    const i = this.message(t, n, r);
    return i.fatal = void 0, i;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > ğŸª¦ **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(t, n, r) {
    const i = new zn(
      // @ts-expect-error: the overloads are fine.
      t,
      n,
      r
    );
    return this.path && (i.name = this.path + ":" + i.name, i.file = this.path), i.fatal = !1, this.messages.push(i), i;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when itâ€™s a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(t) {
    return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(t || void 0).decode(this.value);
  }
}
function zl(e, t) {
  if (e && e.includes(Zr.sep))
    throw new Error(
      "`" + t + "` cannot be a path: did not expect `" + Zr.sep + "`"
    );
}
function Yl(e, t) {
  if (!e)
    throw new Error("`" + t + "` cannot be empty");
}
function Vh(e, t) {
  if (!e)
    throw new Error("Setting `" + t + "` requires `path` to be set too");
}
function c4(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const f4 = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  (function(e) {
    const r = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      this.constructor.prototype
    ), i = r[e], a = function() {
      return i.apply(a, arguments);
    };
    return Object.setPrototypeOf(a, r), a;
  })
), h4 = {}.hasOwnProperty;
class lf extends f4 {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = J3();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@linkcode Processor}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const t = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new lf()
    );
    let n = -1;
    for (; ++n < this.attachers.length; ) {
      const r = this.attachers[n];
      t.use(...r);
    }
    return t.data(jl(!0, {}, this.namespace)), t;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > **Note**: to register custom data in TypeScript, augment the
   * > {@linkcode Data} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(t, n) {
    return typeof t == "string" ? arguments.length === 2 ? (Gl("data", this.frozen), this.namespace[t] = n, this) : h4.call(this.namespace, t) && this.namespace[t] || void 0 : t ? (Gl("data", this.frozen), this.namespace = t, this) : this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * Itâ€™s possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen)
      return this;
    const t = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    for (; ++this.freezeIndex < this.attachers.length; ) {
      const [n, ...r] = this.attachers[this.freezeIndex];
      if (r[0] === !1)
        continue;
      r[0] === !0 && (r[0] = void 0);
      const i = n.call(t, ...r);
      typeof i == "function" && this.transformers.use(i);
    }
    return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(t) {
    this.freeze();
    const n = lu(t), r = this.parser || this.Parser;
    return Wl("parse", r), r(String(n), n);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youâ€™re using a compiler that doesnâ€™t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(t, n) {
    const r = this;
    return this.freeze(), Wl("process", this.parser || this.Parser), Vl("process", this.compiler || this.Compiler), n ? i(void 0, n) : new Promise(i);
    function i(a, s) {
      const o = lu(t), u = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        r.parse(o)
      );
      r.run(u, o, function(f, p, E) {
        if (f || !p || !E)
          return c(f);
        const d = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          p
        ), A = r.stringify(d, E);
        m4(A) ? E.value = A : E.result = A, c(
          f,
          /** @type {VFileWithOutput<CompileResult>} */
          E
        );
      });
      function c(f, p) {
        f || !p ? s(f) : a ? a(p) : n(void 0, p);
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youâ€™re using a compiler that doesnâ€™t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(t) {
    let n = !1, r;
    return this.freeze(), Wl("processSync", this.parser || this.Parser), Vl("processSync", this.compiler || this.Compiler), this.process(t, i), $h("processSync", "process", n), r;
    function i(a, s) {
      n = !0, Yh(a), r = s;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(t, n, r) {
    Gh(t), this.freeze();
    const i = this.transformers;
    return !r && typeof n == "function" && (r = n, n = void 0), r ? a(void 0, r) : new Promise(a);
    function a(s, o) {
      const u = lu(n);
      i.run(t, u, c);
      function c(f, p, E) {
        const d = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          p || t
        );
        f ? o(f) : s ? s(d) : r(void 0, d, E);
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(t, n) {
    let r = !1, i;
    return this.run(t, n, a), $h("runSync", "run", r), i;
    function a(s, o) {
      Yh(s), i = o, r = !0;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youâ€™re using a compiler that doesnâ€™t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(t, n) {
    this.freeze();
    const r = lu(n), i = this.compiler || this.Compiler;
    return Vl("stringify", i), Gh(t), i(t, r);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(t, ...n) {
    const r = this.attachers, i = this.namespace;
    if (Gl("use", this.frozen), t != null) if (typeof t == "function")
      u(t, n);
    else if (typeof t == "object")
      Array.isArray(t) ? o(t) : s(t);
    else
      throw new TypeError("Expected usable value, not `" + t + "`");
    return this;
    function a(c) {
      if (typeof c == "function")
        u(c, []);
      else if (typeof c == "object")
        if (Array.isArray(c)) {
          const [f, ...p] = (
            /** @type {PluginTuple<Array<unknown>>} */
            c
          );
          u(f, p);
        } else
          s(c);
      else
        throw new TypeError("Expected usable value, not `" + c + "`");
    }
    function s(c) {
      if (!("plugins" in c) && !("settings" in c))
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      o(c.plugins), c.settings && (i.settings = jl(!0, i.settings, c.settings));
    }
    function o(c) {
      let f = -1;
      if (c != null) if (Array.isArray(c))
        for (; ++f < c.length; ) {
          const p = c[f];
          a(p);
        }
      else
        throw new TypeError("Expected a list of plugins, not `" + c + "`");
    }
    function u(c, f) {
      let p = -1, E = -1;
      for (; ++p < r.length; )
        if (r[p][0] === c) {
          E = p;
          break;
        }
      if (E === -1)
        r.push([c, ...f]);
      else if (f.length > 0) {
        let [d, ...A] = f;
        const v = r[E][1];
        Cc(v) && Cc(d) && (d = jl(!0, v, d)), r[E] = [c, d, ...A];
      }
    }
  }
}
const d4 = new lf().freeze();
function Wl(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `parser`");
}
function Vl(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `compiler`");
}
function Gl(e, t) {
  if (t)
    throw new Error(
      "Cannot call `" + e + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function Gh(e) {
  if (!Cc(e) || typeof e.type != "string")
    throw new TypeError("Expected node, got `" + e + "`");
}
function $h(e, t, n) {
  if (!n)
    throw new Error(
      "`" + e + "` finished async. Use `" + t + "` instead"
    );
}
function lu(e) {
  return p4(e) ? e : new P1(e);
}
function p4(e) {
  return !!(e && typeof e == "object" && "message" in e && "messages" in e);
}
function m4(e) {
  return typeof e == "string" || g4(e);
}
function g4(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const b4 = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md", Xh = [], Kh = { allowDangerousHtml: !0 }, E4 = /^(https?|ircs?|mailto|xmpp)$/i, y4 = [
  { from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" },
  { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" },
  {
    from: "allowNode",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowElement"
  },
  {
    from: "allowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowedElements"
  },
  { from: "className", id: "remove-classname" },
  {
    from: "disallowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "disallowedElements"
  },
  { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" },
  { from: "includeElementIndex", id: "#remove-includeelementindex" },
  {
    from: "includeNodeIndex",
    id: "change-includenodeindex-to-includeelementindex"
  },
  { from: "linkTarget", id: "remove-linktarget" },
  { from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" },
  { from: "rawSourcePos", id: "#remove-rawsourcepos" },
  { from: "renderers", id: "change-renderers-to-components", to: "components" },
  { from: "source", id: "change-source-to-children", to: "children" },
  { from: "sourcePos", id: "#remove-sourcepos" },
  { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" },
  { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }
];
function T4(e) {
  const t = _4(e), n = A4(e);
  return w4(t.runSync(t.parse(n), n), e);
}
function _4(e) {
  const t = e.rehypePlugins || Xh, n = e.remarkPlugins || Xh, r = e.remarkRehypeOptions ? { ...e.remarkRehypeOptions, ...Kh } : Kh;
  return d4().use(t3).use(n).use(X3, r).use(t);
}
function A4(e) {
  const t = e.children || "", n = new P1();
  return typeof t == "string" && (n.value = t), n;
}
function w4(e, t) {
  const n = t.allowedElements, r = t.allowElement, i = t.components, a = t.disallowedElements, s = t.skipHtml, o = t.unwrapDisallowed, u = t.urlTransform || x4;
  for (const f of y4)
    Object.hasOwn(t, f.from) && ("" + f.from + (f.to ? "use `" + f.to + "` instead" : "remove it") + b4 + f.id, void 0);
  return Xu(e, c), B5(e, {
    Fragment: wm,
    components: i,
    ignoreInvalidStyle: !0,
    jsx: De,
    jsxs: Ke,
    passKeys: !0,
    passNode: !0
  });
  function c(f, p, E) {
    if (f.type === "raw" && E && typeof p == "number")
      return s ? E.children.splice(p, 1) : E.children[p] = { type: "text", value: f.value }, p;
    if (f.type === "element") {
      let d;
      for (d in Fl)
        if (Object.hasOwn(Fl, d) && Object.hasOwn(f.properties, d)) {
          const A = f.properties[d], v = Fl[d];
          (v === null || v.includes(f.tagName)) && (f.properties[d] = u(String(A || ""), d, f));
        }
    }
    if (f.type === "element") {
      let d = n ? !n.includes(f.tagName) : a ? a.includes(f.tagName) : !1;
      if (!d && r && typeof p == "number" && (d = !r(f, p, E)), d && E && typeof p == "number")
        return o && f.children ? E.children.splice(p, 1, ...f.children) : E.children.splice(p, 1), p;
    }
  }
}
function x4(e) {
  const t = e.indexOf(":"), n = e.indexOf("?"), r = e.indexOf("#"), i = e.indexOf("/");
  return (
    // If there is no protocol, itâ€™s relative.
    t === -1 || // If the first colon is after a `?`, `#`, or `/`, itâ€™s not a protocol.
    i !== -1 && t > i || n !== -1 && t > n || r !== -1 && t > r || // It is a protocol, it should be allowed.
    E4.test(e.slice(0, t)) ? e : ""
  );
}
function Qh(e, t) {
  const n = String(e);
  if (typeof t != "string")
    throw new TypeError("Expected character");
  let r = 0, i = n.indexOf(t);
  for (; i !== -1; )
    r++, i = n.indexOf(t, i + t.length);
  return r;
}
function N4(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function v4(e, t, n) {
  const i = Gu((n || {}).ignore || []), a = S4(t);
  let s = -1;
  for (; ++s < a.length; )
    I1(e, "text", o);
  function o(c, f) {
    let p = -1, E;
    for (; ++p < f.length; ) {
      const d = f[p], A = E ? E.children : void 0;
      if (i(
        d,
        A ? A.indexOf(d) : void 0,
        E
      ))
        return;
      E = d;
    }
    if (E)
      return u(c, f);
  }
  function u(c, f) {
    const p = f[f.length - 1], E = a[s][0], d = a[s][1];
    let A = 0;
    const C = p.children.indexOf(c);
    let _ = !1, U = [];
    E.lastIndex = 0;
    let B = E.exec(c.value);
    for (; B; ) {
      const V = B.index, ie = {
        index: B.index,
        input: B.input,
        stack: [...f, c]
      };
      let K = d(...B, ie);
      if (typeof K == "string" && (K = K.length > 0 ? { type: "text", value: K } : void 0), K === !1 ? E.lastIndex = V + 1 : (A !== V && U.push({
        type: "text",
        value: c.value.slice(A, V)
      }), Array.isArray(K) ? U.push(...K) : K && U.push(K), A = V + B[0].length, _ = !0), !E.global)
        break;
      B = E.exec(c.value);
    }
    return _ ? (A < c.value.length && U.push({ type: "text", value: c.value.slice(A) }), p.children.splice(C, 1, ...U)) : U = [c], C + U.length;
  }
}
function S4(e) {
  const t = [];
  if (!Array.isArray(e))
    throw new TypeError("Expected find and replace tuple or list of tuples");
  const n = !e[0] || Array.isArray(e[0]) ? e : [e];
  let r = -1;
  for (; ++r < n.length; ) {
    const i = n[r];
    t.push([L4(i[0]), k4(i[1])]);
  }
  return t;
}
function L4(e) {
  return typeof e == "string" ? new RegExp(N4(e), "g") : e;
}
function k4(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}
const $l = "phrasing", Xl = ["autolink", "link", "image", "label"];
function C4() {
  return {
    transforms: [F4],
    enter: {
      literalAutolink: P4,
      literalAutolinkEmail: Kl,
      literalAutolinkHttp: Kl,
      literalAutolinkWww: Kl
    },
    exit: {
      literalAutolink: M4,
      literalAutolinkEmail: D4,
      literalAutolinkHttp: O4,
      literalAutolinkWww: R4
    }
  };
}
function I4() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct: $l,
        notInConstruct: Xl
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct: $l,
        notInConstruct: Xl
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct: $l,
        notInConstruct: Xl
      }
    ]
  };
}
function P4(e) {
  this.enter({ type: "link", title: null, url: "", children: [] }, e);
}
function Kl(e) {
  this.config.enter.autolinkProtocol.call(this, e);
}
function O4(e) {
  this.config.exit.autolinkProtocol.call(this, e);
}
function R4(e) {
  this.config.exit.data.call(this, e);
  const t = this.stack[this.stack.length - 1];
  t.type, t.url = "http://" + this.sliceSerialize(e);
}
function D4(e) {
  this.config.exit.autolinkEmail.call(this, e);
}
function M4(e) {
  this.exit(e);
}
function F4(e) {
  v4(
    e,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, B4],
      [new RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)", "gu"), U4]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function B4(e, t, n, r, i) {
  let a = "";
  if (!O1(i) || (/^w/i.test(t) && (n = t + n, t = "", a = "http://"), !H4(n)))
    return !1;
  const s = j4(n + r);
  if (!s[0]) return !1;
  const o = {
    type: "link",
    title: null,
    url: a + t + s[0],
    children: [{ type: "text", value: t + s[0] }]
  };
  return s[1] ? [o, { type: "text", value: s[1] }] : o;
}
function U4(e, t, n, r) {
  return (
    // Not an expected previous character.
    !O1(r, !0) || // Label ends in not allowed character.
    /[-\d_]$/.test(n) ? !1 : {
      type: "link",
      title: null,
      url: "mailto:" + t + "@" + n,
      children: [{ type: "text", value: t + "@" + n }]
    }
  );
}
function H4(e) {
  const t = e.split(".");
  return !(t.length < 2 || t[t.length - 1] && (/_/.test(t[t.length - 1]) || !/[a-zA-Z\d]/.test(t[t.length - 1])) || t[t.length - 2] && (/_/.test(t[t.length - 2]) || !/[a-zA-Z\d]/.test(t[t.length - 2])));
}
function j4(e) {
  const t = /[!"&'),.:;<>?\]}]+$/.exec(e);
  if (!t)
    return [e, void 0];
  e = e.slice(0, t.index);
  let n = t[0], r = n.indexOf(")");
  const i = Qh(e, "(");
  let a = Qh(e, ")");
  for (; r !== -1 && i > a; )
    e += n.slice(0, r + 1), n = n.slice(r + 1), r = n.indexOf(")"), a++;
  return [e, n];
}
function O1(e, t) {
  const n = e.input.charCodeAt(e.index - 1);
  return (e.index === 0 || va(n) || Yu(n)) && // If itâ€™s an email, the previous character should not be a slash.
  (!t || n !== 47);
}
R1.peek = K4;
function q4() {
  this.buffer();
}
function z4(e) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, e);
}
function Y4() {
  this.buffer();
}
function W4(e) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    e
  );
}
function V4(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.identifier = Fr(
    this.sliceSerialize(e)
  ).toLowerCase(), n.label = t;
}
function G4(e) {
  this.exit(e);
}
function $4(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.identifier = Fr(
    this.sliceSerialize(e)
  ).toLowerCase(), n.label = t;
}
function X4(e) {
  this.exit(e);
}
function K4() {
  return "[";
}
function R1(e, t, n, r) {
  const i = n.createTracker(r);
  let a = i.move("[^");
  const s = n.enter("footnoteReference"), o = n.enter("reference");
  return a += i.move(
    n.safe(n.associationId(e), { after: "]", before: a })
  ), o(), s(), a += i.move("]"), a;
}
function Q4() {
  return {
    enter: {
      gfmFootnoteCallString: q4,
      gfmFootnoteCall: z4,
      gfmFootnoteDefinitionLabelString: Y4,
      gfmFootnoteDefinition: W4
    },
    exit: {
      gfmFootnoteCallString: V4,
      gfmFootnoteCall: G4,
      gfmFootnoteDefinitionLabelString: $4,
      gfmFootnoteDefinition: X4
    }
  };
}
function J4(e) {
  let t = !1;
  return e && e.firstLineBlank && (t = !0), {
    handlers: { footnoteDefinition: n, footnoteReference: R1 },
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["label", "phrasing", "reference"] }]
  };
  function n(r, i, a, s) {
    const o = a.createTracker(s);
    let u = o.move("[^");
    const c = a.enter("footnoteDefinition"), f = a.enter("label");
    return u += o.move(
      a.safe(a.associationId(r), { before: u, after: "]" })
    ), f(), u += o.move("]:"), r.children && r.children.length > 0 && (o.shift(4), u += o.move(
      (t ? `
` : " ") + a.indentLines(
        a.containerFlow(r, o.current()),
        t ? D1 : Z4
      )
    )), c(), u;
  }
}
function Z4(e, t, n) {
  return t === 0 ? e : D1(e, t, n);
}
function D1(e, t, n) {
  return (n ? "" : "    ") + e;
}
const eE = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
M1.peek = aE;
function tE() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: rE },
    exit: { strikethrough: iE }
  };
}
function nE() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: eE
      }
    ],
    handlers: { delete: M1 }
  };
}
function rE(e) {
  this.enter({ type: "delete", children: [] }, e);
}
function iE(e) {
  this.exit(e);
}
function M1(e, t, n, r) {
  const i = n.createTracker(r), a = n.enter("strikethrough");
  let s = i.move("~~");
  return s += n.containerPhrasing(e, {
    ...i.current(),
    before: s,
    after: "~"
  }), s += i.move("~~"), a(), s;
}
function aE() {
  return "~";
}
function sE(e) {
  return e.length;
}
function oE(e, t) {
  const n = t || {}, r = (n.align || []).concat(), i = n.stringLength || sE, a = [], s = [], o = [], u = [];
  let c = 0, f = -1;
  for (; ++f < e.length; ) {
    const v = [], C = [];
    let _ = -1;
    for (e[f].length > c && (c = e[f].length); ++_ < e[f].length; ) {
      const U = uE(e[f][_]);
      if (n.alignDelimiters !== !1) {
        const B = i(U);
        C[_] = B, (u[_] === void 0 || B > u[_]) && (u[_] = B);
      }
      v.push(U);
    }
    s[f] = v, o[f] = C;
  }
  let p = -1;
  if (typeof r == "object" && "length" in r)
    for (; ++p < c; )
      a[p] = Jh(r[p]);
  else {
    const v = Jh(r);
    for (; ++p < c; )
      a[p] = v;
  }
  p = -1;
  const E = [], d = [];
  for (; ++p < c; ) {
    const v = a[p];
    let C = "", _ = "";
    v === 99 ? (C = ":", _ = ":") : v === 108 ? C = ":" : v === 114 && (_ = ":");
    let U = n.alignDelimiters === !1 ? 1 : Math.max(
      1,
      u[p] - C.length - _.length
    );
    const B = C + "-".repeat(U) + _;
    n.alignDelimiters !== !1 && (U = C.length + U + _.length, U > u[p] && (u[p] = U), d[p] = U), E[p] = B;
  }
  s.splice(1, 0, E), o.splice(1, 0, d), f = -1;
  const A = [];
  for (; ++f < s.length; ) {
    const v = s[f], C = o[f];
    p = -1;
    const _ = [];
    for (; ++p < c; ) {
      const U = v[p] || "";
      let B = "", V = "";
      if (n.alignDelimiters !== !1) {
        const ie = u[p] - (C[p] || 0), K = a[p];
        K === 114 ? B = " ".repeat(ie) : K === 99 ? ie % 2 ? (B = " ".repeat(ie / 2 + 0.5), V = " ".repeat(ie / 2 - 0.5)) : (B = " ".repeat(ie / 2), V = B) : V = " ".repeat(ie);
      }
      n.delimiterStart !== !1 && !p && _.push("|"), n.padding !== !1 && // Donâ€™t add the opening space if weâ€™re not aligning and the cell is
      // empty: there will be a closing space.
      !(n.alignDelimiters === !1 && U === "") && (n.delimiterStart !== !1 || p) && _.push(" "), n.alignDelimiters !== !1 && _.push(B), _.push(U), n.alignDelimiters !== !1 && _.push(V), n.padding !== !1 && _.push(" "), (n.delimiterEnd !== !1 || p !== c - 1) && _.push("|");
    }
    A.push(
      n.delimiterEnd === !1 ? _.join("").replace(/ +$/, "") : _.join("")
    );
  }
  return A.join(`
`);
}
function uE(e) {
  return e == null ? "" : String(e);
}
function Jh(e) {
  const t = typeof e == "string" ? e.codePointAt(0) : 0;
  return t === 67 || t === 99 ? 99 : t === 76 || t === 108 ? 108 : t === 82 || t === 114 ? 114 : 0;
}
const Zh = {}.hasOwnProperty;
function F1(e, t) {
  const n = t || {};
  function r(i, ...a) {
    let s = r.invalid;
    const o = r.handlers;
    if (i && Zh.call(i, e)) {
      const u = String(i[e]);
      s = Zh.call(o, u) ? o[u] : r.unknown;
    }
    if (s)
      return s.call(this, i, ...a);
  }
  return r.handlers = n.handlers || {}, r.invalid = n.invalid, r.unknown = n.unknown, r;
}
function lE(e, t, n, r) {
  const i = n.enter("blockquote"), a = n.createTracker(r);
  a.move("> "), a.shift(2);
  const s = n.indentLines(
    n.containerFlow(e, a.current()),
    cE
  );
  return i(), s;
}
function cE(e, t, n) {
  return ">" + (n ? "" : " ") + e;
}
function fE(e, t) {
  return e0(e, t.inConstruct, !0) && !e0(e, t.notInConstruct, !1);
}
function e0(e, t, n) {
  if (typeof t == "string" && (t = [t]), !t || t.length === 0)
    return n;
  let r = -1;
  for (; ++r < t.length; )
    if (e.includes(t[r]))
      return !0;
  return !1;
}
function t0(e, t, n, r) {
  let i = -1;
  for (; ++i < n.unsafe.length; )
    if (n.unsafe[i].character === `
` && fE(n.stack, n.unsafe[i]))
      return /[ \t]/.test(r.before) ? "" : " ";
  return `\\
`;
}
function hE(e, t) {
  const n = String(e);
  let r = n.indexOf(t), i = r, a = 0, s = 0;
  if (typeof t != "string")
    throw new TypeError("Expected substring");
  for (; r !== -1; )
    r === i ? ++a > s && (s = a) : a = 1, i = r + t.length, r = n.indexOf(t, i);
  return s;
}
function dE(e, t) {
  return !!(t.options.fences === !1 && e.value && // If thereâ€™s no infoâ€¦
  !e.lang && // And thereâ€™s a non-whitespace characterâ€¦
  /[^ \r\n]/.test(e.value) && // And the value doesnâ€™t start or end in a blankâ€¦
  !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value));
}
function pE(e) {
  const t = e.options.fence || "`";
  if (t !== "`" && t !== "~")
    throw new Error(
      "Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`"
    );
  return t;
}
function mE(e, t, n, r) {
  const i = pE(n), a = e.value || "", s = i === "`" ? "GraveAccent" : "Tilde";
  if (dE(e, n)) {
    const p = n.enter("codeIndented"), E = n.indentLines(a, gE);
    return p(), E;
  }
  const o = n.createTracker(r), u = i.repeat(Math.max(hE(a, i) + 1, 3)), c = n.enter("codeFenced");
  let f = o.move(u);
  if (e.lang) {
    const p = n.enter(`codeFencedLang${s}`);
    f += o.move(
      n.safe(e.lang, {
        before: f,
        after: " ",
        encode: ["`"],
        ...o.current()
      })
    ), p();
  }
  if (e.lang && e.meta) {
    const p = n.enter(`codeFencedMeta${s}`);
    f += o.move(" "), f += o.move(
      n.safe(e.meta, {
        before: f,
        after: `
`,
        encode: ["`"],
        ...o.current()
      })
    ), p();
  }
  return f += o.move(`
`), a && (f += o.move(a + `
`)), f += o.move(u), c(), f;
}
function gE(e, t, n) {
  return (n ? "" : "    ") + e;
}
function cf(e) {
  const t = e.options.quote || '"';
  if (t !== '"' && t !== "'")
    throw new Error(
      "Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`"
    );
  return t;
}
function bE(e, t, n, r) {
  const i = cf(n), a = i === '"' ? "Quote" : "Apostrophe", s = n.enter("definition");
  let o = n.enter("label");
  const u = n.createTracker(r);
  let c = u.move("[");
  return c += u.move(
    n.safe(n.associationId(e), {
      before: c,
      after: "]",
      ...u.current()
    })
  ), c += u.move("]: "), o(), // If thereâ€™s no url, orâ€¦
  !e.url || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (o = n.enter("destinationLiteral"), c += u.move("<"), c += u.move(
    n.safe(e.url, { before: c, after: ">", ...u.current() })
  ), c += u.move(">")) : (o = n.enter("destinationRaw"), c += u.move(
    n.safe(e.url, {
      before: c,
      after: e.title ? " " : `
`,
      ...u.current()
    })
  )), o(), e.title && (o = n.enter(`title${a}`), c += u.move(" " + i), c += u.move(
    n.safe(e.title, {
      before: c,
      after: i,
      ...u.current()
    })
  ), c += u.move(i), o()), s(), c;
}
function EE(e) {
  const t = e.options.emphasis || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`"
    );
  return t;
}
function po(e) {
  return "&#x" + e.toString(16).toUpperCase() + ";";
}
function Pu(e, t, n) {
  const r = ls(e), i = ls(t);
  return r === void 0 ? i === void 0 ? (
    // Letter inside:
    // we have to encode *both* letters for `_` as it is looser.
    // it already forms for `*` (and GFMs `~`).
    n === "_" ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode both (letter, whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: encode outer (letter)
    { inside: !1, outside: !0 }
  ) : r === 1 ? i === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode both (whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode inner (whitespace).
    { inside: !0, outside: !1 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  );
}
B1.peek = yE;
function B1(e, t, n, r) {
  const i = EE(n), a = n.enter("emphasis"), s = n.createTracker(r), o = s.move(i);
  let u = s.move(
    n.containerPhrasing(e, {
      after: i,
      before: o,
      ...s.current()
    })
  );
  const c = u.charCodeAt(0), f = Pu(
    r.before.charCodeAt(r.before.length - 1),
    c,
    i
  );
  f.inside && (u = po(c) + u.slice(1));
  const p = u.charCodeAt(u.length - 1), E = Pu(r.after.charCodeAt(0), p, i);
  E.inside && (u = u.slice(0, -1) + po(p));
  const d = s.move(i);
  return a(), n.attentionEncodeSurroundingInfo = {
    after: E.outside,
    before: f.outside
  }, o + u + d;
}
function yE(e, t, n) {
  return n.options.emphasis || "*";
}
function TE(e, t) {
  let n = !1;
  return Xu(e, function(r) {
    if ("value" in r && /\r?\n|\r/.test(r.value) || r.type === "break")
      return n = !0, Lc;
  }), !!((!e.depth || e.depth < 3) && tf(e) && (t.options.setext || n));
}
function _E(e, t, n, r) {
  const i = Math.max(Math.min(6, e.depth || 1), 1), a = n.createTracker(r);
  if (TE(e, n)) {
    const f = n.enter("headingSetext"), p = n.enter("phrasing"), E = n.containerPhrasing(e, {
      ...a.current(),
      before: `
`,
      after: `
`
    });
    return p(), f(), E + `
` + (i === 1 ? "=" : "-").repeat(
      // The whole sizeâ€¦
      E.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)â€¦
      (Math.max(E.lastIndexOf("\r"), E.lastIndexOf(`
`)) + 1)
    );
  }
  const s = "#".repeat(i), o = n.enter("headingAtx"), u = n.enter("phrasing");
  a.move(s + " ");
  let c = n.containerPhrasing(e, {
    before: "# ",
    after: `
`,
    ...a.current()
  });
  return /^[\t ]/.test(c) && (c = po(c.charCodeAt(0)) + c.slice(1)), c = c ? s + " " + c : s, n.options.closeAtx && (c += " " + s), u(), o(), c;
}
U1.peek = AE;
function U1(e) {
  return e.value || "";
}
function AE() {
  return "<";
}
H1.peek = wE;
function H1(e, t, n, r) {
  const i = cf(n), a = i === '"' ? "Quote" : "Apostrophe", s = n.enter("image");
  let o = n.enter("label");
  const u = n.createTracker(r);
  let c = u.move("![");
  return c += u.move(
    n.safe(e.alt, { before: c, after: "]", ...u.current() })
  ), c += u.move("]("), o(), // If thereâ€™s no url but there is a titleâ€¦
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (o = n.enter("destinationLiteral"), c += u.move("<"), c += u.move(
    n.safe(e.url, { before: c, after: ">", ...u.current() })
  ), c += u.move(">")) : (o = n.enter("destinationRaw"), c += u.move(
    n.safe(e.url, {
      before: c,
      after: e.title ? " " : ")",
      ...u.current()
    })
  )), o(), e.title && (o = n.enter(`title${a}`), c += u.move(" " + i), c += u.move(
    n.safe(e.title, {
      before: c,
      after: i,
      ...u.current()
    })
  ), c += u.move(i), o()), c += u.move(")"), s(), c;
}
function wE() {
  return "!";
}
j1.peek = xE;
function j1(e, t, n, r) {
  const i = e.referenceType, a = n.enter("imageReference");
  let s = n.enter("label");
  const o = n.createTracker(r);
  let u = o.move("![");
  const c = n.safe(e.alt, {
    before: u,
    after: "]",
    ...o.current()
  });
  u += o.move(c + "]["), s();
  const f = n.stack;
  n.stack = [], s = n.enter("reference");
  const p = n.safe(n.associationId(e), {
    before: u,
    after: "]",
    ...o.current()
  });
  return s(), n.stack = f, a(), i === "full" || !c || c !== p ? u += o.move(p + "]") : i === "shortcut" ? u = u.slice(0, -1) : u += o.move("]"), u;
}
function xE() {
  return "!";
}
q1.peek = NE;
function q1(e, t, n) {
  let r = e.value || "", i = "`", a = -1;
  for (; new RegExp("(^|[^`])" + i + "([^`]|$)").test(r); )
    i += "`";
  for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++a < n.unsafe.length; ) {
    const s = n.unsafe[a], o = n.compilePattern(s);
    let u;
    if (s.atBreak)
      for (; u = o.exec(r); ) {
        let c = u.index;
        r.charCodeAt(c) === 10 && r.charCodeAt(c - 1) === 13 && c--, r = r.slice(0, c) + " " + r.slice(u.index + 1);
      }
  }
  return i + r + i;
}
function NE() {
  return "`";
}
function z1(e, t) {
  const n = tf(e);
  return !!(!t.options.resourceLink && // If thereâ€™s a urlâ€¦
  e.url && // And thereâ€™s a no titleâ€¦
  !e.title && // And the content of `node` is a single text nodeâ€¦
  e.children && e.children.length === 1 && e.children[0].type === "text" && // And if the url is the same as the contentâ€¦
  (n === e.url || "mailto:" + n === e.url) && // And that starts w/ a protocolâ€¦
  /^[a-z][a-z+.-]+:/i.test(e.url) && // And that doesnâ€™t contain ASCII control codes (character escapes and
  // references donâ€™t work), space, or angle bracketsâ€¦
  !/[\0- <>\u007F]/.test(e.url));
}
Y1.peek = vE;
function Y1(e, t, n, r) {
  const i = cf(n), a = i === '"' ? "Quote" : "Apostrophe", s = n.createTracker(r);
  let o, u;
  if (z1(e, n)) {
    const f = n.stack;
    n.stack = [], o = n.enter("autolink");
    let p = s.move("<");
    return p += s.move(
      n.containerPhrasing(e, {
        before: p,
        after: ">",
        ...s.current()
      })
    ), p += s.move(">"), o(), n.stack = f, p;
  }
  o = n.enter("link"), u = n.enter("label");
  let c = s.move("[");
  return c += s.move(
    n.containerPhrasing(e, {
      before: c,
      after: "](",
      ...s.current()
    })
  ), c += s.move("]("), u(), // If thereâ€™s no url but there is a titleâ€¦
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (u = n.enter("destinationLiteral"), c += s.move("<"), c += s.move(
    n.safe(e.url, { before: c, after: ">", ...s.current() })
  ), c += s.move(">")) : (u = n.enter("destinationRaw"), c += s.move(
    n.safe(e.url, {
      before: c,
      after: e.title ? " " : ")",
      ...s.current()
    })
  )), u(), e.title && (u = n.enter(`title${a}`), c += s.move(" " + i), c += s.move(
    n.safe(e.title, {
      before: c,
      after: i,
      ...s.current()
    })
  ), c += s.move(i), u()), c += s.move(")"), o(), c;
}
function vE(e, t, n) {
  return z1(e, n) ? "<" : "[";
}
W1.peek = SE;
function W1(e, t, n, r) {
  const i = e.referenceType, a = n.enter("linkReference");
  let s = n.enter("label");
  const o = n.createTracker(r);
  let u = o.move("[");
  const c = n.containerPhrasing(e, {
    before: u,
    after: "]",
    ...o.current()
  });
  u += o.move(c + "]["), s();
  const f = n.stack;
  n.stack = [], s = n.enter("reference");
  const p = n.safe(n.associationId(e), {
    before: u,
    after: "]",
    ...o.current()
  });
  return s(), n.stack = f, a(), i === "full" || !c || c !== p ? u += o.move(p + "]") : i === "shortcut" ? u = u.slice(0, -1) : u += o.move("]"), u;
}
function SE() {
  return "[";
}
function ff(e) {
  const t = e.options.bullet || "*";
  if (t !== "*" && t !== "+" && t !== "-")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  return t;
}
function LE(e) {
  const t = ff(e), n = e.options.bulletOther;
  if (!n)
    return t === "*" ? "-" : "*";
  if (n !== "*" && n !== "+" && n !== "-")
    throw new Error(
      "Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  if (n === t)
    throw new Error(
      "Expected `bullet` (`" + t + "`) and `bulletOther` (`" + n + "`) to be different"
    );
  return n;
}
function kE(e) {
  const t = e.options.bulletOrdered || ".";
  if (t !== "." && t !== ")")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  return t;
}
function V1(e) {
  const t = e.options.rule || "*";
  if (t !== "*" && t !== "-" && t !== "_")
    throw new Error(
      "Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  return t;
}
function CE(e, t, n, r) {
  const i = n.enter("list"), a = n.bulletCurrent;
  let s = e.ordered ? kE(n) : ff(n);
  const o = e.ordered ? s === "." ? ")" : "." : LE(n);
  let u = t && n.bulletLastUsed ? s === n.bulletLastUsed : !1;
  if (!e.ordered) {
    const f = e.children ? e.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (s === "*" || s === "-") && // Empty first list item:
      f && (!f.children || !f.children[0]) && // Directly in two other list items:
      n.stack[n.stack.length - 1] === "list" && n.stack[n.stack.length - 2] === "listItem" && n.stack[n.stack.length - 3] === "list" && n.stack[n.stack.length - 4] === "listItem" && // That are each the first child.
      n.indexStack[n.indexStack.length - 1] === 0 && n.indexStack[n.indexStack.length - 2] === 0 && n.indexStack[n.indexStack.length - 3] === 0 && (u = !0), V1(n) === s && f
    ) {
      let p = -1;
      for (; ++p < e.children.length; ) {
        const E = e.children[p];
        if (E && E.type === "listItem" && E.children && E.children[0] && E.children[0].type === "thematicBreak") {
          u = !0;
          break;
        }
      }
    }
  }
  u && (s = o), n.bulletCurrent = s;
  const c = n.containerFlow(e, r);
  return n.bulletLastUsed = s, n.bulletCurrent = a, i(), c;
}
function IE(e) {
  const t = e.options.listItemIndent || "one";
  if (t !== "tab" && t !== "one" && t !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  return t;
}
function PE(e, t, n, r) {
  const i = IE(n);
  let a = n.bulletCurrent || ff(n);
  t && t.type === "list" && t.ordered && (a = (typeof t.start == "number" && t.start > -1 ? t.start : 1) + (n.options.incrementListMarker === !1 ? 0 : t.children.indexOf(e)) + a);
  let s = a.length + 1;
  (i === "tab" || i === "mixed" && (t && t.type === "list" && t.spread || e.spread)) && (s = Math.ceil(s / 4) * 4);
  const o = n.createTracker(r);
  o.move(a + " ".repeat(s - a.length)), o.shift(s);
  const u = n.enter("listItem"), c = n.indentLines(
    n.containerFlow(e, o.current()),
    f
  );
  return u(), c;
  function f(p, E, d) {
    return E ? (d ? "" : " ".repeat(s)) + p : (d ? a : a + " ".repeat(s - a.length)) + p;
  }
}
function OE(e, t, n, r) {
  const i = n.enter("paragraph"), a = n.enter("phrasing"), s = n.containerPhrasing(e, r);
  return a(), i(), s;
}
const RE = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  Gu([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);
function DE(e, t, n, r) {
  return (e.children.some(function(s) {
    return RE(s);
  }) ? n.containerPhrasing : n.containerFlow).call(n, e, r);
}
function ME(e) {
  const t = e.options.strong || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`"
    );
  return t;
}
G1.peek = FE;
function G1(e, t, n, r) {
  const i = ME(n), a = n.enter("strong"), s = n.createTracker(r), o = s.move(i + i);
  let u = s.move(
    n.containerPhrasing(e, {
      after: i,
      before: o,
      ...s.current()
    })
  );
  const c = u.charCodeAt(0), f = Pu(
    r.before.charCodeAt(r.before.length - 1),
    c,
    i
  );
  f.inside && (u = po(c) + u.slice(1));
  const p = u.charCodeAt(u.length - 1), E = Pu(r.after.charCodeAt(0), p, i);
  E.inside && (u = u.slice(0, -1) + po(p));
  const d = s.move(i + i);
  return a(), n.attentionEncodeSurroundingInfo = {
    after: E.outside,
    before: f.outside
  }, o + u + d;
}
function FE(e, t, n) {
  return n.options.strong || "*";
}
function BE(e, t, n, r) {
  return n.safe(e.value, r);
}
function UE(e) {
  const t = e.options.ruleRepetition || 3;
  if (t < 3)
    throw new Error(
      "Cannot serialize rules with repetition `" + t + "` for `options.ruleRepetition`, expected `3` or more"
    );
  return t;
}
function HE(e, t, n) {
  const r = (V1(n) + (n.options.ruleSpaces ? " " : "")).repeat(UE(n));
  return n.options.ruleSpaces ? r.slice(0, -1) : r;
}
const $1 = {
  blockquote: lE,
  break: t0,
  code: mE,
  definition: bE,
  emphasis: B1,
  hardBreak: t0,
  heading: _E,
  html: U1,
  image: H1,
  imageReference: j1,
  inlineCode: q1,
  link: Y1,
  linkReference: W1,
  list: CE,
  listItem: PE,
  paragraph: OE,
  root: DE,
  strong: G1,
  text: BE,
  thematicBreak: HE
};
function jE() {
  return {
    enter: {
      table: qE,
      tableData: n0,
      tableHeader: n0,
      tableRow: YE
    },
    exit: {
      codeText: WE,
      table: zE,
      tableData: Ql,
      tableHeader: Ql,
      tableRow: Ql
    }
  };
}
function qE(e) {
  const t = e._align;
  this.enter(
    {
      type: "table",
      align: t.map(function(n) {
        return n === "none" ? null : n;
      }),
      children: []
    },
    e
  ), this.data.inTable = !0;
}
function zE(e) {
  this.exit(e), this.data.inTable = void 0;
}
function YE(e) {
  this.enter({ type: "tableRow", children: [] }, e);
}
function Ql(e) {
  this.exit(e);
}
function n0(e) {
  this.enter({ type: "tableCell", children: [] }, e);
}
function WE(e) {
  let t = this.resume();
  this.data.inTable && (t = t.replace(/\\([\\|])/g, VE));
  const n = this.stack[this.stack.length - 1];
  n.type, n.value = t, this.exit(e);
}
function VE(e, t) {
  return t === "|" ? t : e;
}
function GE(e) {
  const t = e || {}, n = t.tableCellPadding, r = t.tablePipeAlign, i = t.stringLength, a = n ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: `
`, inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: !0, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: !0, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: !0, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: E,
      table: s,
      tableCell: u,
      tableRow: o
    }
  };
  function s(d, A, v, C) {
    return c(f(d, v, C), d.align);
  }
  function o(d, A, v, C) {
    const _ = p(d, v, C), U = c([_]);
    return U.slice(0, U.indexOf(`
`));
  }
  function u(d, A, v, C) {
    const _ = v.enter("tableCell"), U = v.enter("phrasing"), B = v.containerPhrasing(d, {
      ...C,
      before: a,
      after: a
    });
    return U(), _(), B;
  }
  function c(d, A) {
    return oE(d, {
      align: A,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters: r,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding: n,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength: i
    });
  }
  function f(d, A, v) {
    const C = d.children;
    let _ = -1;
    const U = [], B = A.enter("table");
    for (; ++_ < C.length; )
      U[_] = p(C[_], A, v);
    return B(), U;
  }
  function p(d, A, v) {
    const C = d.children;
    let _ = -1;
    const U = [], B = A.enter("tableRow");
    for (; ++_ < C.length; )
      U[_] = u(C[_], d, A, v);
    return B(), U;
  }
  function E(d, A, v) {
    let C = $1.inlineCode(d, A, v);
    return v.stack.includes("tableCell") && (C = C.replace(/\|/g, "\\$&")), C;
  }
}
function $E() {
  return {
    exit: {
      taskListCheckValueChecked: r0,
      taskListCheckValueUnchecked: r0,
      paragraph: KE
    }
  };
}
function XE() {
  return {
    unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }],
    handlers: { listItem: QE }
  };
}
function r0(e) {
  const t = this.stack[this.stack.length - 2];
  t.type, t.checked = e.type === "taskListCheckValueChecked";
}
function KE(e) {
  const t = this.stack[this.stack.length - 2];
  if (t && t.type === "listItem" && typeof t.checked == "boolean") {
    const n = this.stack[this.stack.length - 1];
    n.type;
    const r = n.children[0];
    if (r && r.type === "text") {
      const i = t.children;
      let a = -1, s;
      for (; ++a < i.length; ) {
        const o = i[a];
        if (o.type === "paragraph") {
          s = o;
          break;
        }
      }
      s === n && (r.value = r.value.slice(1), r.value.length === 0 ? n.children.shift() : n.position && r.position && typeof r.position.start.offset == "number" && (r.position.start.column++, r.position.start.offset++, n.position.start = Object.assign({}, r.position.start)));
    }
  }
  this.exit(e);
}
function QE(e, t, n, r) {
  const i = e.children[0], a = typeof e.checked == "boolean" && i && i.type === "paragraph", s = "[" + (e.checked ? "x" : " ") + "] ", o = n.createTracker(r);
  a && o.move(s);
  let u = $1.listItem(e, t, n, {
    ...r,
    ...o.current()
  });
  return a && (u = u.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, c)), u;
  function c(f) {
    return f + s;
  }
}
function JE() {
  return [
    C4(),
    Q4(),
    tE(),
    jE(),
    $E()
  ];
}
function ZE(e) {
  return {
    extensions: [
      I4(),
      J4(e),
      nE(),
      GE(e),
      XE()
    ]
  };
}
const e6 = {
  tokenize: s6,
  partial: !0
}, X1 = {
  tokenize: o6,
  partial: !0
}, K1 = {
  tokenize: u6,
  partial: !0
}, Q1 = {
  tokenize: l6,
  partial: !0
}, t6 = {
  tokenize: c6,
  partial: !0
}, J1 = {
  name: "wwwAutolink",
  tokenize: i6,
  previous: e2
}, Z1 = {
  name: "protocolAutolink",
  tokenize: a6,
  previous: t2
}, Si = {
  name: "emailAutolink",
  tokenize: r6,
  previous: n2
}, ri = {};
function n6() {
  return {
    text: ri
  };
}
let Ta = 48;
for (; Ta < 123; )
  ri[Ta] = Si, Ta++, Ta === 58 ? Ta = 65 : Ta === 91 && (Ta = 97);
ri[43] = Si;
ri[45] = Si;
ri[46] = Si;
ri[95] = Si;
ri[72] = [Si, Z1];
ri[104] = [Si, Z1];
ri[87] = [Si, J1];
ri[119] = [Si, J1];
function r6(e, t, n) {
  const r = this;
  let i, a;
  return s;
  function s(p) {
    return !Pc(p) || !n2.call(r, r.previous) || hf(r.events) ? n(p) : (e.enter("literalAutolink"), e.enter("literalAutolinkEmail"), o(p));
  }
  function o(p) {
    return Pc(p) ? (e.consume(p), o) : p === 64 ? (e.consume(p), u) : n(p);
  }
  function u(p) {
    return p === 46 ? e.check(t6, f, c)(p) : p === 45 || p === 95 || qn(p) ? (a = !0, e.consume(p), u) : f(p);
  }
  function c(p) {
    return e.consume(p), i = !0, u;
  }
  function f(p) {
    return a && i && Xn(r.previous) ? (e.exit("literalAutolinkEmail"), e.exit("literalAutolink"), t(p)) : n(p);
  }
}
function i6(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return s !== 87 && s !== 119 || !e2.call(r, r.previous) || hf(r.events) ? n(s) : (e.enter("literalAutolink"), e.enter("literalAutolinkWww"), e.check(e6, e.attempt(X1, e.attempt(K1, a), n), n)(s));
  }
  function a(s) {
    return e.exit("literalAutolinkWww"), e.exit("literalAutolink"), t(s);
  }
}
function a6(e, t, n) {
  const r = this;
  let i = "", a = !1;
  return s;
  function s(p) {
    return (p === 72 || p === 104) && t2.call(r, r.previous) && !hf(r.events) ? (e.enter("literalAutolink"), e.enter("literalAutolinkHttp"), i += String.fromCodePoint(p), e.consume(p), o) : n(p);
  }
  function o(p) {
    if (Xn(p) && i.length < 5)
      return i += String.fromCodePoint(p), e.consume(p), o;
    if (p === 58) {
      const E = i.toLowerCase();
      if (E === "http" || E === "https")
        return e.consume(p), u;
    }
    return n(p);
  }
  function u(p) {
    return p === 47 ? (e.consume(p), a ? c : (a = !0, u)) : n(p);
  }
  function c(p) {
    return p === null || Cu(p) || Vt(p) || va(p) || Yu(p) ? n(p) : e.attempt(X1, e.attempt(K1, f), n)(p);
  }
  function f(p) {
    return e.exit("literalAutolinkHttp"), e.exit("literalAutolink"), t(p);
  }
}
function s6(e, t, n) {
  let r = 0;
  return i;
  function i(s) {
    return (s === 87 || s === 119) && r < 3 ? (r++, e.consume(s), i) : s === 46 && r === 3 ? (e.consume(s), a) : n(s);
  }
  function a(s) {
    return s === null ? n(s) : t(s);
  }
}
function o6(e, t, n) {
  let r, i, a;
  return s;
  function s(c) {
    return c === 46 || c === 95 ? e.check(Q1, u, o)(c) : c === null || Vt(c) || va(c) || c !== 45 && Yu(c) ? u(c) : (a = !0, e.consume(c), s);
  }
  function o(c) {
    return c === 95 ? r = !0 : (i = r, r = void 0), e.consume(c), s;
  }
  function u(c) {
    return i || r || !a ? n(c) : t(c);
  }
}
function u6(e, t) {
  let n = 0, r = 0;
  return i;
  function i(s) {
    return s === 40 ? (n++, e.consume(s), i) : s === 41 && r < n ? a(s) : s === 33 || s === 34 || s === 38 || s === 39 || s === 41 || s === 42 || s === 44 || s === 46 || s === 58 || s === 59 || s === 60 || s === 63 || s === 93 || s === 95 || s === 126 ? e.check(Q1, t, a)(s) : s === null || Vt(s) || va(s) ? t(s) : (e.consume(s), i);
  }
  function a(s) {
    return s === 41 && r++, e.consume(s), i;
  }
}
function l6(e, t, n) {
  return r;
  function r(o) {
    return o === 33 || o === 34 || o === 39 || o === 41 || o === 42 || o === 44 || o === 46 || o === 58 || o === 59 || o === 63 || o === 95 || o === 126 ? (e.consume(o), r) : o === 38 ? (e.consume(o), a) : o === 93 ? (e.consume(o), i) : (
      // `<` is an end.
      o === 60 || // So is whitespace.
      o === null || Vt(o) || va(o) ? t(o) : n(o)
    );
  }
  function i(o) {
    return o === null || o === 40 || o === 91 || Vt(o) || va(o) ? t(o) : r(o);
  }
  function a(o) {
    return Xn(o) ? s(o) : n(o);
  }
  function s(o) {
    return o === 59 ? (e.consume(o), r) : Xn(o) ? (e.consume(o), s) : n(o);
  }
}
function c6(e, t, n) {
  return r;
  function r(a) {
    return e.consume(a), i;
  }
  function i(a) {
    return qn(a) ? n(a) : t(a);
  }
}
function e2(e) {
  return e === null || e === 40 || e === 42 || e === 95 || e === 91 || e === 93 || e === 126 || Vt(e);
}
function t2(e) {
  return !Xn(e);
}
function n2(e) {
  return !(e === 47 || Pc(e));
}
function Pc(e) {
  return e === 43 || e === 45 || e === 46 || e === 95 || qn(e);
}
function hf(e) {
  let t = e.length, n = !1;
  for (; t--; ) {
    const r = e[t][1];
    if ((r.type === "labelLink" || r.type === "labelImage") && !r._balanced) {
      n = !0;
      break;
    }
    if (r._gfmAutolinkLiteralWalkedInto) {
      n = !1;
      break;
    }
  }
  return e.length > 0 && !n && (e[e.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), n;
}
const f6 = {
  tokenize: y6,
  partial: !0
};
function h6() {
  return {
    document: {
      91: {
        name: "gfmFootnoteDefinition",
        tokenize: g6,
        continuation: {
          tokenize: b6
        },
        exit: E6
      }
    },
    text: {
      91: {
        name: "gfmFootnoteCall",
        tokenize: m6
      },
      93: {
        name: "gfmPotentialFootnoteCall",
        add: "after",
        tokenize: d6,
        resolveTo: p6
      }
    }
  };
}
function d6(e, t, n) {
  const r = this;
  let i = r.events.length;
  const a = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let s;
  for (; i--; ) {
    const u = r.events[i][1];
    if (u.type === "labelImage") {
      s = u;
      break;
    }
    if (u.type === "gfmFootnoteCall" || u.type === "labelLink" || u.type === "label" || u.type === "image" || u.type === "link")
      break;
  }
  return o;
  function o(u) {
    if (!s || !s._balanced)
      return n(u);
    const c = Fr(r.sliceSerialize({
      start: s.end,
      end: r.now()
    }));
    return c.codePointAt(0) !== 94 || !a.includes(c.slice(1)) ? n(u) : (e.enter("gfmFootnoteCallLabelMarker"), e.consume(u), e.exit("gfmFootnoteCallLabelMarker"), t(u));
  }
}
function p6(e, t) {
  let n = e.length;
  for (; n--; )
    if (e[n][1].type === "labelImage" && e[n][0] === "enter") {
      e[n][1];
      break;
    }
  e[n + 1][1].type = "data", e[n + 3][1].type = "gfmFootnoteCallLabelMarker";
  const r = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, e[n + 3][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, i = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, e[n + 3][1].end),
    end: Object.assign({}, e[n + 3][1].end)
  };
  i.end.column++, i.end.offset++, i.end._bufferIndex++;
  const a = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, i.end),
    end: Object.assign({}, e[e.length - 1][1].start)
  }, s = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, a.start),
    end: Object.assign({}, a.end)
  }, o = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    e[n + 1],
    e[n + 2],
    ["enter", r, t],
    // The `[`
    e[n + 3],
    e[n + 4],
    // The `^`.
    ["enter", i, t],
    ["exit", i, t],
    // Everything in between.
    ["enter", a, t],
    ["enter", s, t],
    ["exit", s, t],
    ["exit", a, t],
    // The ending (`]`, properly parsed and labelled).
    e[e.length - 2],
    e[e.length - 1],
    ["exit", r, t]
  ];
  return e.splice(n, e.length - n + 1, ...o), e;
}
function m6(e, t, n) {
  const r = this, i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let a = 0, s;
  return o;
  function o(p) {
    return e.enter("gfmFootnoteCall"), e.enter("gfmFootnoteCallLabelMarker"), e.consume(p), e.exit("gfmFootnoteCallLabelMarker"), u;
  }
  function u(p) {
    return p !== 94 ? n(p) : (e.enter("gfmFootnoteCallMarker"), e.consume(p), e.exit("gfmFootnoteCallMarker"), e.enter("gfmFootnoteCallString"), e.enter("chunkString").contentType = "string", c);
  }
  function c(p) {
    if (
      // Too long.
      a > 999 || // Closing brace with nothing.
      p === 93 && !s || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      p === null || p === 91 || Vt(p)
    )
      return n(p);
    if (p === 93) {
      e.exit("chunkString");
      const E = e.exit("gfmFootnoteCallString");
      return i.includes(Fr(r.sliceSerialize(E))) ? (e.enter("gfmFootnoteCallLabelMarker"), e.consume(p), e.exit("gfmFootnoteCallLabelMarker"), e.exit("gfmFootnoteCall"), t) : n(p);
    }
    return Vt(p) || (s = !0), a++, e.consume(p), p === 92 ? f : c;
  }
  function f(p) {
    return p === 91 || p === 92 || p === 93 ? (e.consume(p), a++, c) : c(p);
  }
}
function g6(e, t, n) {
  const r = this, i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let a, s = 0, o;
  return u;
  function u(A) {
    return e.enter("gfmFootnoteDefinition")._container = !0, e.enter("gfmFootnoteDefinitionLabel"), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(A), e.exit("gfmFootnoteDefinitionLabelMarker"), c;
  }
  function c(A) {
    return A === 94 ? (e.enter("gfmFootnoteDefinitionMarker"), e.consume(A), e.exit("gfmFootnoteDefinitionMarker"), e.enter("gfmFootnoteDefinitionLabelString"), e.enter("chunkString").contentType = "string", f) : n(A);
  }
  function f(A) {
    if (
      // Too long.
      s > 999 || // Closing brace with nothing.
      A === 93 && !o || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      A === null || A === 91 || Vt(A)
    )
      return n(A);
    if (A === 93) {
      e.exit("chunkString");
      const v = e.exit("gfmFootnoteDefinitionLabelString");
      return a = Fr(r.sliceSerialize(v)), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(A), e.exit("gfmFootnoteDefinitionLabelMarker"), e.exit("gfmFootnoteDefinitionLabel"), E;
    }
    return Vt(A) || (o = !0), s++, e.consume(A), A === 92 ? p : f;
  }
  function p(A) {
    return A === 91 || A === 92 || A === 93 ? (e.consume(A), s++, f) : f(A);
  }
  function E(A) {
    return A === 58 ? (e.enter("definitionMarker"), e.consume(A), e.exit("definitionMarker"), i.includes(a) || i.push(a), Pt(e, d, "gfmFootnoteDefinitionWhitespace")) : n(A);
  }
  function d(A) {
    return t(A);
  }
}
function b6(e, t, n) {
  return e.check(To, t, e.attempt(f6, t, n));
}
function E6(e) {
  e.exit("gfmFootnoteDefinition");
}
function y6(e, t, n) {
  const r = this;
  return Pt(e, i, "gfmFootnoteDefinitionIndent", 5);
  function i(a) {
    const s = r.events[r.events.length - 1];
    return s && s[1].type === "gfmFootnoteDefinitionIndent" && s[2].sliceSerialize(s[1], !0).length === 4 ? t(a) : n(a);
  }
}
function T6(e) {
  let n = (e || {}).singleTilde;
  const r = {
    name: "strikethrough",
    tokenize: a,
    resolveAll: i
  };
  return n == null && (n = !0), {
    text: {
      126: r
    },
    insideSpan: {
      null: [r]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function i(s, o) {
    let u = -1;
    for (; ++u < s.length; )
      if (s[u][0] === "enter" && s[u][1].type === "strikethroughSequenceTemporary" && s[u][1]._close) {
        let c = u;
        for (; c--; )
          if (s[c][0] === "exit" && s[c][1].type === "strikethroughSequenceTemporary" && s[c][1]._open && // If the sizes are the same:
          s[u][1].end.offset - s[u][1].start.offset === s[c][1].end.offset - s[c][1].start.offset) {
            s[u][1].type = "strikethroughSequence", s[c][1].type = "strikethroughSequence";
            const f = {
              type: "strikethrough",
              start: Object.assign({}, s[c][1].start),
              end: Object.assign({}, s[u][1].end)
            }, p = {
              type: "strikethroughText",
              start: Object.assign({}, s[c][1].end),
              end: Object.assign({}, s[u][1].start)
            }, E = [["enter", f, o], ["enter", s[c][1], o], ["exit", s[c][1], o], ["enter", p, o]], d = o.parser.constructs.insideSpan.null;
            d && mr(E, E.length, 0, Wu(d, s.slice(c + 1, u), o)), mr(E, E.length, 0, [["exit", p, o], ["enter", s[u][1], o], ["exit", s[u][1], o], ["exit", f, o]]), mr(s, c - 1, u - c + 3, E), u = c + E.length - 2;
            break;
          }
      }
    for (u = -1; ++u < s.length; )
      s[u][1].type === "strikethroughSequenceTemporary" && (s[u][1].type = "data");
    return s;
  }
  function a(s, o, u) {
    const c = this.previous, f = this.events;
    let p = 0;
    return E;
    function E(A) {
      return c === 126 && f[f.length - 1][1].type !== "characterEscape" ? u(A) : (s.enter("strikethroughSequenceTemporary"), d(A));
    }
    function d(A) {
      const v = ls(c);
      if (A === 126)
        return p > 1 ? u(A) : (s.consume(A), p++, d);
      if (p < 2 && !n) return u(A);
      const C = s.exit("strikethroughSequenceTemporary"), _ = ls(A);
      return C._open = !_ || _ === 2 && !!v, C._close = !v || v === 2 && !!_, o(A);
    }
  }
}
class _6 {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(t, n, r) {
    A6(this, t, n, r);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImplementation(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(t) {
    if (this.map.sort(function(a, s) {
      return a[0] - s[0];
    }), this.map.length === 0)
      return;
    let n = this.map.length;
    const r = [];
    for (; n > 0; )
      n -= 1, r.push(t.slice(this.map[n][0] + this.map[n][1]), this.map[n][2]), t.length = this.map[n][0];
    r.push(t.slice()), t.length = 0;
    let i = r.pop();
    for (; i; ) {
      for (const a of i)
        t.push(a);
      i = r.pop();
    }
    this.map.length = 0;
  }
}
function A6(e, t, n, r) {
  let i = 0;
  if (!(n === 0 && r.length === 0)) {
    for (; i < e.map.length; ) {
      if (e.map[i][0] === t) {
        e.map[i][1] += n, e.map[i][2].push(...r);
        return;
      }
      i += 1;
    }
    e.map.push([t, n, r]);
  }
}
function w6(e, t) {
  let n = !1;
  const r = [];
  for (; t < e.length; ) {
    const i = e[t];
    if (n) {
      if (i[0] === "enter")
        i[1].type === "tableContent" && r.push(e[t + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
      else if (i[1].type === "tableContent") {
        if (e[t - 1][1].type === "tableDelimiterMarker") {
          const a = r.length - 1;
          r[a] = r[a] === "left" ? "center" : "right";
        }
      } else if (i[1].type === "tableDelimiterRow")
        break;
    } else i[0] === "enter" && i[1].type === "tableDelimiterRow" && (n = !0);
    t += 1;
  }
  return r;
}
function x6() {
  return {
    flow: {
      null: {
        name: "table",
        tokenize: N6,
        resolveAll: v6
      }
    }
  };
}
function N6(e, t, n) {
  const r = this;
  let i = 0, a = 0, s;
  return o;
  function o(D) {
    let N = r.events.length - 1;
    for (; N > -1; ) {
      const Y = r.events[N][1].type;
      if (Y === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      Y === "linePrefix") N--;
      else break;
    }
    const I = N > -1 ? r.events[N][1].type : null, $ = I === "tableHead" || I === "tableRow" ? K : u;
    return $ === K && r.parser.lazy[r.now().line] ? n(D) : $(D);
  }
  function u(D) {
    return e.enter("tableHead"), e.enter("tableRow"), c(D);
  }
  function c(D) {
    return D === 124 || (s = !0, a += 1), f(D);
  }
  function f(D) {
    return D === null ? n(D) : st(D) ? a > 1 ? (a = 0, r.interrupt = !0, e.exit("tableRow"), e.enter("lineEnding"), e.consume(D), e.exit("lineEnding"), d) : n(D) : Lt(D) ? Pt(e, f, "whitespace")(D) : (a += 1, s && (s = !1, i += 1), D === 124 ? (e.enter("tableCellDivider"), e.consume(D), e.exit("tableCellDivider"), s = !0, f) : (e.enter("data"), p(D)));
  }
  function p(D) {
    return D === null || D === 124 || Vt(D) ? (e.exit("data"), f(D)) : (e.consume(D), D === 92 ? E : p);
  }
  function E(D) {
    return D === 92 || D === 124 ? (e.consume(D), p) : p(D);
  }
  function d(D) {
    return r.interrupt = !1, r.parser.lazy[r.now().line] ? n(D) : (e.enter("tableDelimiterRow"), s = !1, Lt(D) ? Pt(e, A, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(D) : A(D));
  }
  function A(D) {
    return D === 45 || D === 58 ? C(D) : D === 124 ? (s = !0, e.enter("tableCellDivider"), e.consume(D), e.exit("tableCellDivider"), v) : ie(D);
  }
  function v(D) {
    return Lt(D) ? Pt(e, C, "whitespace")(D) : C(D);
  }
  function C(D) {
    return D === 58 ? (a += 1, s = !0, e.enter("tableDelimiterMarker"), e.consume(D), e.exit("tableDelimiterMarker"), _) : D === 45 ? (a += 1, _(D)) : D === null || st(D) ? V(D) : ie(D);
  }
  function _(D) {
    return D === 45 ? (e.enter("tableDelimiterFiller"), U(D)) : ie(D);
  }
  function U(D) {
    return D === 45 ? (e.consume(D), U) : D === 58 ? (s = !0, e.exit("tableDelimiterFiller"), e.enter("tableDelimiterMarker"), e.consume(D), e.exit("tableDelimiterMarker"), B) : (e.exit("tableDelimiterFiller"), B(D));
  }
  function B(D) {
    return Lt(D) ? Pt(e, V, "whitespace")(D) : V(D);
  }
  function V(D) {
    return D === 124 ? A(D) : D === null || st(D) ? !s || i !== a ? ie(D) : (e.exit("tableDelimiterRow"), e.exit("tableHead"), t(D)) : ie(D);
  }
  function ie(D) {
    return n(D);
  }
  function K(D) {
    return e.enter("tableRow"), fe(D);
  }
  function fe(D) {
    return D === 124 ? (e.enter("tableCellDivider"), e.consume(D), e.exit("tableCellDivider"), fe) : D === null || st(D) ? (e.exit("tableRow"), t(D)) : Lt(D) ? Pt(e, fe, "whitespace")(D) : (e.enter("data"), Z(D));
  }
  function Z(D) {
    return D === null || D === 124 || Vt(D) ? (e.exit("data"), fe(D)) : (e.consume(D), D === 92 ? z : Z);
  }
  function z(D) {
    return D === 92 || D === 124 ? (e.consume(D), Z) : Z(D);
  }
}
function v6(e, t) {
  let n = -1, r = !0, i = 0, a = [0, 0, 0, 0], s = [0, 0, 0, 0], o = !1, u = 0, c, f, p;
  const E = new _6();
  for (; ++n < e.length; ) {
    const d = e[n], A = d[1];
    d[0] === "enter" ? A.type === "tableHead" ? (o = !1, u !== 0 && (i0(E, t, u, c, f), f = void 0, u = 0), c = {
      type: "table",
      start: Object.assign({}, A.start),
      // Note: correct end is set later.
      end: Object.assign({}, A.end)
    }, E.add(n, 0, [["enter", c, t]])) : A.type === "tableRow" || A.type === "tableDelimiterRow" ? (r = !0, p = void 0, a = [0, 0, 0, 0], s = [0, n + 1, 0, 0], o && (o = !1, f = {
      type: "tableBody",
      start: Object.assign({}, A.start),
      // Note: correct end is set later.
      end: Object.assign({}, A.end)
    }, E.add(n, 0, [["enter", f, t]])), i = A.type === "tableDelimiterRow" ? 2 : f ? 3 : 1) : i && (A.type === "data" || A.type === "tableDelimiterMarker" || A.type === "tableDelimiterFiller") ? (r = !1, s[2] === 0 && (a[1] !== 0 && (s[0] = s[1], p = cu(E, t, a, i, void 0, p), a = [0, 0, 0, 0]), s[2] = n)) : A.type === "tableCellDivider" && (r ? r = !1 : (a[1] !== 0 && (s[0] = s[1], p = cu(E, t, a, i, void 0, p)), a = s, s = [a[1], n, 0, 0])) : A.type === "tableHead" ? (o = !0, u = n) : A.type === "tableRow" || A.type === "tableDelimiterRow" ? (u = n, a[1] !== 0 ? (s[0] = s[1], p = cu(E, t, a, i, n, p)) : s[1] !== 0 && (p = cu(E, t, s, i, n, p)), i = 0) : i && (A.type === "data" || A.type === "tableDelimiterMarker" || A.type === "tableDelimiterFiller") && (s[3] = n);
  }
  for (u !== 0 && i0(E, t, u, c, f), E.consume(t.events), n = -1; ++n < t.events.length; ) {
    const d = t.events[n];
    d[0] === "enter" && d[1].type === "table" && (d[1]._align = w6(t.events, n));
  }
  return e;
}
function cu(e, t, n, r, i, a) {
  const s = r === 1 ? "tableHeader" : r === 2 ? "tableDelimiter" : "tableData", o = "tableContent";
  n[0] !== 0 && (a.end = Object.assign({}, Za(t.events, n[0])), e.add(n[0], 0, [["exit", a, t]]));
  const u = Za(t.events, n[1]);
  if (a = {
    type: s,
    start: Object.assign({}, u),
    // Note: correct end is set later.
    end: Object.assign({}, u)
  }, e.add(n[1], 0, [["enter", a, t]]), n[2] !== 0) {
    const c = Za(t.events, n[2]), f = Za(t.events, n[3]), p = {
      type: o,
      start: Object.assign({}, c),
      end: Object.assign({}, f)
    };
    if (e.add(n[2], 0, [["enter", p, t]]), r !== 2) {
      const E = t.events[n[2]], d = t.events[n[3]];
      if (E[1].end = Object.assign({}, d[1].end), E[1].type = "chunkText", E[1].contentType = "text", n[3] > n[2] + 1) {
        const A = n[2] + 1, v = n[3] - n[2] - 1;
        e.add(A, v, []);
      }
    }
    e.add(n[3] + 1, 0, [["exit", p, t]]);
  }
  return i !== void 0 && (a.end = Object.assign({}, Za(t.events, i)), e.add(i, 0, [["exit", a, t]]), a = void 0), a;
}
function i0(e, t, n, r, i) {
  const a = [], s = Za(t.events, n);
  i && (i.end = Object.assign({}, s), a.push(["exit", i, t])), r.end = Object.assign({}, s), a.push(["exit", r, t]), e.add(n + 1, 0, a);
}
function Za(e, t) {
  const n = e[t], r = n[0] === "enter" ? "start" : "end";
  return n[1][r];
}
const S6 = {
  name: "tasklistCheck",
  tokenize: k6
};
function L6() {
  return {
    text: {
      91: S6
    }
  };
}
function k6(e, t, n) {
  const r = this;
  return i;
  function i(u) {
    return (
      // Exit if thereâ€™s stuff before.
      r.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !r._gfmTasklistFirstContentOfListItem ? n(u) : (e.enter("taskListCheck"), e.enter("taskListCheckMarker"), e.consume(u), e.exit("taskListCheckMarker"), a)
    );
  }
  function a(u) {
    return Vt(u) ? (e.enter("taskListCheckValueUnchecked"), e.consume(u), e.exit("taskListCheckValueUnchecked"), s) : u === 88 || u === 120 ? (e.enter("taskListCheckValueChecked"), e.consume(u), e.exit("taskListCheckValueChecked"), s) : n(u);
  }
  function s(u) {
    return u === 93 ? (e.enter("taskListCheckMarker"), e.consume(u), e.exit("taskListCheckMarker"), e.exit("taskListCheck"), o) : n(u);
  }
  function o(u) {
    return st(u) ? t(u) : Lt(u) ? e.check({
      tokenize: C6
    }, t, n)(u) : n(u);
  }
}
function C6(e, t, n) {
  return Pt(e, r, "whitespace");
  function r(i) {
    return i === null ? n(i) : t(i);
  }
}
function I6(e) {
  return h1([
    n6(),
    h6(),
    T6(e),
    x6(),
    L6()
  ]);
}
const P6 = {};
function O6(e) {
  const t = (
    /** @type {Processor<Root>} */
    this
  ), n = e || P6, r = t.data(), i = r.micromarkExtensions || (r.micromarkExtensions = []), a = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = []), s = r.toMarkdownExtensions || (r.toMarkdownExtensions = []);
  i.push(I6(n)), a.push(JE()), s.push(ZE(n));
}
const a0 = /[#.]/g;
function R6(e, t) {
  const n = e || "", r = {};
  let i = 0, a, s;
  for (; i < n.length; ) {
    a0.lastIndex = i;
    const o = a0.exec(n), u = n.slice(i, o ? o.index : n.length);
    u && (a ? a === "#" ? r.id = u : Array.isArray(r.className) ? r.className.push(u) : r.className = [u] : s = u, i += u.length), o && (a = o[0], i++);
  }
  return {
    type: "element",
    // @ts-expect-error: tag name is parsed.
    tagName: s || t || "div",
    properties: r,
    children: []
  };
}
function r2(e, t, n) {
  const r = n ? B6(n) : void 0;
  function i(a, s, ...o) {
    let u;
    if (a == null) {
      u = { type: "root", children: [] };
      const c = (
        /** @type {Child} */
        s
      );
      o.unshift(c);
    } else {
      u = R6(a, t);
      const c = u.tagName.toLowerCase(), f = r ? r.get(c) : void 0;
      if (u.tagName = f || c, D6(s))
        o.unshift(s);
      else
        for (const [p, E] of Object.entries(s))
          M6(e, u.properties, p, E);
    }
    for (const c of o)
      Oc(u.children, c);
    return u.type === "element" && u.tagName === "template" && (u.content = { type: "root", children: u.children }, u.children = []), u;
  }
  return i;
}
function D6(e) {
  if (e === null || typeof e != "object" || Array.isArray(e))
    return !0;
  if (typeof e.type != "string") return !1;
  const t = (
    /** @type {Record<string, unknown>} */
    e
  ), n = Object.keys(e);
  for (const r of n) {
    const i = t[r];
    if (i && typeof i == "object") {
      if (!Array.isArray(i)) return !0;
      const a = (
        /** @type {ReadonlyArray<unknown>} */
        i
      );
      for (const s of a)
        if (typeof s != "number" && typeof s != "string")
          return !0;
    }
  }
  return !!("children" in e && Array.isArray(e.children));
}
function M6(e, t, n, r) {
  const i = qu(e, n);
  let a;
  if (r != null) {
    if (typeof r == "number") {
      if (Number.isNaN(r)) return;
      a = r;
    } else typeof r == "boolean" ? a = r : typeof r == "string" ? i.spaceSeparated ? a = Eh(r) : i.commaSeparated ? a = dh(r) : i.commaOrSpaceSeparated ? a = Eh(dh(r).join(" ")) : a = s0(i, i.property, r) : Array.isArray(r) ? a = [...r] : a = i.property === "style" ? F6(r) : String(r);
    if (Array.isArray(a)) {
      const s = [];
      for (const o of a)
        s.push(
          /** @type {number | string} */
          s0(i, i.property, o)
        );
      a = s;
    }
    i.property === "className" && Array.isArray(t.className) && (a = t.className.concat(
      /** @type {Array<number | string> | number | string} */
      a
    )), t[i.property] = a;
  }
}
function Oc(e, t) {
  if (t != null) if (typeof t == "number" || typeof t == "string")
    e.push({ type: "text", value: String(t) });
  else if (Array.isArray(t))
    for (const n of t)
      Oc(e, n);
  else if (typeof t == "object" && "type" in t)
    t.type === "root" ? Oc(e, t.children) : e.push(t);
  else
    throw new Error("Expected node, nodes, or string, got `" + t + "`");
}
function s0(e, t, n) {
  if (typeof n == "string") {
    if (e.number && n && !Number.isNaN(Number(n)))
      return Number(n);
    if ((e.boolean || e.overloadedBoolean) && (n === "" || fo(n) === fo(t)))
      return !0;
  }
  return n;
}
function F6(e) {
  const t = [];
  for (const [n, r] of Object.entries(e))
    t.push([n, r].join(": "));
  return t.join("; ");
}
function B6(e) {
  const t = /* @__PURE__ */ new Map();
  for (const n of e)
    t.set(n.toLowerCase(), n);
  return t;
}
const U6 = [
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "solidColor",
  "textArea",
  "textPath"
], H6 = r2(yo, "div"), j6 = r2(ea, "g", U6);
function q6(e) {
  const t = String(e), n = [];
  return { toOffset: i, toPoint: r };
  function r(a) {
    if (typeof a == "number" && a > -1 && a <= t.length) {
      let s = 0;
      for (; ; ) {
        let o = n[s];
        if (o === void 0) {
          const u = o0(t, n[s - 1]);
          o = u === -1 ? t.length + 1 : u + 1, n[s] = o;
        }
        if (o > a)
          return {
            line: s + 1,
            column: a - (s > 0 ? n[s - 1] : 0) + 1,
            offset: a
          };
        s++;
      }
    }
  }
  function i(a) {
    if (a && typeof a.line == "number" && typeof a.column == "number" && !Number.isNaN(a.line) && !Number.isNaN(a.column)) {
      for (; n.length < a.line; ) {
        const o = n[n.length - 1], u = o0(t, o), c = u === -1 ? t.length + 1 : u + 1;
        if (o === c) break;
        n.push(c);
      }
      const s = (a.line > 1 ? n[a.line - 2] : 0) + a.column - 1;
      if (s < n[a.line - 1]) return s;
    }
  }
}
function o0(e, t) {
  const n = e.indexOf("\r", t), r = e.indexOf(`
`, t);
  return r === -1 ? n : n === -1 || n + 1 === r ? r : n < r ? n : r;
}
const wa = {
  html: "http://www.w3.org/1999/xhtml",
  mathml: "http://www.w3.org/1998/Math/MathML",
  svg: "http://www.w3.org/2000/svg",
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
}, i2 = {}.hasOwnProperty, z6 = Object.prototype;
function Y6(e, t) {
  const n = t || {};
  return df(
    {
      file: n.file || void 0,
      location: !1,
      schema: n.space === "svg" ? ea : yo,
      verbose: n.verbose || !1
    },
    e
  );
}
function df(e, t) {
  let n;
  switch (t.nodeName) {
    case "#comment": {
      const r = (
        /** @type {DefaultTreeAdapterMap['commentNode']} */
        t
      );
      return n = { type: "comment", value: r.data }, Au(e, r, n), n;
    }
    case "#document":
    case "#document-fragment": {
      const r = (
        /** @type {DefaultTreeAdapterMap['document'] | DefaultTreeAdapterMap['documentFragment']} */
        t
      ), i = "mode" in r ? r.mode === "quirks" || r.mode === "limited-quirks" : !1;
      if (n = {
        type: "root",
        children: a2(e, t.childNodes),
        data: { quirksMode: i }
      }, e.file && e.location) {
        const a = String(e.file), s = q6(a), o = s.toPoint(0), u = s.toPoint(a.length);
        n.position = { start: o, end: u };
      }
      return n;
    }
    case "#documentType": {
      const r = (
        /** @type {DefaultTreeAdapterMap['documentType']} */
        t
      );
      return n = { type: "doctype" }, Au(e, r, n), n;
    }
    case "#text": {
      const r = (
        /** @type {DefaultTreeAdapterMap['textNode']} */
        t
      );
      return n = { type: "text", value: r.value }, Au(e, r, n), n;
    }
    // Element.
    default:
      return n = W6(
        e,
        /** @type {DefaultTreeAdapterMap['element']} */
        t
      ), n;
  }
}
function a2(e, t) {
  let n = -1;
  const r = [];
  for (; ++n < t.length; ) {
    const i = (
      /** @type {RootContent} */
      df(e, t[n])
    );
    r.push(i);
  }
  return r;
}
function W6(e, t) {
  const n = e.schema;
  e.schema = t.namespaceURI === wa.svg ? ea : yo;
  let r = -1;
  const i = {};
  for (; ++r < t.attrs.length; ) {
    const o = t.attrs[r], u = (o.prefix ? o.prefix + ":" : "") + o.name;
    i2.call(z6, u) || (i[u] = o.value);
  }
  const s = (e.schema.space === "svg" ? j6 : H6)(t.tagName, i, a2(e, t.childNodes));
  if (Au(e, t, s), s.tagName === "template") {
    const o = (
      /** @type {DefaultTreeAdapterMap['template']} */
      t
    ), u = o.sourceCodeLocation, c = u && u.startTag && ns(u.startTag), f = u && u.endTag && ns(u.endTag), p = (
      /** @type {Root} */
      df(e, o.content)
    );
    c && f && e.file && (p.position = { start: c.end, end: f.start }), s.content = p;
  }
  return e.schema = n, s;
}
function Au(e, t, n) {
  if ("sourceCodeLocation" in t && t.sourceCodeLocation && e.file) {
    const r = V6(e, n, t.sourceCodeLocation);
    r && (e.location = !0, n.position = r);
  }
}
function V6(e, t, n) {
  const r = ns(n);
  if (t.type === "element") {
    const i = t.children[t.children.length - 1];
    if (r && !n.endTag && i && i.position && i.position.end && (r.end = Object.assign({}, i.position.end)), e.verbose) {
      const a = {};
      let s;
      if (n.attrs)
        for (s in n.attrs)
          i2.call(n.attrs, s) && (a[qu(e.schema, s).property] = ns(
            n.attrs[s]
          ));
      n.startTag;
      const o = ns(n.startTag), u = n.endTag ? ns(n.endTag) : void 0, c = { opening: o };
      u && (c.closing = u), c.properties = a, t.data = { position: c };
    }
  }
  return r;
}
function ns(e) {
  const t = u0({
    line: e.startLine,
    column: e.startCol,
    offset: e.startOffset
  }), n = u0({
    line: e.endLine,
    column: e.endCol,
    offset: e.endOffset
  });
  return t || n ? { start: t, end: n } : void 0;
}
function u0(e) {
  return e.line && e.column ? e : void 0;
}
const G6 = {}, $6 = {}.hasOwnProperty, s2 = F1("type", { handlers: { root: K6, element: ty, text: Z6, comment: ey, doctype: J6 } });
function X6(e, t) {
  const r = (t || G6).space;
  return s2(e, r === "svg" ? ea : yo);
}
function K6(e, t) {
  const n = {
    nodeName: "#document",
    // @ts-expect-error: `parse5` uses enums, which are actually strings.
    mode: (e.data || {}).quirksMode ? "quirks" : "no-quirks",
    childNodes: []
  };
  return n.childNodes = pf(e.children, n, t), ps(e, n), n;
}
function Q6(e, t) {
  const n = { nodeName: "#document-fragment", childNodes: [] };
  return n.childNodes = pf(e.children, n, t), ps(e, n), n;
}
function J6(e) {
  const t = {
    nodeName: "#documentType",
    name: "html",
    publicId: "",
    systemId: "",
    parentNode: null
  };
  return ps(e, t), t;
}
function Z6(e) {
  const t = {
    nodeName: "#text",
    value: e.value,
    parentNode: null
  };
  return ps(e, t), t;
}
function ey(e) {
  const t = {
    nodeName: "#comment",
    data: e.value,
    parentNode: null
  };
  return ps(e, t), t;
}
function ty(e, t) {
  const n = t;
  let r = n;
  e.type === "element" && e.tagName.toLowerCase() === "svg" && n.space === "html" && (r = ea);
  const i = [];
  let a;
  if (e.properties) {
    for (a in e.properties)
      if (a !== "children" && $6.call(e.properties, a)) {
        const u = ny(
          r,
          a,
          e.properties[a]
        );
        u && i.push(u);
      }
  }
  const s = r.space, o = {
    nodeName: e.tagName,
    tagName: e.tagName,
    attrs: i,
    // @ts-expect-error: `parse5` types are wrong.
    namespaceURI: wa[s],
    childNodes: [],
    parentNode: null
  };
  return o.childNodes = pf(e.children, o, r), ps(e, o), e.tagName === "template" && e.content && (o.content = Q6(e.content, r)), o;
}
function ny(e, t, n) {
  const r = qu(e, t);
  if (n === !1 || n === null || n === void 0 || typeof n == "number" && Number.isNaN(n) || !n && r.boolean)
    return;
  Array.isArray(n) && (n = r.commaSeparated ? Kd(n) : i1(n));
  const i = {
    name: r.attribute,
    value: n === !0 ? "" : String(n)
  };
  if (r.space && r.space !== "html" && r.space !== "svg") {
    const a = i.name.indexOf(":");
    a < 0 ? i.prefix = "" : (i.name = i.name.slice(a + 1), i.prefix = r.attribute.slice(0, a)), i.namespace = wa[r.space];
  }
  return i;
}
function pf(e, t, n) {
  let r = -1;
  const i = [];
  if (e)
    for (; ++r < e.length; ) {
      const a = s2(e[r], n);
      a.parentNode = t, i.push(a);
    }
  return i;
}
function ps(e, t) {
  const n = e.position;
  n && n.start && n.end && (n.start.offset, n.end.offset, t.sourceCodeLocation = {
    startLine: n.start.line,
    startCol: n.start.column,
    startOffset: n.start.offset,
    endLine: n.end.line,
    endCol: n.end.column,
    endOffset: n.end.offset
  });
}
const ry = [
  "area",
  "base",
  "basefont",
  "bgsound",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "image",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
], iy = /* @__PURE__ */ new Set([
  65534,
  65535,
  131070,
  131071,
  196606,
  196607,
  262142,
  262143,
  327678,
  327679,
  393214,
  393215,
  458750,
  458751,
  524286,
  524287,
  589822,
  589823,
  655358,
  655359,
  720894,
  720895,
  786430,
  786431,
  851966,
  851967,
  917502,
  917503,
  983038,
  983039,
  1048574,
  1048575,
  1114110,
  1114111
]), en = "ï¿½";
var R;
(function(e) {
  e[e.EOF = -1] = "EOF", e[e.NULL = 0] = "NULL", e[e.TABULATION = 9] = "TABULATION", e[e.CARRIAGE_RETURN = 13] = "CARRIAGE_RETURN", e[e.LINE_FEED = 10] = "LINE_FEED", e[e.FORM_FEED = 12] = "FORM_FEED", e[e.SPACE = 32] = "SPACE", e[e.EXCLAMATION_MARK = 33] = "EXCLAMATION_MARK", e[e.QUOTATION_MARK = 34] = "QUOTATION_MARK", e[e.AMPERSAND = 38] = "AMPERSAND", e[e.APOSTROPHE = 39] = "APOSTROPHE", e[e.HYPHEN_MINUS = 45] = "HYPHEN_MINUS", e[e.SOLIDUS = 47] = "SOLIDUS", e[e.DIGIT_0 = 48] = "DIGIT_0", e[e.DIGIT_9 = 57] = "DIGIT_9", e[e.SEMICOLON = 59] = "SEMICOLON", e[e.LESS_THAN_SIGN = 60] = "LESS_THAN_SIGN", e[e.EQUALS_SIGN = 61] = "EQUALS_SIGN", e[e.GREATER_THAN_SIGN = 62] = "GREATER_THAN_SIGN", e[e.QUESTION_MARK = 63] = "QUESTION_MARK", e[e.LATIN_CAPITAL_A = 65] = "LATIN_CAPITAL_A", e[e.LATIN_CAPITAL_Z = 90] = "LATIN_CAPITAL_Z", e[e.RIGHT_SQUARE_BRACKET = 93] = "RIGHT_SQUARE_BRACKET", e[e.GRAVE_ACCENT = 96] = "GRAVE_ACCENT", e[e.LATIN_SMALL_A = 97] = "LATIN_SMALL_A", e[e.LATIN_SMALL_Z = 122] = "LATIN_SMALL_Z";
})(R || (R = {}));
const Jn = {
  DASH_DASH: "--",
  CDATA_START: "[CDATA[",
  DOCTYPE: "doctype",
  SCRIPT: "script",
  PUBLIC: "public",
  SYSTEM: "system"
};
function o2(e) {
  return e >= 55296 && e <= 57343;
}
function ay(e) {
  return e >= 56320 && e <= 57343;
}
function sy(e, t) {
  return (e - 55296) * 1024 + 9216 + t;
}
function u2(e) {
  return e !== 32 && e !== 10 && e !== 13 && e !== 9 && e !== 12 && e >= 1 && e <= 31 || e >= 127 && e <= 159;
}
function l2(e) {
  return e >= 64976 && e <= 65007 || iy.has(e);
}
var ye;
(function(e) {
  e.controlCharacterInInputStream = "control-character-in-input-stream", e.noncharacterInInputStream = "noncharacter-in-input-stream", e.surrogateInInputStream = "surrogate-in-input-stream", e.nonVoidHtmlElementStartTagWithTrailingSolidus = "non-void-html-element-start-tag-with-trailing-solidus", e.endTagWithAttributes = "end-tag-with-attributes", e.endTagWithTrailingSolidus = "end-tag-with-trailing-solidus", e.unexpectedSolidusInTag = "unexpected-solidus-in-tag", e.unexpectedNullCharacter = "unexpected-null-character", e.unexpectedQuestionMarkInsteadOfTagName = "unexpected-question-mark-instead-of-tag-name", e.invalidFirstCharacterOfTagName = "invalid-first-character-of-tag-name", e.unexpectedEqualsSignBeforeAttributeName = "unexpected-equals-sign-before-attribute-name", e.missingEndTagName = "missing-end-tag-name", e.unexpectedCharacterInAttributeName = "unexpected-character-in-attribute-name", e.unknownNamedCharacterReference = "unknown-named-character-reference", e.missingSemicolonAfterCharacterReference = "missing-semicolon-after-character-reference", e.unexpectedCharacterAfterDoctypeSystemIdentifier = "unexpected-character-after-doctype-system-identifier", e.unexpectedCharacterInUnquotedAttributeValue = "unexpected-character-in-unquoted-attribute-value", e.eofBeforeTagName = "eof-before-tag-name", e.eofInTag = "eof-in-tag", e.missingAttributeValue = "missing-attribute-value", e.missingWhitespaceBetweenAttributes = "missing-whitespace-between-attributes", e.missingWhitespaceAfterDoctypePublicKeyword = "missing-whitespace-after-doctype-public-keyword", e.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers = "missing-whitespace-between-doctype-public-and-system-identifiers", e.missingWhitespaceAfterDoctypeSystemKeyword = "missing-whitespace-after-doctype-system-keyword", e.missingQuoteBeforeDoctypePublicIdentifier = "missing-quote-before-doctype-public-identifier", e.missingQuoteBeforeDoctypeSystemIdentifier = "missing-quote-before-doctype-system-identifier", e.missingDoctypePublicIdentifier = "missing-doctype-public-identifier", e.missingDoctypeSystemIdentifier = "missing-doctype-system-identifier", e.abruptDoctypePublicIdentifier = "abrupt-doctype-public-identifier", e.abruptDoctypeSystemIdentifier = "abrupt-doctype-system-identifier", e.cdataInHtmlContent = "cdata-in-html-content", e.incorrectlyOpenedComment = "incorrectly-opened-comment", e.eofInScriptHtmlCommentLikeText = "eof-in-script-html-comment-like-text", e.eofInDoctype = "eof-in-doctype", e.nestedComment = "nested-comment", e.abruptClosingOfEmptyComment = "abrupt-closing-of-empty-comment", e.eofInComment = "eof-in-comment", e.incorrectlyClosedComment = "incorrectly-closed-comment", e.eofInCdata = "eof-in-cdata", e.absenceOfDigitsInNumericCharacterReference = "absence-of-digits-in-numeric-character-reference", e.nullCharacterReference = "null-character-reference", e.surrogateCharacterReference = "surrogate-character-reference", e.characterReferenceOutsideUnicodeRange = "character-reference-outside-unicode-range", e.controlCharacterReference = "control-character-reference", e.noncharacterCharacterReference = "noncharacter-character-reference", e.missingWhitespaceBeforeDoctypeName = "missing-whitespace-before-doctype-name", e.missingDoctypeName = "missing-doctype-name", e.invalidCharacterSequenceAfterDoctypeName = "invalid-character-sequence-after-doctype-name", e.duplicateAttribute = "duplicate-attribute", e.nonConformingDoctype = "non-conforming-doctype", e.missingDoctype = "missing-doctype", e.misplacedDoctype = "misplaced-doctype", e.endTagWithoutMatchingOpenElement = "end-tag-without-matching-open-element", e.closingOfElementWithOpenChildElements = "closing-of-element-with-open-child-elements", e.disallowedContentInNoscriptInHead = "disallowed-content-in-noscript-in-head", e.openElementsLeftAfterEof = "open-elements-left-after-eof", e.abandonedHeadElementChild = "abandoned-head-element-child", e.misplacedStartTagForHeadElement = "misplaced-start-tag-for-head-element", e.nestedNoscriptInHead = "nested-noscript-in-head", e.eofInElementThatCanContainOnlyText = "eof-in-element-that-can-contain-only-text";
})(ye || (ye = {}));
const oy = 65536;
class uy {
  constructor(t) {
    this.handler = t, this.html = "", this.pos = -1, this.lastGapPos = -2, this.gapStack = [], this.skipNextNewLine = !1, this.lastChunkWritten = !1, this.endOfChunkHit = !1, this.bufferWaterline = oy, this.isEol = !1, this.lineStartPos = 0, this.droppedBufferSize = 0, this.line = 1, this.lastErrOffset = -1;
  }
  /** The column on the current line. If we just saw a gap (eg. a surrogate pair), return the index before. */
  get col() {
    return this.pos - this.lineStartPos + +(this.lastGapPos !== this.pos);
  }
  get offset() {
    return this.droppedBufferSize + this.pos;
  }
  getError(t, n) {
    const { line: r, col: i, offset: a } = this, s = i + n, o = a + n;
    return {
      code: t,
      startLine: r,
      endLine: r,
      startCol: s,
      endCol: s,
      startOffset: o,
      endOffset: o
    };
  }
  _err(t) {
    this.handler.onParseError && this.lastErrOffset !== this.offset && (this.lastErrOffset = this.offset, this.handler.onParseError(this.getError(t, 0)));
  }
  _addGap() {
    this.gapStack.push(this.lastGapPos), this.lastGapPos = this.pos;
  }
  _processSurrogate(t) {
    if (this.pos !== this.html.length - 1) {
      const n = this.html.charCodeAt(this.pos + 1);
      if (ay(n))
        return this.pos++, this._addGap(), sy(t, n);
    } else if (!this.lastChunkWritten)
      return this.endOfChunkHit = !0, R.EOF;
    return this._err(ye.surrogateInInputStream), t;
  }
  willDropParsedChunk() {
    return this.pos > this.bufferWaterline;
  }
  dropParsedChunk() {
    this.willDropParsedChunk() && (this.html = this.html.substring(this.pos), this.lineStartPos -= this.pos, this.droppedBufferSize += this.pos, this.pos = 0, this.lastGapPos = -2, this.gapStack.length = 0);
  }
  write(t, n) {
    this.html.length > 0 ? this.html += t : this.html = t, this.endOfChunkHit = !1, this.lastChunkWritten = n;
  }
  insertHtmlAtCurrentPos(t) {
    this.html = this.html.substring(0, this.pos + 1) + t + this.html.substring(this.pos + 1), this.endOfChunkHit = !1;
  }
  startsWith(t, n) {
    if (this.pos + t.length > this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, !1;
    if (n)
      return this.html.startsWith(t, this.pos);
    for (let r = 0; r < t.length; r++)
      if ((this.html.charCodeAt(this.pos + r) | 32) !== t.charCodeAt(r))
        return !1;
    return !0;
  }
  peek(t) {
    const n = this.pos + t;
    if (n >= this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, R.EOF;
    const r = this.html.charCodeAt(n);
    return r === R.CARRIAGE_RETURN ? R.LINE_FEED : r;
  }
  advance() {
    if (this.pos++, this.isEol && (this.isEol = !1, this.line++, this.lineStartPos = this.pos), this.pos >= this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, R.EOF;
    let t = this.html.charCodeAt(this.pos);
    return t === R.CARRIAGE_RETURN ? (this.isEol = !0, this.skipNextNewLine = !0, R.LINE_FEED) : t === R.LINE_FEED && (this.isEol = !0, this.skipNextNewLine) ? (this.line--, this.skipNextNewLine = !1, this._addGap(), this.advance()) : (this.skipNextNewLine = !1, o2(t) && (t = this._processSurrogate(t)), this.handler.onParseError === null || t > 31 && t < 127 || t === R.LINE_FEED || t === R.CARRIAGE_RETURN || t > 159 && t < 64976 || this._checkForProblematicCharacters(t), t);
  }
  _checkForProblematicCharacters(t) {
    u2(t) ? this._err(ye.controlCharacterInInputStream) : l2(t) && this._err(ye.noncharacterInInputStream);
  }
  retreat(t) {
    for (this.pos -= t; this.pos < this.lastGapPos; )
      this.lastGapPos = this.gapStack.pop(), this.pos--;
    this.isEol = !1;
  }
}
var St;
(function(e) {
  e[e.CHARACTER = 0] = "CHARACTER", e[e.NULL_CHARACTER = 1] = "NULL_CHARACTER", e[e.WHITESPACE_CHARACTER = 2] = "WHITESPACE_CHARACTER", e[e.START_TAG = 3] = "START_TAG", e[e.END_TAG = 4] = "END_TAG", e[e.COMMENT = 5] = "COMMENT", e[e.DOCTYPE = 6] = "DOCTYPE", e[e.EOF = 7] = "EOF", e[e.HIBERNATION = 8] = "HIBERNATION";
})(St || (St = {}));
function c2(e, t) {
  for (let n = e.attrs.length - 1; n >= 0; n--)
    if (e.attrs[n].name === t)
      return e.attrs[n].value;
  return null;
}
const ly = /* @__PURE__ */ new Uint16Array(
  // prettier-ignore
  /* @__PURE__ */ 'áµ<Ã•Ä±ÊŠÒÕ»×ÙµÛŞ¢ß–à à©Šàª‘à¶¡à¹­à¼‰à¼¦áƒŠáˆ¨á‹¡á•á’á“ƒá“Ÿá”¥\0\0\0\0\0\0á•«á›á¦á°’á·á½¾â â†°âŠâ€â»â‘‚â ¤â¤’â´ˆâ¹ˆâ¿ã€–ãŠºã˜¹ã¬ã£¾ã¨¨ã©±ã« ã¬®à €EMabcfglmnoprstu\\bfmsÂ„Â‹ÂÂ•Â˜Â¦Â³Â¹ÃˆÃligè€»Ã†äƒ†Pè€»&ä€¦cuteè€»Ãäƒreve;ä„‚Ä€iyx}rcè€»Ã‚äƒ‚;är;ì€€ğ”„raveè€»Ã€äƒ€pha;ä‘acr;ä„€d;æ©“Ä€gpÂÂ¡on;ä„„f;ì€€ğ”¸plyFunction;æ¡ingè€»Ã…äƒ…Ä€csÂ¾Ãƒr;ì€€ğ’œign;æ‰”ildeè€»Ãƒäƒƒmlè€»Ã„äƒ„Ğ€aceforsuÃ¥Ã»Ã¾Ä—ÄœÄ¢Ä§ÄªÄ€crÃªÃ²kslash;æˆ–Å¶Ã¶Ã¸;æ«§ed;æŒ†y;ä‘Æ€crtÄ…Ä‹Ä”ause;æˆµnoullis;æ„¬a;ä’r;ì€€ğ”…pf;ì€€ğ”¹eve;ä‹˜cÃ²Ä“mpeq;æ‰Ü€HOacdefhilorsuÅÅ‘Å–Æ€ÆÆ¢ÆµÆ·ÆºÇœÈ•É³É¸É¾cy;ä§PYè€»Â©ä‚©Æ€cpyÅÅ¢Åºute;ä„†Ä€;iÅ§Å¨æ‹’talDifferentialD;æ……leys;æ„­È€aeioÆ‰ÆÆ”Æ˜ron;ä„Œdilè€»Ã‡äƒ‡rc;ä„ˆnint;æˆ°ot;ä„ŠÄ€dnÆ§Æ­illa;ä‚¸terDot;ä‚·Ã²Å¿i;ä§rcleÈ€DMPTÇ‡Ç‹Ç‘Ç–ot;æŠ™inus;æŠ–lus;æŠ•imes;æŠ—oÄ€csÇ¢Ç¸kwiseContourIntegral;æˆ²eCurlyÄ€DQÈƒÈoubleQuote;æ€uote;æ€™È€lnpuÈÈ¨É‡É•onÄ€;eÈ¥È¦æˆ·;æ©´Æ€gitÈ¯È¶Èºruent;æ‰¡nt;æˆ¯ourIntegral;æˆ®Ä€frÉŒÉ;æ„‚oduct;æˆnterClockwiseContourIntegral;æˆ³oss;æ¨¯cr;ì€€ğ’pÄ€;CÊ„Ê…æ‹“ap;æ‰Ö€DJSZacefiosÊ Ê¬Ê°Ê´Ê¸Ë‹Ë—Ë¡Ë¦Ì³ÒÄ€;oÅ¹Ê¥trahd;æ¤‘cy;ä‚cy;ä…cy;äÆ€grsÊ¿Ë„Ë‡ger;æ€¡r;æ†¡hv;æ«¤Ä€ayËË•ron;ä„;ä”lÄ€;tËËæˆ‡a;ä”r;ì€€ğ”‡Ä€afË«Ì§Ä€cmË°Ì¢riticalÈ€ADGTÌ€Ì†Ì–Ìœcute;ä‚´oÅ´Ì‹Ì;ä‹™bleAcute;ä‹rave;ä ilde;ä‹œond;æ‹„ferentialD;æ…†Ñ°Ì½\0\0\0Í‚Í”\0Ğ…f;ì€€ğ”»Æ€;DEÍˆÍ‰Íä‚¨ot;æƒœqual;æ‰bleÌ€CDLRUVÍ£Í²Î‚ÏÏ¢Ï¸ontourIntegraÃ¬È¹oÉ´Í¹\0\0Í»Â»Í‰nArrow;æ‡“Ä€eoÎ‡Î¤ftÆ€ARTÎÎ–Î¡rrow;æ‡ightArrow;æ‡”eÃ¥ËŠngÄ€LRÎ«Ï„eftÄ€ARÎ³Î¹rrow;æŸ¸ightArrow;æŸºightArrow;æŸ¹ightÄ€ATÏ˜Ïrrow;æ‡’ee;æŠ¨pÉÏ©\0\0Ï¯rrow;æ‡‘ownArrow;æ‡•erticalBar;æˆ¥nÌ€ABLRTaĞ’ĞªĞ°ÑÑ¿Í¼rrowÆ€;BUĞĞĞ¢æ†“ar;æ¤“pArrow;æ‡µreve;äŒ‘eftË’Ğº\0Ñ†\0ÑightVector;æ¥eeVector;æ¥ectorÄ€;BÑ™Ñšæ†½ar;æ¥–ightÇ”Ñ§\0Ñ±eeVector;æ¥ŸectorÄ€;BÑºÑ»æ‡ar;æ¥—eeÄ€;AÒ†Ò‡æŠ¤rrow;æ†§Ä€ctÒ’Ò—r;ì€€ğ’Ÿrok;ä„à €NTacdfglmopqstuxÒ½Ó€Ó„Ó‹ÓÓ¢Ó§Ó®ÓµÔ¡Ô¯Ô¶Õ’ÕÕ Õ¥G;ä…ŠHè€»Ãäƒcuteè€»Ã‰äƒ‰Æ€aiyÓ’Ó—Óœron;ä„šrcè€»ÃŠäƒŠ;ä­ot;ä„–r;ì€€ğ”ˆraveè€»Ãˆäƒˆement;æˆˆÄ€apÓºÓ¾cr;ä„’tyÉ“Ô†\0\0Ô’mallSquare;æ—»erySmallSquare;æ–«Ä€gpÔ¦Ôªon;ä„˜f;ì€€ğ”¼silon;ä•uÄ€aiÔ¼Õ‰lÄ€;TÕ‚Õƒæ©µilde;æ‰‚librium;æ‡ŒÄ€ciÕ—Õšr;æ„°m;æ©³a;ä—mlè€»Ã‹äƒ‹Ä€ipÕªÕ¯sts;æˆƒonentialE;æ…‡Ê€cfiosÖ…ÖˆÖÖ²×Œy;ä¤r;ì€€ğ”‰lledÉ“Ö—\0\0Ö£mallSquare;æ—¼erySmallSquare;æ–ªÍ°Öº\0Ö¿\0\0×„f;ì€€ğ”½All;æˆ€riertrf;æ„±cÃ²×‹Ø€JTabcdfgorst×¨×¬×¯×ºØ€Ø’Ø–Ø›ØØ£Ù¬Ù²cy;äƒè€»>ä€¾mmaÄ€;d×·×¸ä“;äœreve;ä„Æ€eiyØ‡ØŒØdil;ä„¢rc;ä„œ;ä“ot;ä„ r;ì€€ğ”Š;æ‹™pf;ì€€ğ”¾eaterÌ€EFGLSTØµÙ„ÙÙ–Ù›Ù¦qualÄ€;LØ¾Ø¿æ‰¥ess;æ‹›ullEqual;æ‰§reater;æª¢ess;æ‰·lantEqual;æ©¾ilde;æ‰³cr;ì€€ğ’¢;æ‰«Ğ€AacfiosuÚ…Ú‹Ú–Ú›ÚÚªÚ¾ÛŠRDcy;äªÄ€ctÚÚ”ek;ä‹‡;äirc;ä„¤r;æ„ŒlbertSpace;æ„‹Ç°Ú¯\0Ú²f;æ„izontalLine;æ”€Ä€ctÛƒÛ…Ã²Ú©rok;ä„¦mpÅ„ÛÛ˜ownHumÃ°Ä¯qual;æ‰Ü€EJOacdfgmnostuÛºÛ¾ÜƒÜ‡ÜÜšÜÜ¡Ü¨İ„İ¸Ş‹ŞŞ•cy;ä•lig;ä„²cy;äcuteè€»ÃäƒÄ€iyÜ“Ü˜rcè€»Ãäƒ;ä˜ot;ä„°r;æ„‘raveè€»ÃŒäƒŒÆ€;apÜ Ü¯Ü¿Ä€cgÜ´Ü·r;ä„ªinaryI;æ…ˆlieÃ³ÏÇ´İ‰\0İ¢Ä€;eİİæˆ¬Ä€grİ“İ˜ral;æˆ«section;æ‹‚isibleÄ€CTİ¬İ²omma;æ£imes;æ¢Æ€gptİ¿ŞƒŞˆon;ä„®f;ì€€ğ•€a;ä™cr;æ„ilde;ä„¨Ç«Şš\0Şcy;ä†lè€»ÃäƒÊ€cfosuŞ¬Ş·Ş¼ß‚ßÄ€iyŞ±Şµrc;ä„´;ä™r;ì€€ğ”pf;ì€€ğ•Ç£ß‡\0ßŒr;ì€€ğ’¥rcy;äˆkcy;ä„Î€HJacfosß¤ß¨ß¬ß±ß½à ‚à ˆcy;ä¥cy;äŒppa;äšÄ€eyß¶ß»dil;ä„¶;äšr;ì€€ğ”pf;ì€€ğ•‚cr;ì€€ğ’¦Ö€JTaceflmostà ¥à ©à ¬à¡à¡£à¦³à¦¸à§‡à§à¨·à©‡cy;ä‰è€»<ä€¼Ê€cmnprà ·à ¼à¡à¡„à¡ute;ä„¹bda;ä›g;æŸªlacetrf;æ„’r;æ†Æ€aeyà¡—à¡œà¡¡ron;ä„½dil;ä„»;ä›Ä€fsà¡¨à¥°tÔ€ACDFRTUVarà¡¾à¢©à¢±à£ à£¦à£¼à¤¯à¥›Îà¥ªÄ€nrà¢ƒà¢gleBracket;æŸ¨rowÆ€;BRà¢™à¢šà¢æ†ar;æ‡¤ightArrow;æ‡†eiling;æŒˆoÇµà¢·\0à£ƒbleBracket;æŸ¦nÇ”à£ˆ\0à£’eeVector;æ¥¡ectorÄ€;Bà£›à£œæ‡ƒar;æ¥™loor;æŒŠightÄ€AVà£¯à£µrrow;æ†”ector;æ¥Ä€erà¤à¤—eÆ€;AVà¤‰à¤Šà¤æŠ£rrow;æ†¤ector;æ¥šiangleÆ€;BEà¤¤à¤¥à¤©æŠ²ar;æ§qual;æŠ´pÆ€DTVà¤·à¥‚à¥ŒownVector;æ¥‘eeVector;æ¥ ectorÄ€;Bà¥–à¥—æ†¿ar;æ¥˜ectorÄ€;Bà¥¥à¥¦æ†¼ar;æ¥’ightÃ¡ÎœsÌ€EFGLSTà¥¾à¦‹à¦•à¦à¦¢à¦­qualGreater;æ‹šullEqual;æ‰¦reater;æ‰¶ess;æª¡lantEqual;æ©½ilde;æ‰²r;ì€€ğ”Ä€;eà¦½à¦¾æ‹˜ftarrow;æ‡šidot;ä„¿Æ€npwà§”à¨–à¨›gÈ€LRlrà§à§·à¨‚à¨eftÄ€ARà§¦à§¬rrow;æŸµightArrow;æŸ·ightArrow;æŸ¶eftÄ€arÎ³à¨ŠightÃ¡Î¿ightÃ¡ÏŠf;ì€€ğ•ƒerÄ€LRà¨¢à¨¬eftArrow;æ†™ightArrow;æ†˜Æ€chtà¨¾à©€à©‚Ã²à¡Œ;æ†°rok;ä…;æ‰ªĞ€acefiosuà©šà©à© à©·à©¼àª…àª‹àªp;æ¤…y;äœÄ€dlà©¥à©¯iumSpace;æŸlintrf;æ„³r;ì€€ğ”nusPlus;æˆ“pf;ì€€ğ•„cÃ²à©¶;äœÒ€Jacefostuàª£àª§àª­à«€à¬”à¬™à¶‘à¶—à¶cy;äŠcute;ä…ƒÆ€aeyàª´àª¹àª¾ron;ä…‡dil;ä……;äÆ€gswà«‡à«°à¬ativeÆ€MTVà«“à«Ÿà«¨ediumSpace;æ€‹hiÄ€cnà«¦à«˜Ã«à«™eryThiÃ®à«™tedÄ€GLà«¸à¬†reaterGreateÃ²Ù³essLesÃ³à©ˆLine;ä€Šr;ì€€ğ”‘È€Bnptà¬¢à¬¨à¬·à¬ºreak;æ BreakingSpace;ä‚ f;æ„•Ú€;CDEGHLNPRSTVà­•à­–à­ªà­¼à®¡à¯«à°„à±à²„à²¦à³˜àµ¡à¶…æ«¬Ä€ouà­›à­¤ngruent;æ‰¢pCap;æ‰­oubleVerticalBar;æˆ¦Æ€lqxà®ƒà®Šà®›ement;æˆ‰ualÄ€;Tà®’à®“æ‰ ilde;ì€€â‰‚Ì¸ists;æˆ„reaterÎ€;EFGLSTà®¶à®·à®½à¯‰à¯“à¯˜à¯¥æ‰¯qual;æ‰±ullEqual;ì€€â‰§Ì¸reater;ì€€â‰«Ì¸ess;æ‰¹lantEqual;ì€€â©¾Ì¸ilde;æ‰µumpÅ„à¯²à¯½ownHump;ì€€â‰Ì¸qual;ì€€â‰Ì¸eÄ€fsà°Šà°§tTriangleÆ€;BEà°šà°›à°¡æ‹ªar;ì€€â§Ì¸qual;æ‹¬sÌ€;EGLSTà°µà°¶à°¼à±„à±‹à±˜æ‰®qual;æ‰°reater;æ‰¸ess;ì€€â‰ªÌ¸lantEqual;ì€€â©½Ì¸ilde;æ‰´estedÄ€GLà±¨à±¹reaterGreater;ì€€âª¢Ì¸essLess;ì€€âª¡Ì¸recedesÆ€;ESà²’à²“à²›æŠ€qual;ì€€âª¯Ì¸lantEqual;æ‹ Ä€eià²«à²¹verseElement;æˆŒghtTriangleÆ€;BEà³‹à³Œà³’æ‹«ar;ì€€â§Ì¸qual;æ‹­Ä€quà³à´ŒuareSuÄ€bpà³¨à³¹setÄ€;Eà³°à³³ì€€âŠÌ¸qual;æ‹¢ersetÄ€;Eà´ƒà´†ì€€âŠÌ¸qual;æ‹£Æ€bcpà´“à´¤àµsetÄ€;Eà´›à´ì€€âŠ‚âƒ’qual;æŠˆceedsÈ€;ESTà´²à´³à´»àµ†æŠqual;ì€€âª°Ì¸lantEqual;æ‹¡ilde;ì€€â‰¿Ì¸ersetÄ€;Eàµ˜àµ›ì€€âŠƒâƒ’qual;æŠ‰ildeÈ€;EFTàµ®àµ¯àµµàµ¿æ‰qual;æ‰„ullEqual;æ‰‡ilde;æ‰‰erticalBar;æˆ¤cr;ì€€ğ’©ildeè€»Ã‘äƒ‘;äÜ€Eacdfgmoprstuvà¶½à·‚à·‰à·•à·›à· à·§à·¼à¸‚à¸ à¸¢à¸²à¸¿à¹„lig;ä…’cuteè€»Ã“äƒ“Ä€iyà·à·“rcè€»Ã”äƒ”;äblac;ä…r;ì€€ğ”’raveè€»Ã’äƒ’Æ€aeià·®à·²à·¶cr;ä…Œga;ä©cron;äŸpf;ì€€ğ•†enCurlyÄ€DQà¸à¸šoubleQuote;æ€œuote;æ€˜;æ©”Ä€clà¸§à¸¬r;ì€€ğ’ªashè€»Ã˜äƒ˜iÅ¬à¸·à¸¼deè€»Ã•äƒ•es;æ¨·mlè€»Ã–äƒ–erÄ€BPà¹‹à¹ Ä€arà¹à¹“r;æ€¾acÄ€ekà¹šà¹œ;æet;æ´arenthesis;æœÒ€acfhilorsà¹¿àº‡àºŠàºàº’àº”àºàº°à»¼rtialD;æˆ‚y;äŸr;ì€€ğ”“i;ä¦;ä usMinus;ä‚±Ä€ipàº¢àº­ncareplanÃ¥Úf;æ„™È€;eioàº¹àººà» à»¤æª»cedesÈ€;ESTà»ˆà»‰à»à»šæ‰ºqual;æª¯lantEqual;æ‰¼ilde;æ‰¾me;æ€³Ä€dpà»©à»®uct;æˆortionÄ€;aÈ¥à»¹l;æˆÄ€cià¼à¼†r;ì€€ğ’«;ä¨È€Ufosà¼‘à¼–à¼›à¼ŸOTè€»"ä€¢r;ì€€ğ””pf;æ„šcr;ì€€ğ’¬Ø€BEacefhiorsuà¼¾à½ƒà½‡à½ à½³à¾§à¾ªà¾­á‚–á‚©á‚´á‚¾arr;æ¤Gè€»Â®ä‚®Æ€cnrà½à½“à½–ute;ä…”g;æŸ«rÄ€;tà½œà½æ† l;æ¤–Æ€aeyà½§à½¬à½±ron;ä…˜dil;ä…–;ä Ä€;và½¸à½¹æ„œerseÄ€EUà¾‚à¾™Ä€lqà¾‡à¾ement;æˆ‹uilibrium;æ‡‹pEquilibrium;æ¥¯rÂ»à½¹o;ä¡ghtĞ€ACDFTUVaà¿à¿«à¿³á€¢á€¨á›á‚‡Ï˜Ä€nrà¿†à¿’gleBracket;æŸ©rowÆ€;BLà¿œà¿à¿¡æ†’ar;æ‡¥eftArrow;æ‡„eiling;æŒ‰oÇµà¿¹\0á€…bleBracket;æŸ§nÇ”á€Š\0á€”eeVector;æ¥ectorÄ€;Bá€á€æ‡‚ar;æ¥•loor;æŒ‹Ä€erá€­áƒeÆ€;AVá€µá€¶á€¼æŠ¢rrow;æ†¦ector;æ¥›iangleÆ€;BEáá‘á•æŠ³ar;æ§qual;æŠµpÆ€DTVá£á®á¸ownVector;æ¥eeVector;æ¥œectorÄ€;Bá‚‚á‚ƒæ†¾ar;æ¥”ectorÄ€;Bá‚‘á‚’æ‡€ar;æ¥“Ä€puá‚›á‚f;æ„ndImplies;æ¥°ightarrow;æ‡›Ä€chá‚¹á‚¼r;æ„›;æ†±leDelayed;æ§´Ú€HOacfhimoqstuáƒ¤áƒ±áƒ·áƒ½á„™á„á…‘á…–á…¡á…§á†µá†»á†¿Ä€Ccáƒ©áƒ®Hcy;ä©y;ä¨FTcy;ä¬cute;ä…šÊ€;aeiyá„ˆá„‰á„á„“á„—æª¼ron;ä… dil;ä…rc;ä…œ;ä¡r;ì€€ğ”–ortÈ€DLRUá„ªá„´á„¾á…‰ownArrowÂ»ĞeftArrowÂ»à¢šightArrowÂ»à¿pArrow;æ†‘gma;ä£allCircle;æˆ˜pf;ì€€ğ•ŠÉ²á…­\0\0á…°t;æˆšareÈ€;ISUá…»á…¼á†‰á†¯æ–¡ntersection;æŠ“uÄ€bpá†á†setÄ€;Eá†—á†˜æŠqual;æŠ‘ersetÄ€;Eá†¨á†©æŠqual;æŠ’nion;æŠ”cr;ì€€ğ’®ar;æ‹†È€bcmpá‡ˆá‡›áˆ‰áˆ‹Ä€;sá‡á‡æ‹etÄ€;Eá‡á‡•qual;æŠ†Ä€chá‡ áˆ…eedsÈ€;ESTá‡­á‡®á‡´á‡¿æ‰»qual;æª°lantEqual;æ‰½ilde;æ‰¿ThÃ¡à¾Œ;æˆ‘Æ€;esáˆ’áˆ“áˆ£æ‹‘rsetÄ€;EáˆœáˆæŠƒqual;æŠ‡etÂ»áˆ“Ö€HRSacfhiorsáˆ¾á‰„á‰‰á‰•á‰á‰±á‰¶áŠŸá‹‚á‹ˆá‹‘ORNè€»ÃäƒADE;æ„¢Ä€Hcá‰á‰’cy;ä‹y;ä¦Ä€buá‰šá‰œ;ä€‰;ä¤Æ€aeyá‰¥á‰ªá‰¯ron;ä…¤dil;ä…¢;ä¢r;ì€€ğ”—Ä€eiá‰»áŠ‰Ç²áŠ€\0áŠ‡efore;æˆ´a;ä˜Ä€cnáŠáŠ˜kSpace;ì€€âŸâ€ŠSpace;æ€‰ldeÈ€;EFTáŠ«áŠ¬áŠ²áŠ¼æˆ¼qual;æ‰ƒullEqual;æ‰…ilde;æ‰ˆpf;ì€€ğ•‹ipleDot;æƒ›Ä€ctá‹–á‹›r;ì€€ğ’¯rok;ä…¦à«¡á‹·áŒáŒšáŒ¦\0áŒ¬áŒ±\0\0\0\0\0áŒ¸áŒ½á·á…\0á¿á„áŠáÄ€crá‹»áŒuteè€»ÃšäƒšrÄ€;oáŒ‡áŒˆæ†Ÿcir;æ¥‰rÇ£áŒ“\0áŒ–y;äve;ä…¬Ä€iyáŒáŒ£rcè€»Ã›äƒ›;ä£blac;ä…°r;ì€€ğ”˜raveè€»Ã™äƒ™acr;ä…ªÄ€diáá©erÄ€BPáˆáÄ€aráár;äŸacÄ€eká—á™;æŸet;æµarenthesis;æonÄ€;Pá°á±æ‹ƒlus;æŠÄ€gpá»á¿on;ä…²f;ì€€ğ•ŒĞ€ADETadpsá•á®á¸á„Ï¨á’á—á³rrowÆ€;BDá…á á¤ar;æ¤’ownArrow;æ‡…ownArrow;æ†•quilibrium;æ¥®eeÄ€;Aá‹áŒæŠ¥rrow;æ†¥ownÃ¡Ï³erÄ€LRáá¨eftArrow;æ†–ightArrow;æ†—iÄ€;lá¹áºä’on;ä¥ing;ä…®cr;ì€€ğ’°ilde;ä…¨mlè€»ÃœäƒœÒ€Dbcdefosvá§á¬á°á³á¾á’…á’Šá’á’–ash;æŠ«ar;æ««y;ä’ashÄ€;lá»á¼æŠ©;æ«¦Ä€erá‘ƒá‘…;æ‹Æ€btyá‘Œá‘á‘ºar;æ€–Ä€;iá‘á‘•calÈ€BLSTá‘¡á‘¥á‘ªá‘´ar;æˆ£ine;ä¼eparator;æ˜ilde;æ‰€ThinSpace;æ€Šr;ì€€ğ”™pf;ì€€ğ•cr;ì€€ğ’±dash;æŠªÊ€cefosá’§á’¬á’±á’¶á’¼irc;ä…´dge;æ‹€r;ì€€ğ”špf;ì€€ğ•cr;ì€€ğ’²È€fiosá“‹á“á“’á“˜r;ì€€ğ”›;äpf;ì€€ğ•cr;ì€€ğ’³Ò€AIUacfosuá“±á“µá“¹á“½á”„á”á””á”šá” cy;ä¯cy;ä‡cy;ä®cuteè€»ÃäƒÄ€iyá”‰á”rc;ä…¶;ä«r;ì€€ğ”œpf;ì€€ğ•cr;ì€€ğ’´ml;ä…¸Ğ€Hacdefosá”µá”¹á”¿á•‹á•á•á• á•¤cy;ä–cute;ä…¹Ä€ayá•„á•‰ron;ä…½;ä—ot;ä…»Ç²á•”\0á•›oWidtÃ¨à«™a;ä–r;æ„¨pf;æ„¤cr;ì€€ğ’µà¯¡á–ƒá–Šá–\0á–°á–¶á–¿\0\0\0\0á—†á—›á—«á™Ÿá™­\0áš•áš›áš²áš¹\0áš¾cuteè€»Ã¡äƒ¡reve;ä„ƒÌ€;Ediuyá–œá–á–¡á–£á–¨á–­æˆ¾;ì€€âˆ¾Ì³;æˆ¿rcè€»Ã¢äƒ¢teè‚»Â´Ì†;ä°ligè€»Ã¦äƒ¦Ä€;rÂ²á–º;ì€€ğ”raveè€»Ã äƒ Ä€epá—Šá—–Ä€fpá—á—”sym;æ„µÃ¨á—“ha;ä±Ä€apá—ŸcÄ€clá—¤á—§r;ä„g;æ¨¿É¤á—°\0\0á˜ŠÊ€;adsvá—ºá—»á—¿á˜á˜‡æˆ§nd;æ©•;æ©œlope;æ©˜;æ©šÎ€;elmrszá˜˜á˜™á˜›á˜á˜¿á™á™™æˆ ;æ¦¤eÂ»á˜™sdÄ€;aá˜¥á˜¦æˆ¡Ñ¡á˜°á˜²á˜´á˜¶á˜¸á˜ºá˜¼á˜¾;æ¦¨;æ¦©;æ¦ª;æ¦«;æ¦¬;æ¦­;æ¦®;æ¦¯tÄ€;vá™…á™†æˆŸbÄ€;dá™Œá™æŠ¾;æ¦Ä€ptá™”á™—h;æˆ¢Â»Â¹arr;æ¼Ä€gpá™£á™§on;ä„…f;ì€€ğ•’Î€;Eaeiopá‹á™»á™½áš‚áš„áš‡ášŠ;æ©°cir;æ©¯;æ‰Šd;æ‰‹s;ä€§roxÄ€;eá‹áš’Ã±ášƒingè€»Ã¥äƒ¥Æ€ctyáš¡áš¦áš¨r;ì€€ğ’¶;ä€ªmpÄ€;eá‹áš¯Ã±Êˆildeè€»Ã£äƒ£mlè€»Ã¤äƒ¤Ä€ciá›‚á›ˆoninÃ´É²nt;æ¨‘à €Nabcdefiklnoprsuá›­á›±áœ°áœ¼áƒáˆá¸á½áŸ áŸ¦á ¹á¡áœá¤½á¥ˆá¥°ot;æ«­Ä€crá›¶áœkÈ€cepsáœ€áœ…áœáœ“ong;æ‰Œpsilon;ä¶rime;æ€µimÄ€;eáœšáœ›æˆ½q;æ‹Å¶áœ¢áœ¦ee;æŠ½edÄ€;gáœ¬áœ­æŒ…eÂ»áœ­rkÄ€;táœáœ·brk;æ¶Ä€oyáœá;ä±quo;æ€Ê€cmprtá“á›á¡á¤á¨ausÄ€;eÄŠÄ‰ptyv;æ¦°sÃ©áœŒnoÃµÄ“Æ€ahwá¯á±á³;ä²;æ„¶een;æ‰¬r;ì€€ğ”ŸgÎ€costuvwááá³áŸáŸ•áŸ›áŸÆ€aiuá”á–ášÃ°İ rc;æ—¯pÂ»á±Æ€dptá¤á¨á­ot;æ¨€lus;æ¨imes;æ¨‚É±á¹\0\0á¾cup;æ¨†ar;æ˜…riangleÄ€duáŸáŸ’own;æ–½p;æ–³plus;æ¨„eÃ¥á‘„Ã¥á’­arow;æ¤Æ€akoáŸ­á ¦á µÄ€cnáŸ²á £kÆ€lstáŸºÖ«á ‚ozenge;æ§«riangleÈ€;dlrá ’á “á ˜á æ–´own;æ–¾eft;æ—‚ight;æ–¸k;æ£Æ±á «\0á ³Æ²á ¯\0á ±;æ–’;æ–‘4;æ–“ck;æ–ˆÄ€eoá ¾á¡Ä€;qá¡ƒá¡†ì€€=âƒ¥uiv;ì€€â‰¡âƒ¥t;æŒÈ€ptwxá¡™á¡á¡§á¡¬f;ì€€ğ•“Ä€;tá‹á¡£omÂ»áŒtie;æ‹ˆØ€DHUVbdhmptuvá¢…á¢–á¢ªá¢»á£—á£›á£¬á£¿á¤…á¤Šá¤á¤¡È€LRlrá¢á¢á¢’á¢”;æ•—;æ•”;æ•–;æ•“Ê€;DUduá¢¡á¢¢á¢¤á¢¦á¢¨æ•;æ•¦;æ•©;æ•¤;æ•§È€LRlrá¢³á¢µá¢·á¢¹;æ•;æ•š;æ•œ;æ•™Î€;HLRhlrá£Šá£‹á£á£á£‘á£“á£•æ•‘;æ•¬;æ•£;æ• ;æ•«;æ•¢;æ•Ÿox;æ§‰È€LRlrá£¤á£¦á£¨á£ª;æ••;æ•’;æ”;æ”ŒÊ€;DUduÚ½á£·á£¹á£»á£½;æ•¥;æ•¨;æ”¬;æ”´inus;æŠŸlus;æŠimes;æŠ È€LRlrá¤™á¤›á¤á¤Ÿ;æ•›;æ•˜;æ”˜;æ””Î€;HLRhlrá¤°á¤±á¤³á¤µá¤·á¤¹á¤»æ”‚;æ•ª;æ•¡;æ•;æ”¼;æ”¤;æ”œÄ€evÄ£á¥‚barè€»Â¦ä‚¦È€ceioá¥‘á¥–á¥šá¥ r;ì€€ğ’·mi;æmÄ€;eáœšáœœlÆ€;bhá¥¨á¥©á¥«äœ;æ§…sub;æŸˆÅ¬á¥´á¥¾lÄ€;eá¥¹á¥ºæ€¢tÂ»á¥ºpÆ€;EeÄ¯á¦…á¦‡;æª®Ä€;qÛœÛ›à³¡á¦§\0á§¨á¨‘á¨•á¨²\0á¨·á©\0\0áª´\0\0á«\0\0á¬¡á¬®á­á­’\0á¯½\0á°ŒÆ€cprá¦­á¦²á§ute;ä„‡Ì€;abcdsá¦¿á§€á§„á§Šá§•á§™æˆ©nd;æ©„rcup;æ©‰Ä€auá§á§’p;æ©‹p;æ©‡ot;æ©€;ì€€âˆ©ï¸€Ä€eoá§¢á§¥t;æÃ®Ú“È€aeiuá§°á§»á¨á¨…Ç°á§µ\0á§¸s;æ©on;ä„dilè€»Ã§äƒ§rc;ä„‰psÄ€;sá¨Œá¨æ©Œm;æ©ot;ä„‹Æ€dmná¨›á¨ á¨¦ilè‚»Â¸Æ­ptyv;æ¦²tè„€Â¢;eá¨­á¨®ä‚¢rÃ¤Æ²r;ì€€ğ” Æ€ceiá¨½á©€á©y;ä‘‡ckÄ€;má©‡á©ˆæœ“arkÂ»á©ˆ;ä‡rÎ€;Ecefmsá©Ÿá© á©¢á©«áª¤áªªáª®æ—‹;æ§ƒÆ€;elá©©á©ªá©­ä‹†q;æ‰—eÉ¡á©´\0\0áªˆrrowÄ€lrá©¼áªeft;æ†ºight;æ†»Ê€RSacdáª’áª”áª–áªšáªŸÂ»à½‡;æ“ˆst;æŠ›irc;æŠšash;æŠnint;æ¨id;æ«¯cir;æ§‚ubsÄ€;uáª»áª¼æ™£itÂ»áª¼Ë¬á«‡á«”á«º\0á¬ŠonÄ€;eá«á«ä€ºÄ€;qÃ‡Ã†É­á«™\0\0á«¢aÄ€;tá«á«Ÿä€¬;ä€Æ€;flá«¨á«©á««æˆÃ®á… eÄ€mxá«±á«¶entÂ»á«©eÃ³ÉÇ§á«¾\0á¬‡Ä€;dáŠ»á¬‚ot;æ©­nÃ´É†Æ€fryá¬á¬”á¬—;ì€€ğ•”oÃ¤É”è„€Â©;sÅ•á¬r;æ„—Ä€aoá¬¥á¬©rr;æ†µss;æœ—Ä€cuá¬²á¬·r;ì€€ğ’¸Ä€bpá¬¼á­„Ä€;eá­á­‚æ«;æ«‘Ä€;eá­‰á­Šæ«;æ«’dot;æ‹¯Î€delprvwá­ á­¬á­·á®‚á®¬á¯”á¯¹arrÄ€lrá­¨á­ª;æ¤¸;æ¤µÉ°á­²\0\0á­µr;æ‹c;æ‹ŸarrÄ€;pá­¿á®€æ†¶;æ¤½Ì€;bcdosá®á®á®–á®¡á®¥á®¨æˆªrcap;æ©ˆÄ€auá®›á®p;æ©†p;æ©Šot;æŠr;æ©…;ì€€âˆªï¸€È€alrvá®µá®¿á¯á¯£rrÄ€;má®¼á®½æ†·;æ¤¼yÆ€evwá¯‡á¯”á¯˜qÉ°á¯\0\0á¯’reÃ£á­³uÃ£á­µee;æ‹edge;æ‹enè€»Â¤ä‚¤earrowÄ€lrá¯®á¯³eftÂ»á®€ightÂ»á®½eÃ¤á¯Ä€ciá°á°‡oninÃ´Ç·nt;æˆ±lcty;æŒ­à¦€AHabcdefhijlorstuwzá°¸á°»á°¿á±á±©á±µá²Šá²á²¬á²·á³»á³¿á´áµ»á¶‘á¶«á¶»á·†á·rÃ²Îar;æ¥¥È€glrsá±ˆá±á±’á±”ger;æ€ eth;æ„¸Ã²á„³hÄ€;vá±šá±›æ€Â»à¤ŠÅ«á±¡á±§arow;æ¤aÃ£Ì•Ä€ayá±®á±³ron;ä„;ä´Æ€;aoÌ²á±¼á²„Ä€grÊ¿á²r;æ‡Štseq;æ©·Æ€glmá²‘á²”á²˜è€»Â°ä‚°ta;ä´ptyv;æ¦±Ä€irá²£á²¨sht;æ¥¿;ì€€ğ”¡arÄ€lrá²³á²µÂ»à£œÂ»á€Ê€aegsvá³‚Í¸á³–á³œá³ mÆ€;osÌ¦á³Šá³”ndÄ€;sÌ¦á³‘uit;æ™¦amma;äin;æ‹²Æ€;ioá³§á³¨á³¸äƒ·deè„€Ã·;oá³§á³°ntimes;æ‹‡nÃ¸á³·cy;ä‘’cÉ¯á´†\0\0á´Šrn;æŒop;æŒÊ€lptuwá´˜á´á´¢áµ‰áµ•lar;ä€¤f;ì€€ğ••Ê€;empsÌ‹á´­á´·á´½áµ‚qÄ€;dÍ’á´³ot;æ‰‘inus;æˆ¸lus;æˆ”quare;æŠ¡blebarwedgÃ¥ÃºnÆ€adhá„®áµáµ§ownarrowÃ³á²ƒarpoonÄ€lráµ²áµ¶efÃ´á²´ighÃ´á²¶Å¢áµ¿á¶…karoÃ·à½‚É¯á¶Š\0\0á¶rn;æŒŸop;æŒŒÆ€cotá¶˜á¶£á¶¦Ä€ryá¶á¶¡;ì€€ğ’¹;ä‘•l;æ§¶rok;ä„‘Ä€drá¶°á¶´ot;æ‹±iÄ€;fá¶ºá –æ–¿Ä€ahá·€á·ƒrÃ²Ğ©aÃ²à¾¦angle;æ¦¦Ä€ciá·’á·•y;ä‘Ÿgrarr;æŸ¿à¤€Dacdefglmnopqrstuxá¸á¸‰á¸™á¸¸Õ¸á¸¼á¹‰á¹¡á¹¾áº¥áº¯áº½á»¡á¼ªá¼·á½„á½á½šÄ€Doá¸†á´´oÃ´á²‰Ä€csá¸á¸”uteè€»Ã©äƒ©ter;æ©®È€aioyá¸¢á¸§á¸±á¸¶ron;ä„›rÄ€;cá¸­á¸®æ‰–è€»Ãªäƒªlon;æ‰•;ä‘ot;ä„—Ä€Drá¹á¹…ot;æ‰’;ì€€ğ”¢Æ€;rsá¹á¹‘á¹—æªšaveè€»Ã¨äƒ¨Ä€;dá¹œá¹æª–ot;æª˜È€;ilsá¹ªá¹«á¹²á¹´æª™nters;æ§;æ„“Ä€;dá¹¹á¹ºæª•ot;æª—Æ€apsáº…áº‰áº—cr;ä„“tyÆ€;sváº’áº“áº•æˆ…etÂ»áº“pÄ€1;áºáº¤Ä³áº¡áº£;æ€„;æ€…æ€ƒÄ€gsáºªáº¬;ä…‹p;æ€‚Ä€gpáº´áº¸on;ä„™f;ì€€ğ•–Æ€alsá»„á»á»’rÄ€;sá»Šá»‹æ‹•l;æ§£us;æ©±iÆ€;lvá»šá»›á»ŸäµonÂ»á»›;äµÈ€csuvá»ªá»³á¼‹á¼£Ä€ioá»¯á¸±rcÂ»á¸®É©á»¹\0\0á»»Ã­ÕˆantÄ€glá¼‚á¼†trÂ»á¹essÂ»á¹ºÆ€aeiá¼’á¼–á¼šls;ä€½st;æ‰ŸvÄ€;DÈµá¼ D;æ©¸parsl;æ§¥Ä€Daá¼¯á¼³ot;æ‰“rr;æ¥±Æ€cdiá¼¾á½á»¸r;æ„¯oÃ´Í’Ä€ahá½‰á½‹;ä·è€»Ã°äƒ°Ä€mrá½“á½—lè€»Ã«äƒ«o;æ‚¬Æ€cipá½¡á½¤á½§l;ä€¡sÃ´Õ®Ä€eoá½¬á½´ctatioÃ®Õ™nentialÃ¥Õ¹à§¡á¾’\0á¾\0á¾¡á¾§\0\0á¿†á¿Œ\0á¿“\0á¿¦á¿ªâ€€\0â€ˆâšllingdotseÃ±á¹„y;ä‘„male;æ™€Æ€ilrá¾­á¾³á¿lig;è€€ï¬ƒÉ©á¾¹\0\0á¾½g;è€€ï¬€ig;è€€ï¬„;ì€€ğ”£lig;è€€ï¬lig;ì€€fjÆ€altá¿™á¿œá¿¡t;æ™­ig;è€€ï¬‚ns;æ–±of;ä†’Ç°á¿®\0á¿³f;ì€€ğ•—Ä€akÖ¿á¿·Ä€;vá¿¼á¿½æ‹”;æ«™artint;æ¨Ä€aoâ€Œâ•Ä€csâ€‘â’Î±â€šâ€°â€¸â…âˆ\0âÎ²â€¢â€¥â€§â€ªâ€¬\0â€®è€»Â½ä‚½;æ…“è€»Â¼ä‚¼;æ…•;æ…™;æ…›Æ³â€´\0â€¶;æ…”;æ…–Ê´â€¾â\0\0âƒè€»Â¾ä‚¾;æ…—;æ…œ5;æ…˜Æ¶âŒ\0â;æ…š;æ…8;æ…l;æ„wn;æŒ¢cr;ì€€ğ’»à¢€Eabcdefgijlnorstvâ‚‚â‚‰â‚Ÿâ‚¥â‚°â‚´âƒ°âƒµâƒºâƒ¿â„ƒâ„’â„¸Ì—â„¾â…’â†Ä€;lÙâ‚‡;æªŒÆ€cmpâ‚â‚•â‚ute;ä‡µmaÄ€;dâ‚œá³šä³;æª†reve;ä„ŸÄ€iyâ‚ªâ‚®rc;ä„;ä³ot;ä„¡È€;lqsØ¾Ù‚â‚½âƒ‰Æ€;qsØ¾ÙŒâƒ„lanÃ´Ù¥È€;cdlÙ¥âƒ’âƒ•âƒ¥c;æª©otÄ€;oâƒœâƒæª€Ä€;lâƒ¢âƒ£æª‚;æª„Ä€;eâƒªâƒ­ì€€â‹›ï¸€s;æª”r;ì€€ğ”¤Ä€;gÙ³Ø›mel;æ„·cy;ä‘“È€;EajÙšâ„Œâ„â„;æª’;æª¥;æª¤È€Eaesâ„›â„â„©â„´;æ‰©pÄ€;pâ„£â„¤æªŠroxÂ»â„¤Ä€;qâ„®â„¯æªˆÄ€;qâ„®â„›im;æ‹§pf;ì€€ğ•˜Ä€ciâ…ƒâ…†r;æ„ŠmÆ€;elÙ«â…â…;æª;æªèŒ€>;cdlqr×®â… â…ªâ…®â…³â…¹Ä€ciâ…¥â…§;æª§r;æ©ºot;æ‹—Par;æ¦•uest;æ©¼Ê€adelsâ†„â…ªâ†Ù–â†›Ç°â†‰\0â†proÃ¸â‚r;æ¥¸qÄ€lqØ¿â†–lesÃ³â‚ˆiÃ­Ù«Ä€enâ†£â†­rtneqq;ì€€â‰©ï¸€Ã…â†ªÔ€Aabcefkosyâ‡„â‡‡â‡±â‡µâ‡ºâˆ˜âˆâˆ¯â‰¨â‰½rÃ²Î È€ilmrâ‡â‡”â‡—â‡›rsÃ°á’„fÂ»â€¤ilÃ´Ú©Ä€drâ‡ â‡¤cy;ä‘ŠÆ€;cwà£´â‡«â‡¯ir;æ¥ˆ;æ†­ar;æ„irc;ä„¥Æ€alrâˆâˆâˆ“rtsÄ€;uâˆ‰âˆŠæ™¥itÂ»âˆŠlip;æ€¦con;æŠ¹r;ì€€ğ”¥sÄ€ewâˆ£âˆ©arow;æ¤¥arow;æ¤¦Ê€amoprâˆºâˆ¾â‰ƒâ‰â‰£rr;æ‡¿tht;æˆ»kÄ€lrâ‰‰â‰“eftarrow;æ†©ightarrow;æ†ªf;ì€€ğ•™bar;æ€•Æ€cltâ‰¯â‰´â‰¸r;ì€€ğ’½asÃ¨â‡´rok;ä„§Ä€bpâŠ‚âŠ‡ull;æƒhenÂ»á±›à«¡âŠ£\0âŠª\0âŠ¸â‹…â‹\0â‹•â‹³\0\0â‹¸âŒ¢â§â¢â¿\0â†âªâ´cuteè€»Ã­äƒ­Æ€;iyİ±âŠ°âŠµrcè€»Ã®äƒ®;ä¸Ä€cxâŠ¼âŠ¿y;äµclè€»Â¡ä‚¡Ä€frÎŸâ‹‰;ì€€ğ”¦raveè€»Ã¬äƒ¬È€;inoÜ¾â‹â‹©â‹®Ä€inâ‹¢â‹¦nt;æ¨Œt;æˆ­fin;æ§œta;æ„©lig;ä„³Æ€aopâ‹¾âŒšâŒÆ€cgtâŒ…âŒˆâŒ—r;ä„«Æ€elpÜŸâŒâŒ“inÃ¥ŞarÃ´Ü h;ä„±f;æŠ·ed;ä†µÊ€;cfotÓ´âŒ¬âŒ±âŒ½âare;æ„…inÄ€;tâŒ¸âŒ¹æˆie;æ§doÃ´âŒ™Ê€;celpİ—âŒââ›â¡al;æŠºÄ€grâ•â™erÃ³á•£Ã£âarhk;æ¨—rod;æ¨¼È€cgptâ¯â²â¶â»y;ä‘‘on;ä„¯f;ì€€ğ•ša;ä¹uestè€»Â¿ä‚¿Ä€ciâŠâr;ì€€ğ’¾nÊ€;EdsvÓ´â›ââ¡Ó³;æ‹¹ot;æ‹µÄ€;vâ¦â§æ‹´;æ‹³Ä€;iİ·â®lde;ä„©Ç«â¸\0â¼cy;ä‘–lè€»Ã¯äƒ¯Ì€cfmosuâŒâ—âœâ¡â§âµÄ€iyâ‘â•rc;ä„µ;ä¹r;ì€€ğ”§ath;äˆ·pf;ì€€ğ•›Ç£â¬\0â±r;ì€€ğ’¿rcy;ä‘˜kcy;ä‘”Ğ€acfghjosâ‹â–â¢â§â­â±âµâ»ppaÄ€;vâ“â”äº;ä°Ä€eyâ›â dil;ä„·;äºr;ì€€ğ”¨reen;ä„¸cy;ä‘…cy;ä‘œpf;ì€€ğ•œcr;ì€€ğ“€à®€ABEHabcdefghjlmnoprstuvâ‘°â’â’†â’â’‘â”â”½â•šâ–€â™â™â™¥â™¹â™½âššâš²â›˜ââ¨â‹âŸ€â â ’Æ€artâ‘·â‘ºâ‘¼rÃ²à§†Ã²Î•ail;æ¤›arr;æ¤Ä€;gà¦”â’‹;æª‹ar;æ¥¢à¥£â’¥\0â’ª\0â’±\0\0\0\0\0â’µâ’º\0â“†â“ˆâ“\0â“¹ute;ä„ºmptyv;æ¦´raÃ®à¡Œbda;ä»gÆ€;dlà¢â“â“ƒ;æ¦‘Ã¥à¢;æª…uoè€»Â«ä‚«rĞ€;bfhlpstà¢™â“â“¦â“©â“«â“®â“±â“µÄ€;fà¢â“£s;æ¤Ÿs;æ¤Ã«â‰’p;æ†«l;æ¤¹im;æ¥³l;æ†¢Æ€;aeâ“¿â”€â”„æª«il;æ¤™Ä€;sâ”‰â”Šæª­;ì€€âª­ï¸€Æ€abrâ”•â”™â”rr;æ¤Œrk;æ²Ä€akâ”¢â”¬cÄ€ekâ”¨â”ª;ä»;ä›Ä€esâ”±â”³;æ¦‹lÄ€duâ”¹â”»;æ¦;æ¦È€aeuyâ•†â•‹â•–â•˜ron;ä„¾Ä€diâ•â•”il;ä„¼Ã¬à¢°Ã¢â”©;ä»È€cqrsâ•£â•¦â•­â•½a;æ¤¶uoÄ€;rà¸™á†Ä€duâ•²â•·har;æ¥§shar;æ¥‹h;æ†²Ê€;fgqsâ–‹â–Œà¦‰â—³â—¿æ‰¤tÊ€ahlrtâ–˜â–¤â–·â—‚â—¨rrowÄ€;tà¢™â–¡aÃ©â“¶arpoonÄ€duâ–¯â–´ownÂ»ÑšpÂ»à¥¦eftarrows;æ‡‡ightÆ€ahsâ—â—–â—rrowÄ€;sà£´à¢§arpoonÃ³à¾˜quigarroÃ·â‡°hreetimes;æ‹‹Æ€;qsâ–‹à¦“â—ºlanÃ´à¦¬Ê€;cdgsà¦¬â˜Šâ˜â˜â˜¨c;æª¨otÄ€;oâ˜”â˜•æ©¿Ä€;râ˜šâ˜›æª;æªƒÄ€;eâ˜¢â˜¥ì€€â‹šï¸€s;æª“Ê€adegsâ˜³â˜¹â˜½â™‰â™‹pproÃ¸â“†ot;æ‹–qÄ€gqâ™ƒâ™…Ã´à¦‰gtÃ²â’ŒÃ´à¦›iÃ­à¦²Æ€ilrâ™•à£¡â™šsht;æ¥¼;ì€€ğ”©Ä€;Eà¦œâ™£;æª‘Å¡â™©â™¶rÄ€duâ–²â™®Ä€;là¥¥â™³;æ¥ªlk;æ–„cy;ä‘™Ê€;achtà©ˆâšˆâš‹âš‘âš–rÃ²â—orneÃ²á´ˆard;æ¥«ri;æ—ºÄ€ioâšŸâš¤dot;ä…€ustÄ€;aâš¬âš­æ°cheÂ»âš­È€Eaesâš»âš½â›‰â›”;æ‰¨pÄ€;pâ›ƒâ›„æª‰roxÂ»â›„Ä€;qâ›â›æª‡Ä€;qâ›âš»im;æ‹¦Ğ€abnoptwzâ›©â›´â›·âœšâœ¯ââ‡âÄ€nrâ›®â›±g;æŸ¬r;æ‡½rÃ«à£gÆ€lmrâ›¿âœâœ”eftÄ€arà§¦âœ‡ightÃ¡à§²apsto;æŸ¼ightÃ¡à§½parrowÄ€lrâœ¥âœ©efÃ´â“­ight;æ†¬Æ€aflâœ¶âœ¹âœ½r;æ¦…;ì€€ğ•us;æ¨­imes;æ¨´Å¡â‹âst;æˆ—Ã¡áÆ€;efâ—â˜á €æ—ŠngeÂ»â˜arÄ€;lâ¤â¥ä€¨t;æ¦“Ê€achmtâ³â¶â¼â…â‡rÃ²à¢¨orneÃ²á¶ŒarÄ€;dà¾˜âƒ;æ¥­;æ€ri;æŠ¿Ì€achiqtâ˜âà©€â¢â®â»quo;æ€¹r;ì€€ğ“mÆ€;egà¦²âªâ¬;æª;æªÄ€buâ”ªâ³oÄ€;rà¸Ÿâ¹;æ€šrok;ä…‚è€<;cdhilqrà «âŸ’â˜¹âŸœâŸ âŸ¥âŸªâŸ°Ä€ciâŸ—âŸ™;æª¦r;æ©¹reÃ¥â—²mes;æ‹‰arr;æ¥¶uest;æ©»Ä€PiâŸµâŸ¹ar;æ¦–Æ€;efâ €à¤­á ›æ—ƒrÄ€duâ ‡â shar;æ¥Šhar;æ¥¦Ä€enâ —â ¡rtneqq;ì€€â‰¨ï¸€Ã…â Ü€Dacdefhilnopsuâ¡€â¡…â¢‚â¢â¢“â¢ â¢¥â¢¨â£šâ£¢â£¤àªƒâ£³â¤‚Dot;æˆºÈ€clprâ¡â¡’â¡£â¡½rè€»Â¯ä‚¯Ä€etâ¡—â¡™;æ™‚Ä€;eâ¡â¡Ÿæœ seÂ»â¡ŸÄ€;sá€»â¡¨toÈ€;dluá€»â¡³â¡·â¡»owÃ®ÒŒefÃ´à¤Ã°á‘ker;æ–®Ä€oyâ¢‡â¢Œmma;æ¨©;ä¼ash;æ€”asuredangleÂ»á˜¦r;ì€€ğ”ªo;æ„§Æ€cdnâ¢¯â¢´â£‰roè€»Âµä‚µÈ€;acdá‘¤â¢½â£€â£„sÃ´áš§ir;æ«°otè‚»Â·ÆµusÆ€;bdâ£’á¤ƒâ£“æˆ’Ä€;uá´¼â£˜;æ¨ªÅ£â£â£¡p;æ«›Ã²âˆ’Ã°àªÄ€dpâ£©â£®els;æŠ§f;ì€€ğ•Ä€ctâ£¸â£½r;ì€€ğ“‚posÂ»á–Æ€;lmâ¤‰â¤Šâ¤ä¼timap;æŠ¸à°€GLRVabcdefghijlmoprstuvwâ¥‚â¥“â¥¾â¦‰â¦˜â§šâ§©â¨•â¨šâ©˜â©âªƒâª•âª¤âª¨â¬„â¬‡â­„â­¿â®®â°´â±§â±¼â³©Ä€gtâ¥‡â¥‹;ì€€â‹™Ì¸Ä€;vâ¥à¯ì€€â‰«âƒ’Æ€eltâ¥šâ¥²â¥¶ftÄ€arâ¥¡â¥§rrow;æ‡ightarrow;æ‡;ì€€â‹˜Ì¸Ä€;vâ¥»à±‡ì€€â‰ªâƒ’ightarrow;æ‡Ä€Ddâ¦â¦“ash;æŠ¯ash;æŠ®Ê€bcnptâ¦£â¦§â¦¬â¦±â§ŒlaÂ»Ëute;ä…„g;ì€€âˆ âƒ’Ê€;Eiopà¶„â¦¼â§€â§…â§ˆ;ì€€â©°Ì¸d;ì€€â‰‹Ì¸s;ä…‰roÃ¸à¶„urÄ€;aâ§“â§”æ™®lÄ€;sâ§“à¬¸Ç³â§Ÿ\0â§£pè‚»Â à¬·mpÄ€;eà¯¹à°€Ê€aeouyâ§´â§¾â¨ƒâ¨â¨“Ç°â§¹\0â§»;æ©ƒon;ä…ˆdil;ä…†ngÄ€;dàµ¾â¨Šot;ì€€â©­Ì¸p;æ©‚;ä½ash;æ€“Î€;Aadqsxà®’â¨©â¨­â¨»â©â©…â©rr;æ‡—rÄ€hrâ¨³â¨¶k;æ¤¤Ä€;oá²á°ot;ì€€â‰Ì¸uiÃ¶à­£Ä€eiâ©Šâ©ar;æ¤¨Ã­à®˜istÄ€;sà® à®Ÿr;ì€€ğ”«È€Eestà¯…â©¦â©¹â©¼Æ€;qsà®¼â©­à¯¡Æ€;qsà®¼à¯…â©´lanÃ´à¯¢iÃ­à¯ªÄ€;rà®¶âªÂ»à®·Æ€AapâªŠâªâª‘rÃ²â¥±rr;æ†®ar;æ«²Æ€;svà¾âªœà¾ŒÄ€;dâª¡âª¢æ‹¼;æ‹ºcy;ä‘šÎ€AEadestâª·âªºâª¾â«‚â«…â«¶â«¹rÃ²â¥¦;ì€€â‰¦Ì¸rr;æ†šr;æ€¥È€;fqsà°»â«â«£â«¯tÄ€arâ«”â«™rroÃ·â«ightarroÃ·âªÆ€;qsà°»âªºâ«ªlanÃ´à±•Ä€;sà±•â«´Â»à°¶iÃ­à±Ä€;rà°µâ«¾iÄ€;eà°šà°¥iÃ¤à¶Ä€ptâ¬Œâ¬‘f;ì€€ğ•Ÿè†€Â¬;inâ¬™â¬šâ¬¶ä‚¬nÈ€;Edvà®‰â¬¤â¬¨â¬®;ì€€â‹¹Ì¸ot;ì€€â‹µÌ¸Ç¡à®‰â¬³â¬µ;æ‹·;æ‹¶iÄ€;và²¸â¬¼Ç¡à²¸â­â­ƒ;æ‹¾;æ‹½Æ€aorâ­‹â­£â­©rÈ€;astà­»â­•â­šâ­ŸlleÃ¬à­»l;ì€€â«½âƒ¥;ì€€âˆ‚Ì¸lint;æ¨”Æ€;ceà²’â­°â­³uÃ¥à²¥Ä€;cà²˜â­¸Ä€;eà²’â­½Ã±à²˜È€Aaitâ®ˆâ®‹â®â®§rÃ²â¦ˆrrÆ€;cwâ®”â®•â®™æ†›;ì€€â¤³Ì¸;ì€€â†Ì¸ghtarrowÂ»â®•riÄ€;eà³‹à³–Î€chimpquâ®½â¯â¯™â¬„à­¸â¯¤â¯¯È€;cerà´²â¯†à´·â¯‰uÃ¥àµ…;ì€€ğ“ƒortÉ­â¬…\0\0â¯–arÃ¡â­–mÄ€;eàµ®â¯ŸÄ€;qàµ´àµ³suÄ€bpâ¯«â¯­Ã¥à³¸Ã¥à´‹Æ€bcpâ¯¶â°‘â°™È€;Eesâ¯¿â°€à´¢â°„æŠ„;ì€€â«…Ì¸etÄ€;eà´›â°‹qÄ€;qà´£â°€cÄ€;eà´²â°—Ã±à´¸È€;Eesâ°¢â°£àµŸâ°§æŠ…;ì€€â«†Ì¸etÄ€;eàµ˜â°®qÄ€;qàµ â°£È€gilrâ°½â°¿â±…â±‡Ã¬à¯—ldeè€»Ã±äƒ±Ã§à±ƒiangleÄ€lrâ±’â±œeftÄ€;eà°šâ±šÃ±à°¦ightÄ€;eà³‹â±¥Ã±à³—Ä€;mâ±¬â±­ä½Æ€;esâ±´â±µâ±¹ä€£ro;æ„–p;æ€‡Ò€DHadgilrsâ²â²”â²™â²â²£â²°â²¶â³“â³£ash;æŠ­arr;æ¤„p;ì€€â‰âƒ’ash;æŠ¬Ä€etâ²¨â²¬;ì€€â‰¥âƒ’;ì€€>âƒ’nfin;æ§Æ€Aetâ²½â³â³…rr;æ¤‚;ì€€â‰¤âƒ’Ä€;râ³Šâ³ì€€<âƒ’ie;ì€€âŠ´âƒ’Ä€Atâ³˜â³œrr;æ¤ƒrie;ì€€âŠµâƒ’im;ì€€âˆ¼âƒ’Æ€Aanâ³°â³´â´‚rr;æ‡–rÄ€hrâ³ºâ³½k;æ¤£Ä€;oá§á¥ear;æ¤§á‰“áª•\0\0\0\0\0\0\0\0\0\0\0\0\0â´­\0â´¸âµˆâµ âµ¥âµ²â¶„á¬‡\0\0â¶â¶«\0â·ˆâ·\0â·œâ¸™â¸«â¸¾â¹ƒÄ€csâ´±áª—uteè€»Ã³äƒ³Ä€iyâ´¼âµ…rÄ€;cáªâµ‚è€»Ã´äƒ´;ä¾Ê€abiosáª âµ’âµ—Çˆâµšlac;ä…‘v;æ¨¸old;æ¦¼lig;ä…“Ä€crâµ©âµ­ir;æ¦¿;ì€€ğ”¬Í¯âµ¹\0\0âµ¼\0â¶‚n;ä‹›aveè€»Ã²äƒ²;æ§Ä€bmâ¶ˆà·´ar;æ¦µÈ€acitâ¶•â¶˜â¶¥â¶¨rÃ²áª€Ä€irâ¶â¶ r;æ¦¾oss;æ¦»nÃ¥à¹’;æ§€Æ€aeiâ¶±â¶µâ¶¹cr;ä…ga;ä‰Æ€cdnâ·€â·…Çron;ä¿;æ¦¶pf;ì€€ğ• Æ€aelâ·”â·—Ç’r;æ¦·rp;æ¦¹Î€;adiosvâ·ªâ·«â·®â¸ˆâ¸â¸â¸–æˆ¨rÃ²áª†È€;efmâ··â·¸â¸‚â¸…æ©rÄ€;oâ·¾â·¿æ„´fÂ»â·¿è€»Âªä‚ªè€»Âºä‚ºgof;æŠ¶r;æ©–lope;æ©—;æ©›Æ€cloâ¸Ÿâ¸¡â¸§Ã²â¸ashè€»Ã¸äƒ¸l;æŠ˜iÅ¬â¸¯â¸´deè€»ÃµäƒµesÄ€;aÇ›â¸ºs;æ¨¶mlè€»Ã¶äƒ¶bar;æŒ½à«¡â¹\0â¹½\0âº€âº\0âº¢âº¹\0\0â»‹àºœ\0â¼“\0\0â¼«â¾¼\0â¿ˆrÈ€;astĞƒâ¹§â¹²àº…è„€Â¶;lâ¹­â¹®ä‚¶leÃ¬ĞƒÉ©â¹¸\0\0â¹»m;æ«³;æ«½y;ä¿rÊ€cimptâº‹âºâº“á¡¥âº—nt;ä€¥od;ä€®il;æ€°enk;æ€±r;ì€€ğ”­Æ€imoâº¨âº°âº´Ä€;vâº­âº®ä†;ä•maÃ´à©¶ne;æ˜Æ€;tvâº¿â»€â»ˆä€chforkÂ»á¿½;ä–Ä€auâ»â»ŸnÄ€ckâ»•â»kÄ€;hâ‡´â»›;æ„Ã¶â‡´sÒ€;abcdemstâ»³â»´á¤ˆâ»¹â»½â¼„â¼†â¼Šâ¼ä€«cir;æ¨£ir;æ¨¢Ä€ouáµ€â¼‚;æ¨¥;æ©²nè‚»Â±àºim;æ¨¦wo;æ¨§Æ€ipuâ¼™â¼ â¼¥ntint;æ¨•f;ì€€ğ•¡ndè€»Â£ä‚£Ô€;Eaceinosuà»ˆâ¼¿â½â½„â½‡â¾â¾‰â¾’â½¾â¾¶;æª³p;æª·uÃ¥à»™Ä€;cà»â½ŒÌ€;acensà»ˆâ½™â½Ÿâ½¦â½¨â½¾pproÃ¸â½ƒurlyeÃ±à»™Ã±à»Æ€aesâ½¯â½¶â½ºpprox;æª¹qq;æªµim;æ‹¨iÃ­à»ŸmeÄ€;sâ¾ˆàº®æ€²Æ€Easâ½¸â¾â½ºÃ°â½µÆ€dfpà»¬â¾™â¾¯Æ€alsâ¾ â¾¥â¾ªlar;æŒ®ine;æŒ’urf;æŒ“Ä€;tà»»â¾´Ã¯à»»rel;æŠ°Ä€ciâ¿€â¿…r;ì€€ğ“…;äˆncsp;æ€ˆÌ€fiopsuâ¿šâ‹¢â¿Ÿâ¿¥â¿«â¿±r;ì€€ğ”®pf;ì€€ğ•¢rime;æ—cr;ì€€ğ“†Æ€aeoâ¿¸ã€‰ã€“tÄ€eiâ¿¾ã€…rnionÃ³Ú°nt;æ¨–stÄ€;eã€ã€‘ä€¿Ã±á¼™Ã´à¼”àª€ABHabcdefhilmnoprstuxã€ã‘ã•ã™ãƒ ã„ã„«ã…‡ã…¢ã…²ã†ãˆ†ãˆ•ãˆ¤ãˆ©ã‰˜ã‰®ã‰²ãŠãŠ°ãŠ·Æ€artã‡ãŠãŒrÃ²á‚³Ã²Ïail;æ¤œarÃ²á±¥ar;æ¥¤Î€cdenqrtã¨ãµã¸ã¿ã‚ã‚”ãƒŒÄ€euã­ã±;ì€€âˆ½Ì±te;ä…•iÃ£á…®mptyv;æ¦³gÈ€;delà¿‘ã‚‰ã‚‹ã‚;æ¦’;æ¦¥Ã¥à¿‘uoè€»Â»ä‚»rÖ€;abcfhlpstwà¿œã‚¬ã‚¯ã‚·ã‚¹ã‚¼ã‚¾ãƒ€ãƒƒãƒ‡ãƒŠp;æ¥µÄ€;fà¿ ã‚´s;æ¤ ;æ¤³s;æ¤Ã«â‰Ã°âœ®l;æ¥…im;æ¥´l;æ†£;æ†Ä€aiãƒ‘ãƒ•il;æ¤šoÄ€;nãƒ›ãƒœæˆ¶alÃ³à¼Æ€abrãƒ§ãƒªãƒ®rÃ²áŸ¥rk;æ³Ä€akãƒ³ãƒ½cÄ€ekãƒ¹ãƒ»;ä½;äÄ€esã„‚ã„„;æ¦ŒlÄ€duã„Šã„Œ;æ¦;æ¦È€aeuyã„—ã„œã„§ã„©ron;ä…™Ä€diã„¡ã„¥il;ä…—Ã¬à¿²Ã¢ãƒº;ä‘€È€clqsã„´ã„·ã„½ã…„a;æ¤·dhar;æ¥©uoÄ€;rÈÈh;æ†³Æ€acgã…ã…Ÿà½„lÈ€;ipsà½¸ã…˜ã…›á‚œnÃ¥á‚»arÃ´à¾©t;æ–­Æ€ilrã…©á€£ã…®sht;æ¥½;ì€€ğ”¯Ä€aoã…·ã††rÄ€duã…½ã…¿Â»Ñ»Ä€;lá‚‘ã†„;æ¥¬Ä€;vã†‹ã†Œä;ä±Æ€gnsã†•ã‡¹ã‡¼htÌ€ahlrstã†¤ã†°ã‡‚ã‡˜ã‡¤ã‡®rrowÄ€;tà¿œã†­aÃ©ãƒˆarpoonÄ€duã†»ã†¿owÃ®ã…¾pÂ»á‚’eftÄ€ahã‡Šã‡rrowÃ³à¿ªarpoonÃ³Õ‘ightarrows;æ‡‰quigarroÃ·ãƒ‹hreetimes;æ‹Œg;ä‹šingdotseÃ±á¼²Æ€ahmãˆãˆãˆ“rÃ²à¿ªaÃ²Õ‘;æ€oustÄ€;aãˆãˆŸæ±cheÂ»ãˆŸmid;æ«®È€abptãˆ²ãˆ½ã‰€ã‰’Ä€nrãˆ·ãˆºg;æŸ­r;æ‡¾rÃ«á€ƒÆ€aflã‰‡ã‰Šã‰r;æ¦†;ì€€ğ•£us;æ¨®imes;æ¨µÄ€apã‰ã‰§rÄ€;gã‰£ã‰¤ä€©t;æ¦”olint;æ¨’arÃ²ã‡£È€achqã‰»ãŠ€á‚¼ãŠ…quo;æ€ºr;ì€€ğ“‡Ä€buãƒ»ãŠŠoÄ€;rÈ”È“Æ€hirãŠ—ãŠ›ãŠ reÃ¥ã‡¸mes;æ‹ŠiÈ€;eflãŠªá™á ¡ãŠ«æ–¹tri;æ§luhar;æ¥¨;æ„àµ¡ã‹•ã‹›ã‹ŸãŒ¬ãŒ¸ã±\0ãºã¤\0\0ã¬ã°\0ã¨ã‘ˆã‘šã’­ã’±ã“Šã“±\0ã˜–\0\0ã˜³cute;ä…›quÃ¯âºÔ€;Eaceinpsyá‡­ã‹³ã‹µã‹¿ãŒ‚ãŒ‹ãŒãŒŸãŒ¦ãŒ©;æª´Ç°ã‹º\0ã‹¼;æª¸on;ä…¡uÃ¥á‡¾Ä€;dá‡³ãŒ‡il;ä…Ÿrc;ä…Æ€EasãŒ–ãŒ˜ãŒ›;æª¶p;æªºim;æ‹©olint;æ¨“iÃ­áˆ„;ä‘otÆ€;beãŒ´áµ‡ãŒµæ‹…;æ©¦Î€Aacmstxã†ãŠã—ã›ãã£ã­rr;æ‡˜rÄ€hrãã’Ã«âˆ¨Ä€;oà¨¶à¨´tè€»Â§ä‚§i;ä€»war;æ¤©mÄ€inã©Ã°nuÃ³Ã±t;æœ¶rÄ€;oã¶â•ì€€ğ”°È€acoyã‚ã†ã‘ã rp;æ™¯Ä€hyã‹ãcy;ä‘‰;ä‘ˆrtÉ­ã™\0\0ãœiÃ¤á‘¤araÃ¬â¹¯è€»Â­ä‚­Ä€gmã¨ã´maÆ€;fvã±ã²ã²äƒ;ä‚Ğ€;deglnpráŠ«ã…ã‰ãã–ãã¡ã¦ot;æ©ªÄ€;qáŠ±áŠ°Ä€;Eã“ã”æª;æª Ä€;Eã›ãœæª;æªŸe;æ‰†lus;æ¨¤arr;æ¥²arÃ²á„½È€aeitã¸ãˆãã—Ä€lsã½ã„lsetmÃ©ãªhp;æ¨³parsl;æ§¤Ä€dlá‘£ã”e;æŒ£Ä€;eãœãæªªÄ€;sã¢ã£æª¬;ì€€âª¬ï¸€Æ€flpã®ã³ã‘‚tcy;ä‘ŒÄ€;bã¸ã¹ä€¯Ä€;aã¾ã¿æ§„r;æŒ¿f;ì€€ğ•¤aÄ€drã‘Ğ‚esÄ€;uã‘”ã‘•æ™ itÂ»ã‘•Æ€csuã‘ ã‘¹ã’ŸÄ€auã‘¥ã‘¯pÄ€;sá†ˆã‘«;ì€€âŠ“ï¸€pÄ€;sá†´ã‘µ;ì€€âŠ”ï¸€uÄ€bpã‘¿ã’Æ€;esá†—á†œã’†etÄ€;eá†—ã’Ã±á†Æ€;esá†¨á†­ã’–etÄ€;eá†¨ã’Ã±á†®Æ€;afá…»ã’¦Ö°rÅ¥ã’«Ö±Â»á…¼arÃ²á…ˆÈ€cemtã’¹ã’¾ã“‚ã“…r;ì€€ğ“ˆtmÃ®Ã±iÃ¬ã•arÃ¦á†¾Ä€arã“ã“•rÄ€;fã“”á¿æ˜†Ä€anã“šã“­ightÄ€epã“£ã“ªpsiloÃ®á» hÃ©âº¯sÂ»â¡’Ê€bcmnpã“»ã•áˆ‰ã–‹ã–Ò€;Edemnprsã”ã”ã”‘ã”•ã”ã”£ã”¬ã”±ã”¶æŠ‚;æ«…ot;æª½Ä€;dá‡šã”šot;æ«ƒult;æ«Ä€Eeã”¨ã”ª;æ«‹;æŠŠlus;æª¿arr;æ¥¹Æ€eiuã”½ã•’ã••tÆ€;enã”ã•…ã•‹qÄ€;qá‡šã”eqÄ€;qã”«ã”¨m;æ«‡Ä€bpã•šã•œ;æ«•;æ«“cÌ€;acensá‡­ã•¬ã•²ã•¹ã•»ãŒ¦pproÃ¸ã‹ºurlyeÃ±á‡¾Ã±á‡³Æ€aesã–‚ã–ˆãŒ›pproÃ¸ãŒšqÃ±ãŒ—g;æ™ªÚ€123;Edehlmnpsã–©ã–¬ã–¯áˆœã–²ã–´ã—€ã—‰ã—•ã—šã—Ÿã—¨ã—­è€»Â¹ä‚¹è€»Â²ä‚²è€»Â³ä‚³;æ«†Ä€osã–¹ã–¼t;æª¾ub;æ«˜Ä€;dáˆ¢ã—…ot;æ«„sÄ€ouã—ã—’l;æŸ‰b;æ«—arr;æ¥»ult;æ«‚Ä€Eeã—¤ã—¦;æ«Œ;æŠ‹lus;æ«€Æ€eiuã—´ã˜‰ã˜ŒtÆ€;enáˆœã—¼ã˜‚qÄ€;qáˆ¢ã–²eqÄ€;qã—§ã—¤m;æ«ˆÄ€bpã˜‘ã˜“;æ«”;æ«–Æ€Aanã˜œã˜ ã˜­rr;æ‡™rÄ€hrã˜¦ã˜¨Ã«âˆ®Ä€;oà¨«à¨©war;æ¤ªligè€»ÃŸäƒŸà¯¡ã™‘ã™ã™ á‹ã™³ã™¹\0ã™¾ã›‚\0\0\0\0\0ã››ãœƒ\0ãœ‰ã¬\0\0\0ã‡É²ã™–\0\0ã™›get;æŒ–;ä„rÃ«à¹ŸÆ€aeyã™¦ã™«ã™°ron;ä…¥dil;ä…£;ä‘‚lrec;æŒ•r;ì€€ğ”±È€eikoãš†ãšãšµãš¼Ç²ãš‹\0ãš‘eÄ€4fáŠ„áŠaÆ€;svãš˜ãš™ãš›ä¸ym;ä‘Ä€cnãš¢ãš²kÄ€asãš¨ãš®pproÃ¸á‹imÂ»áŠ¬sÃ°áŠÄ€asãšºãš®Ã°á‹rnè€»Ã¾äƒ¾Ç¬ÌŸã›†â‹§esè†€Ã—;bdã›ã›ã›˜äƒ—Ä€;aá¤ã›•r;æ¨±;æ¨°Æ€epsã›¡ã›£ãœ€Ã¡â©È€;bcfÒ†ã›¬ã›°ã›´ot;æŒ¶ir;æ«±Ä€;oã›¹ã›¼ì€€ğ•¥rk;æ«šÃ¡ã¢rime;æ€´Æ€aipãœãœ’ã¤dÃ¥á‰ˆÎ€adempstãœ¡ãã€ã‘ã—ãœãŸngleÊ€;dlqrãœ°ãœ±ãœ¶ã€ã‚æ–µownÂ»á¶»eftÄ€;eâ €ãœ¾Ã±à¤®;æ‰œightÄ€;eãŠªã‹Ã±ášot;æ—¬inus;æ¨ºlus;æ¨¹b;æ§ime;æ¨»ezium;æ¢Æ€chtã²ã½ãÄ€ryã·ã»;ì€€ğ“‰;ä‘†cy;ä‘›rok;ä…§Ä€ioã‹ãxÃ´á·headÄ€lrã—ã eftarroÃ·à¡ightarrowÂ»à½à¤€AHabcdfghlmoprstuwãŸãŸ“ãŸ—ãŸ¤ãŸ°ãŸ¼ã ã œã £ã ´ã¡‘ã¡ã¡«ã¢©ã£Œã£’ã£ªã£¶rÃ²Ï­ar;æ¥£Ä€crãŸœãŸ¢uteè€»ÃºäƒºÃ²á…rÇ£ãŸª\0ãŸ­y;ä‘ve;ä…­Ä€iyãŸµãŸºrcè€»Ã»äƒ»;ä‘ƒÆ€abhã ƒã †ã ‹rÃ²á­lac;ä…±aÃ²áƒÄ€irã “ã ˜sht;æ¥¾;ì€€ğ”²raveè€»Ã¹äƒ¹Å¡ã §ã ±rÄ€lrã ¬ã ®Â»à¥—Â»á‚ƒlk;æ–€Ä€ctã ¹ã¡É¯ã ¿\0\0ã¡ŠrnÄ€;eã¡…ã¡†æŒœrÂ»ã¡†op;æŒri;æ—¸Ä€alã¡–ã¡šcr;ä…«è‚»Â¨Í‰Ä€gpã¡¢ã¡¦on;ä…³f;ì€€ğ•¦Ì€adhlsuá…‹ã¡¸ã¡½á²ã¢‘ã¢ ownÃ¡á³arpoonÄ€lrã¢ˆã¢ŒefÃ´ã ­ighÃ´ã ¯iÆ€;hlã¢™ã¢šã¢œä…Â»áºonÂ»ã¢šparrows;æ‡ˆÆ€citã¢°ã£„ã£ˆÉ¯ã¢¶\0\0ã£rnÄ€;eã¢¼ã¢½æŒrÂ»ã¢½op;æŒng;ä…¯ri;æ—¹cr;ì€€ğ“ŠÆ€dirã£™ã£ã£¢ot;æ‹°lde;ä…©iÄ€;fãœ°ã£¨Â»á “Ä€amã£¯ã£²rÃ²ã¢¨lè€»Ã¼äƒ¼angle;æ¦§Ş€ABDacdeflnoprszã¤œã¤Ÿã¤©ã¤­ã¦µã¦¸ã¦½ã§Ÿã§¤ã§¨ã§³ã§¹ã§½ã¨ã¨ rÃ²Ï·arÄ€;vã¤¦ã¤§æ«¨;æ«©asÃ¨Ï¡Ä€nrã¤²ã¤·grt;æ¦œÎ€eknprstã“£ã¥†ã¥‹ã¥’ã¥ã¥¤ã¦–appÃ¡â•othinÃ§áº–Æ€hirã“«â»ˆã¥™opÃ´â¾µÄ€;há·ã¥¢Ã¯ã†Ä€iuã¥©ã¥­gmÃ¡ã³Ä€bpã¥²ã¦„setneqÄ€;qã¥½ã¦€ì€€âŠŠï¸€;ì€€â«‹ï¸€setneqÄ€;qã¦ã¦’ì€€âŠ‹ï¸€;ì€€â«Œï¸€Ä€hrã¦›ã¦ŸetÃ¡ãšœiangleÄ€lrã¦ªã¦¯eftÂ»à¤¥ightÂ»á‘y;ä²ashÂ»á€¶Æ€elrã§„ã§’ã§—Æ€;beâ·ªã§‹ã§ar;æŠ»q;æ‰šlip;æ‹®Ä€btã§œá‘¨aÃ²á‘©r;ì€€ğ”³trÃ©ã¦®suÄ€bpã§¯ã§±Â»à´œÂ»àµ™pf;ì€€ğ•§roÃ°à»»trÃ©ã¦´Ä€cuã¨†ã¨‹r;ì€€ğ“‹Ä€bpã¨ã¨˜nÄ€Eeã¦€ã¨–Â»ã¥¾nÄ€Eeã¦’ã¨Â»ã¦igzag;æ¦šÎ€cefoprsã¨¶ã¨»ã©–ã©›ã©”ã©¡ã©ªirc;ä…µÄ€diã©€ã©‘Ä€bgã©…ã©‰ar;æ©ŸeÄ€;qá—ºã©;æ‰™erp;æ„˜r;ì€€ğ”´pf;ì€€ğ•¨Ä€;eá‘¹ã©¦atÃ¨á‘¹cr;ì€€ğ“Œà«£áãª‡\0ãª‹\0ãªãª›\0\0ãªãª¨ãª«ãª¯\0\0ã«ƒã«\0ã«˜áŸœáŸŸtrÃ©áŸ‘r;ì€€ğ”µÄ€Aaãª”ãª—rÃ²ÏƒrÃ²à§¶;ä¾Ä€Aaãª¡ãª¤rÃ²Î¸rÃ²à§«aÃ°âœ“is;æ‹»Æ€dptá¤ãªµãª¾Ä€flãªºá©;ì€€ğ•©imÃ¥á²Ä€Aaã«‡ã«ŠrÃ²ÏrÃ²à¨Ä€cqã«’á¸r;ì€€ğ“Ä€ptáŸ–ã«œrÃ©áŸ”Ğ€acefiosuã«°ã«½ã¬ˆã¬Œã¬‘ã¬•ã¬›ã¬¡cÄ€uyã«¶ã«»teè€»Ã½äƒ½;ä‘Ä€iyã¬‚ã¬†rc;ä…·;ä‘‹nè€»Â¥ä‚¥r;ì€€ğ”¶cy;ä‘—pf;ì€€ğ•ªcr;ì€€ğ“Ä€cmã¬¦ã¬©y;ä‘lè€»Ã¿äƒ¿Ô€acdefhioswã­‚ã­ˆã­”ã­˜ã­¤ã­©ã­­ã­´ã­ºã®€cute;ä…ºÄ€ayã­ã­’ron;ä…¾;ä·ot;ä…¼Ä€etã­ã­¡trÃ¦á•Ÿa;ä¶r;ì€€ğ”·cy;ä¶grarr;æ‡pf;ì€€ğ•«cr;ì€€ğ“Ä€jnã®…ã®‡;æ€j;æ€Œ'.split("").map((e) => e.charCodeAt(0))
), cy = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
function fy(e) {
  var t;
  return e >= 55296 && e <= 57343 || e > 1114111 ? 65533 : (t = cy.get(e)) !== null && t !== void 0 ? t : e;
}
var kn;
(function(e) {
  e[e.NUM = 35] = "NUM", e[e.SEMI = 59] = "SEMI", e[e.EQUALS = 61] = "EQUALS", e[e.ZERO = 48] = "ZERO", e[e.NINE = 57] = "NINE", e[e.LOWER_A = 97] = "LOWER_A", e[e.LOWER_F = 102] = "LOWER_F", e[e.LOWER_X = 120] = "LOWER_X", e[e.LOWER_Z = 122] = "LOWER_Z", e[e.UPPER_A = 65] = "UPPER_A", e[e.UPPER_F = 70] = "UPPER_F", e[e.UPPER_Z = 90] = "UPPER_Z";
})(kn || (kn = {}));
const hy = 32;
var Ki;
(function(e) {
  e[e.VALUE_LENGTH = 49152] = "VALUE_LENGTH", e[e.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", e[e.JUMP_TABLE = 127] = "JUMP_TABLE";
})(Ki || (Ki = {}));
function Rc(e) {
  return e >= kn.ZERO && e <= kn.NINE;
}
function dy(e) {
  return e >= kn.UPPER_A && e <= kn.UPPER_F || e >= kn.LOWER_A && e <= kn.LOWER_F;
}
function py(e) {
  return e >= kn.UPPER_A && e <= kn.UPPER_Z || e >= kn.LOWER_A && e <= kn.LOWER_Z || Rc(e);
}
function my(e) {
  return e === kn.EQUALS || py(e);
}
var Sn;
(function(e) {
  e[e.EntityStart = 0] = "EntityStart", e[e.NumericStart = 1] = "NumericStart", e[e.NumericDecimal = 2] = "NumericDecimal", e[e.NumericHex = 3] = "NumericHex", e[e.NamedEntity = 4] = "NamedEntity";
})(Sn || (Sn = {}));
var vi;
(function(e) {
  e[e.Legacy = 0] = "Legacy", e[e.Strict = 1] = "Strict", e[e.Attribute = 2] = "Attribute";
})(vi || (vi = {}));
class gy {
  constructor(t, n, r) {
    this.decodeTree = t, this.emitCodePoint = n, this.errors = r, this.state = Sn.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = vi.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(t) {
    this.decodeMode = t, this.state = Sn.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(t, n) {
    switch (this.state) {
      case Sn.EntityStart:
        return t.charCodeAt(n) === kn.NUM ? (this.state = Sn.NumericStart, this.consumed += 1, this.stateNumericStart(t, n + 1)) : (this.state = Sn.NamedEntity, this.stateNamedEntity(t, n));
      case Sn.NumericStart:
        return this.stateNumericStart(t, n);
      case Sn.NumericDecimal:
        return this.stateNumericDecimal(t, n);
      case Sn.NumericHex:
        return this.stateNumericHex(t, n);
      case Sn.NamedEntity:
        return this.stateNamedEntity(t, n);
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(t, n) {
    return n >= t.length ? -1 : (t.charCodeAt(n) | hy) === kn.LOWER_X ? (this.state = Sn.NumericHex, this.consumed += 1, this.stateNumericHex(t, n + 1)) : (this.state = Sn.NumericDecimal, this.stateNumericDecimal(t, n));
  }
  addToNumericResult(t, n, r, i) {
    if (n !== r) {
      const a = r - n;
      this.result = this.result * Math.pow(i, a) + Number.parseInt(t.substr(n, a), i), this.consumed += a;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(t, n) {
    const r = n;
    for (; n < t.length; ) {
      const i = t.charCodeAt(n);
      if (Rc(i) || dy(i))
        n += 1;
      else
        return this.addToNumericResult(t, r, n, 16), this.emitNumericEntity(i, 3);
    }
    return this.addToNumericResult(t, r, n, 16), -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(t, n) {
    const r = n;
    for (; n < t.length; ) {
      const i = t.charCodeAt(n);
      if (Rc(i))
        n += 1;
      else
        return this.addToNumericResult(t, r, n, 10), this.emitNumericEntity(i, 2);
    }
    return this.addToNumericResult(t, r, n, 10), -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(t, n) {
    var r;
    if (this.consumed <= n)
      return (r = this.errors) === null || r === void 0 || r.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
    if (t === kn.SEMI)
      this.consumed += 1;
    else if (this.decodeMode === vi.Strict)
      return 0;
    return this.emitCodePoint(fy(this.result), this.consumed), this.errors && (t !== kn.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(t, n) {
    const { decodeTree: r } = this;
    let i = r[this.treeIndex], a = (i & Ki.VALUE_LENGTH) >> 14;
    for (; n < t.length; n++, this.excess++) {
      const s = t.charCodeAt(n);
      if (this.treeIndex = by(r, i, this.treeIndex + Math.max(1, a), s), this.treeIndex < 0)
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === vi.Attribute && // We shouldn't have consumed any characters after the entity,
        (a === 0 || // And there should be no invalid characters.
        my(s)) ? 0 : this.emitNotTerminatedNamedEntity();
      if (i = r[this.treeIndex], a = (i & Ki.VALUE_LENGTH) >> 14, a !== 0) {
        if (s === kn.SEMI)
          return this.emitNamedEntityData(this.treeIndex, a, this.consumed + this.excess);
        this.decodeMode !== vi.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var t;
    const { result: n, decodeTree: r } = this, i = (r[n] & Ki.VALUE_LENGTH) >> 14;
    return this.emitNamedEntityData(n, i, this.consumed), (t = this.errors) === null || t === void 0 || t.missingSemicolonAfterCharacterReference(), this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(t, n, r) {
    const { decodeTree: i } = this;
    return this.emitCodePoint(n === 1 ? i[t] & ~Ki.VALUE_LENGTH : i[t + 1], r), n === 3 && this.emitCodePoint(i[t + 2], r), r;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var t;
    switch (this.state) {
      case Sn.NamedEntity:
        return this.result !== 0 && (this.decodeMode !== vi.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      // Otherwise, emit a numeric entity if we have one.
      case Sn.NumericDecimal:
        return this.emitNumericEntity(0, 2);
      case Sn.NumericHex:
        return this.emitNumericEntity(0, 3);
      case Sn.NumericStart:
        return (t = this.errors) === null || t === void 0 || t.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
      case Sn.EntityStart:
        return 0;
    }
  }
}
function by(e, t, n, r) {
  const i = (t & Ki.BRANCH_LENGTH) >> 7, a = t & Ki.JUMP_TABLE;
  if (i === 0)
    return a !== 0 && r === a ? n : -1;
  if (a) {
    const u = r - a;
    return u < 0 || u >= i ? -1 : e[n + u] - 1;
  }
  let s = n, o = s + i - 1;
  for (; s <= o; ) {
    const u = s + o >>> 1, c = e[u];
    if (c < r)
      s = u + 1;
    else if (c > r)
      o = u - 1;
    else
      return e[u + i];
  }
  return -1;
}
var Ce;
(function(e) {
  e.HTML = "http://www.w3.org/1999/xhtml", e.MATHML = "http://www.w3.org/1998/Math/MathML", e.SVG = "http://www.w3.org/2000/svg", e.XLINK = "http://www.w3.org/1999/xlink", e.XML = "http://www.w3.org/XML/1998/namespace", e.XMLNS = "http://www.w3.org/2000/xmlns/";
})(Ce || (Ce = {}));
var xa;
(function(e) {
  e.TYPE = "type", e.ACTION = "action", e.ENCODING = "encoding", e.PROMPT = "prompt", e.NAME = "name", e.COLOR = "color", e.FACE = "face", e.SIZE = "size";
})(xa || (xa = {}));
var vr;
(function(e) {
  e.NO_QUIRKS = "no-quirks", e.QUIRKS = "quirks", e.LIMITED_QUIRKS = "limited-quirks";
})(vr || (vr = {}));
var ce;
(function(e) {
  e.A = "a", e.ADDRESS = "address", e.ANNOTATION_XML = "annotation-xml", e.APPLET = "applet", e.AREA = "area", e.ARTICLE = "article", e.ASIDE = "aside", e.B = "b", e.BASE = "base", e.BASEFONT = "basefont", e.BGSOUND = "bgsound", e.BIG = "big", e.BLOCKQUOTE = "blockquote", e.BODY = "body", e.BR = "br", e.BUTTON = "button", e.CAPTION = "caption", e.CENTER = "center", e.CODE = "code", e.COL = "col", e.COLGROUP = "colgroup", e.DD = "dd", e.DESC = "desc", e.DETAILS = "details", e.DIALOG = "dialog", e.DIR = "dir", e.DIV = "div", e.DL = "dl", e.DT = "dt", e.EM = "em", e.EMBED = "embed", e.FIELDSET = "fieldset", e.FIGCAPTION = "figcaption", e.FIGURE = "figure", e.FONT = "font", e.FOOTER = "footer", e.FOREIGN_OBJECT = "foreignObject", e.FORM = "form", e.FRAME = "frame", e.FRAMESET = "frameset", e.H1 = "h1", e.H2 = "h2", e.H3 = "h3", e.H4 = "h4", e.H5 = "h5", e.H6 = "h6", e.HEAD = "head", e.HEADER = "header", e.HGROUP = "hgroup", e.HR = "hr", e.HTML = "html", e.I = "i", e.IMG = "img", e.IMAGE = "image", e.INPUT = "input", e.IFRAME = "iframe", e.KEYGEN = "keygen", e.LABEL = "label", e.LI = "li", e.LINK = "link", e.LISTING = "listing", e.MAIN = "main", e.MALIGNMARK = "malignmark", e.MARQUEE = "marquee", e.MATH = "math", e.MENU = "menu", e.META = "meta", e.MGLYPH = "mglyph", e.MI = "mi", e.MO = "mo", e.MN = "mn", e.MS = "ms", e.MTEXT = "mtext", e.NAV = "nav", e.NOBR = "nobr", e.NOFRAMES = "noframes", e.NOEMBED = "noembed", e.NOSCRIPT = "noscript", e.OBJECT = "object", e.OL = "ol", e.OPTGROUP = "optgroup", e.OPTION = "option", e.P = "p", e.PARAM = "param", e.PLAINTEXT = "plaintext", e.PRE = "pre", e.RB = "rb", e.RP = "rp", e.RT = "rt", e.RTC = "rtc", e.RUBY = "ruby", e.S = "s", e.SCRIPT = "script", e.SEARCH = "search", e.SECTION = "section", e.SELECT = "select", e.SOURCE = "source", e.SMALL = "small", e.SPAN = "span", e.STRIKE = "strike", e.STRONG = "strong", e.STYLE = "style", e.SUB = "sub", e.SUMMARY = "summary", e.SUP = "sup", e.TABLE = "table", e.TBODY = "tbody", e.TEMPLATE = "template", e.TEXTAREA = "textarea", e.TFOOT = "tfoot", e.TD = "td", e.TH = "th", e.THEAD = "thead", e.TITLE = "title", e.TR = "tr", e.TRACK = "track", e.TT = "tt", e.U = "u", e.UL = "ul", e.SVG = "svg", e.VAR = "var", e.WBR = "wbr", e.XMP = "xmp";
})(ce || (ce = {}));
var m;
(function(e) {
  e[e.UNKNOWN = 0] = "UNKNOWN", e[e.A = 1] = "A", e[e.ADDRESS = 2] = "ADDRESS", e[e.ANNOTATION_XML = 3] = "ANNOTATION_XML", e[e.APPLET = 4] = "APPLET", e[e.AREA = 5] = "AREA", e[e.ARTICLE = 6] = "ARTICLE", e[e.ASIDE = 7] = "ASIDE", e[e.B = 8] = "B", e[e.BASE = 9] = "BASE", e[e.BASEFONT = 10] = "BASEFONT", e[e.BGSOUND = 11] = "BGSOUND", e[e.BIG = 12] = "BIG", e[e.BLOCKQUOTE = 13] = "BLOCKQUOTE", e[e.BODY = 14] = "BODY", e[e.BR = 15] = "BR", e[e.BUTTON = 16] = "BUTTON", e[e.CAPTION = 17] = "CAPTION", e[e.CENTER = 18] = "CENTER", e[e.CODE = 19] = "CODE", e[e.COL = 20] = "COL", e[e.COLGROUP = 21] = "COLGROUP", e[e.DD = 22] = "DD", e[e.DESC = 23] = "DESC", e[e.DETAILS = 24] = "DETAILS", e[e.DIALOG = 25] = "DIALOG", e[e.DIR = 26] = "DIR", e[e.DIV = 27] = "DIV", e[e.DL = 28] = "DL", e[e.DT = 29] = "DT", e[e.EM = 30] = "EM", e[e.EMBED = 31] = "EMBED", e[e.FIELDSET = 32] = "FIELDSET", e[e.FIGCAPTION = 33] = "FIGCAPTION", e[e.FIGURE = 34] = "FIGURE", e[e.FONT = 35] = "FONT", e[e.FOOTER = 36] = "FOOTER", e[e.FOREIGN_OBJECT = 37] = "FOREIGN_OBJECT", e[e.FORM = 38] = "FORM", e[e.FRAME = 39] = "FRAME", e[e.FRAMESET = 40] = "FRAMESET", e[e.H1 = 41] = "H1", e[e.H2 = 42] = "H2", e[e.H3 = 43] = "H3", e[e.H4 = 44] = "H4", e[e.H5 = 45] = "H5", e[e.H6 = 46] = "H6", e[e.HEAD = 47] = "HEAD", e[e.HEADER = 48] = "HEADER", e[e.HGROUP = 49] = "HGROUP", e[e.HR = 50] = "HR", e[e.HTML = 51] = "HTML", e[e.I = 52] = "I", e[e.IMG = 53] = "IMG", e[e.IMAGE = 54] = "IMAGE", e[e.INPUT = 55] = "INPUT", e[e.IFRAME = 56] = "IFRAME", e[e.KEYGEN = 57] = "KEYGEN", e[e.LABEL = 58] = "LABEL", e[e.LI = 59] = "LI", e[e.LINK = 60] = "LINK", e[e.LISTING = 61] = "LISTING", e[e.MAIN = 62] = "MAIN", e[e.MALIGNMARK = 63] = "MALIGNMARK", e[e.MARQUEE = 64] = "MARQUEE", e[e.MATH = 65] = "MATH", e[e.MENU = 66] = "MENU", e[e.META = 67] = "META", e[e.MGLYPH = 68] = "MGLYPH", e[e.MI = 69] = "MI", e[e.MO = 70] = "MO", e[e.MN = 71] = "MN", e[e.MS = 72] = "MS", e[e.MTEXT = 73] = "MTEXT", e[e.NAV = 74] = "NAV", e[e.NOBR = 75] = "NOBR", e[e.NOFRAMES = 76] = "NOFRAMES", e[e.NOEMBED = 77] = "NOEMBED", e[e.NOSCRIPT = 78] = "NOSCRIPT", e[e.OBJECT = 79] = "OBJECT", e[e.OL = 80] = "OL", e[e.OPTGROUP = 81] = "OPTGROUP", e[e.OPTION = 82] = "OPTION", e[e.P = 83] = "P", e[e.PARAM = 84] = "PARAM", e[e.PLAINTEXT = 85] = "PLAINTEXT", e[e.PRE = 86] = "PRE", e[e.RB = 87] = "RB", e[e.RP = 88] = "RP", e[e.RT = 89] = "RT", e[e.RTC = 90] = "RTC", e[e.RUBY = 91] = "RUBY", e[e.S = 92] = "S", e[e.SCRIPT = 93] = "SCRIPT", e[e.SEARCH = 94] = "SEARCH", e[e.SECTION = 95] = "SECTION", e[e.SELECT = 96] = "SELECT", e[e.SOURCE = 97] = "SOURCE", e[e.SMALL = 98] = "SMALL", e[e.SPAN = 99] = "SPAN", e[e.STRIKE = 100] = "STRIKE", e[e.STRONG = 101] = "STRONG", e[e.STYLE = 102] = "STYLE", e[e.SUB = 103] = "SUB", e[e.SUMMARY = 104] = "SUMMARY", e[e.SUP = 105] = "SUP", e[e.TABLE = 106] = "TABLE", e[e.TBODY = 107] = "TBODY", e[e.TEMPLATE = 108] = "TEMPLATE", e[e.TEXTAREA = 109] = "TEXTAREA", e[e.TFOOT = 110] = "TFOOT", e[e.TD = 111] = "TD", e[e.TH = 112] = "TH", e[e.THEAD = 113] = "THEAD", e[e.TITLE = 114] = "TITLE", e[e.TR = 115] = "TR", e[e.TRACK = 116] = "TRACK", e[e.TT = 117] = "TT", e[e.U = 118] = "U", e[e.UL = 119] = "UL", e[e.SVG = 120] = "SVG", e[e.VAR = 121] = "VAR", e[e.WBR = 122] = "WBR", e[e.XMP = 123] = "XMP";
})(m || (m = {}));
const Ey = /* @__PURE__ */ new Map([
  [ce.A, m.A],
  [ce.ADDRESS, m.ADDRESS],
  [ce.ANNOTATION_XML, m.ANNOTATION_XML],
  [ce.APPLET, m.APPLET],
  [ce.AREA, m.AREA],
  [ce.ARTICLE, m.ARTICLE],
  [ce.ASIDE, m.ASIDE],
  [ce.B, m.B],
  [ce.BASE, m.BASE],
  [ce.BASEFONT, m.BASEFONT],
  [ce.BGSOUND, m.BGSOUND],
  [ce.BIG, m.BIG],
  [ce.BLOCKQUOTE, m.BLOCKQUOTE],
  [ce.BODY, m.BODY],
  [ce.BR, m.BR],
  [ce.BUTTON, m.BUTTON],
  [ce.CAPTION, m.CAPTION],
  [ce.CENTER, m.CENTER],
  [ce.CODE, m.CODE],
  [ce.COL, m.COL],
  [ce.COLGROUP, m.COLGROUP],
  [ce.DD, m.DD],
  [ce.DESC, m.DESC],
  [ce.DETAILS, m.DETAILS],
  [ce.DIALOG, m.DIALOG],
  [ce.DIR, m.DIR],
  [ce.DIV, m.DIV],
  [ce.DL, m.DL],
  [ce.DT, m.DT],
  [ce.EM, m.EM],
  [ce.EMBED, m.EMBED],
  [ce.FIELDSET, m.FIELDSET],
  [ce.FIGCAPTION, m.FIGCAPTION],
  [ce.FIGURE, m.FIGURE],
  [ce.FONT, m.FONT],
  [ce.FOOTER, m.FOOTER],
  [ce.FOREIGN_OBJECT, m.FOREIGN_OBJECT],
  [ce.FORM, m.FORM],
  [ce.FRAME, m.FRAME],
  [ce.FRAMESET, m.FRAMESET],
  [ce.H1, m.H1],
  [ce.H2, m.H2],
  [ce.H3, m.H3],
  [ce.H4, m.H4],
  [ce.H5, m.H5],
  [ce.H6, m.H6],
  [ce.HEAD, m.HEAD],
  [ce.HEADER, m.HEADER],
  [ce.HGROUP, m.HGROUP],
  [ce.HR, m.HR],
  [ce.HTML, m.HTML],
  [ce.I, m.I],
  [ce.IMG, m.IMG],
  [ce.IMAGE, m.IMAGE],
  [ce.INPUT, m.INPUT],
  [ce.IFRAME, m.IFRAME],
  [ce.KEYGEN, m.KEYGEN],
  [ce.LABEL, m.LABEL],
  [ce.LI, m.LI],
  [ce.LINK, m.LINK],
  [ce.LISTING, m.LISTING],
  [ce.MAIN, m.MAIN],
  [ce.MALIGNMARK, m.MALIGNMARK],
  [ce.MARQUEE, m.MARQUEE],
  [ce.MATH, m.MATH],
  [ce.MENU, m.MENU],
  [ce.META, m.META],
  [ce.MGLYPH, m.MGLYPH],
  [ce.MI, m.MI],
  [ce.MO, m.MO],
  [ce.MN, m.MN],
  [ce.MS, m.MS],
  [ce.MTEXT, m.MTEXT],
  [ce.NAV, m.NAV],
  [ce.NOBR, m.NOBR],
  [ce.NOFRAMES, m.NOFRAMES],
  [ce.NOEMBED, m.NOEMBED],
  [ce.NOSCRIPT, m.NOSCRIPT],
  [ce.OBJECT, m.OBJECT],
  [ce.OL, m.OL],
  [ce.OPTGROUP, m.OPTGROUP],
  [ce.OPTION, m.OPTION],
  [ce.P, m.P],
  [ce.PARAM, m.PARAM],
  [ce.PLAINTEXT, m.PLAINTEXT],
  [ce.PRE, m.PRE],
  [ce.RB, m.RB],
  [ce.RP, m.RP],
  [ce.RT, m.RT],
  [ce.RTC, m.RTC],
  [ce.RUBY, m.RUBY],
  [ce.S, m.S],
  [ce.SCRIPT, m.SCRIPT],
  [ce.SEARCH, m.SEARCH],
  [ce.SECTION, m.SECTION],
  [ce.SELECT, m.SELECT],
  [ce.SOURCE, m.SOURCE],
  [ce.SMALL, m.SMALL],
  [ce.SPAN, m.SPAN],
  [ce.STRIKE, m.STRIKE],
  [ce.STRONG, m.STRONG],
  [ce.STYLE, m.STYLE],
  [ce.SUB, m.SUB],
  [ce.SUMMARY, m.SUMMARY],
  [ce.SUP, m.SUP],
  [ce.TABLE, m.TABLE],
  [ce.TBODY, m.TBODY],
  [ce.TEMPLATE, m.TEMPLATE],
  [ce.TEXTAREA, m.TEXTAREA],
  [ce.TFOOT, m.TFOOT],
  [ce.TD, m.TD],
  [ce.TH, m.TH],
  [ce.THEAD, m.THEAD],
  [ce.TITLE, m.TITLE],
  [ce.TR, m.TR],
  [ce.TRACK, m.TRACK],
  [ce.TT, m.TT],
  [ce.U, m.U],
  [ce.UL, m.UL],
  [ce.SVG, m.SVG],
  [ce.VAR, m.VAR],
  [ce.WBR, m.WBR],
  [ce.XMP, m.XMP]
]);
function ms(e) {
  var t;
  return (t = Ey.get(e)) !== null && t !== void 0 ? t : m.UNKNOWN;
}
const Oe = m, yy = {
  [Ce.HTML]: /* @__PURE__ */ new Set([
    Oe.ADDRESS,
    Oe.APPLET,
    Oe.AREA,
    Oe.ARTICLE,
    Oe.ASIDE,
    Oe.BASE,
    Oe.BASEFONT,
    Oe.BGSOUND,
    Oe.BLOCKQUOTE,
    Oe.BODY,
    Oe.BR,
    Oe.BUTTON,
    Oe.CAPTION,
    Oe.CENTER,
    Oe.COL,
    Oe.COLGROUP,
    Oe.DD,
    Oe.DETAILS,
    Oe.DIR,
    Oe.DIV,
    Oe.DL,
    Oe.DT,
    Oe.EMBED,
    Oe.FIELDSET,
    Oe.FIGCAPTION,
    Oe.FIGURE,
    Oe.FOOTER,
    Oe.FORM,
    Oe.FRAME,
    Oe.FRAMESET,
    Oe.H1,
    Oe.H2,
    Oe.H3,
    Oe.H4,
    Oe.H5,
    Oe.H6,
    Oe.HEAD,
    Oe.HEADER,
    Oe.HGROUP,
    Oe.HR,
    Oe.HTML,
    Oe.IFRAME,
    Oe.IMG,
    Oe.INPUT,
    Oe.LI,
    Oe.LINK,
    Oe.LISTING,
    Oe.MAIN,
    Oe.MARQUEE,
    Oe.MENU,
    Oe.META,
    Oe.NAV,
    Oe.NOEMBED,
    Oe.NOFRAMES,
    Oe.NOSCRIPT,
    Oe.OBJECT,
    Oe.OL,
    Oe.P,
    Oe.PARAM,
    Oe.PLAINTEXT,
    Oe.PRE,
    Oe.SCRIPT,
    Oe.SECTION,
    Oe.SELECT,
    Oe.SOURCE,
    Oe.STYLE,
    Oe.SUMMARY,
    Oe.TABLE,
    Oe.TBODY,
    Oe.TD,
    Oe.TEMPLATE,
    Oe.TEXTAREA,
    Oe.TFOOT,
    Oe.TH,
    Oe.THEAD,
    Oe.TITLE,
    Oe.TR,
    Oe.TRACK,
    Oe.UL,
    Oe.WBR,
    Oe.XMP
  ]),
  [Ce.MATHML]: /* @__PURE__ */ new Set([Oe.MI, Oe.MO, Oe.MN, Oe.MS, Oe.MTEXT, Oe.ANNOTATION_XML]),
  [Ce.SVG]: /* @__PURE__ */ new Set([Oe.TITLE, Oe.FOREIGN_OBJECT, Oe.DESC]),
  [Ce.XLINK]: /* @__PURE__ */ new Set(),
  [Ce.XML]: /* @__PURE__ */ new Set(),
  [Ce.XMLNS]: /* @__PURE__ */ new Set()
}, Dc = /* @__PURE__ */ new Set([Oe.H1, Oe.H2, Oe.H3, Oe.H4, Oe.H5, Oe.H6]);
ce.STYLE, ce.SCRIPT, ce.XMP, ce.IFRAME, ce.NOEMBED, ce.NOFRAMES, ce.PLAINTEXT;
var W;
(function(e) {
  e[e.DATA = 0] = "DATA", e[e.RCDATA = 1] = "RCDATA", e[e.RAWTEXT = 2] = "RAWTEXT", e[e.SCRIPT_DATA = 3] = "SCRIPT_DATA", e[e.PLAINTEXT = 4] = "PLAINTEXT", e[e.TAG_OPEN = 5] = "TAG_OPEN", e[e.END_TAG_OPEN = 6] = "END_TAG_OPEN", e[e.TAG_NAME = 7] = "TAG_NAME", e[e.RCDATA_LESS_THAN_SIGN = 8] = "RCDATA_LESS_THAN_SIGN", e[e.RCDATA_END_TAG_OPEN = 9] = "RCDATA_END_TAG_OPEN", e[e.RCDATA_END_TAG_NAME = 10] = "RCDATA_END_TAG_NAME", e[e.RAWTEXT_LESS_THAN_SIGN = 11] = "RAWTEXT_LESS_THAN_SIGN", e[e.RAWTEXT_END_TAG_OPEN = 12] = "RAWTEXT_END_TAG_OPEN", e[e.RAWTEXT_END_TAG_NAME = 13] = "RAWTEXT_END_TAG_NAME", e[e.SCRIPT_DATA_LESS_THAN_SIGN = 14] = "SCRIPT_DATA_LESS_THAN_SIGN", e[e.SCRIPT_DATA_END_TAG_OPEN = 15] = "SCRIPT_DATA_END_TAG_OPEN", e[e.SCRIPT_DATA_END_TAG_NAME = 16] = "SCRIPT_DATA_END_TAG_NAME", e[e.SCRIPT_DATA_ESCAPE_START = 17] = "SCRIPT_DATA_ESCAPE_START", e[e.SCRIPT_DATA_ESCAPE_START_DASH = 18] = "SCRIPT_DATA_ESCAPE_START_DASH", e[e.SCRIPT_DATA_ESCAPED = 19] = "SCRIPT_DATA_ESCAPED", e[e.SCRIPT_DATA_ESCAPED_DASH = 20] = "SCRIPT_DATA_ESCAPED_DASH", e[e.SCRIPT_DATA_ESCAPED_DASH_DASH = 21] = "SCRIPT_DATA_ESCAPED_DASH_DASH", e[e.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN = 22] = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN", e[e.SCRIPT_DATA_ESCAPED_END_TAG_OPEN = 23] = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN", e[e.SCRIPT_DATA_ESCAPED_END_TAG_NAME = 24] = "SCRIPT_DATA_ESCAPED_END_TAG_NAME", e[e.SCRIPT_DATA_DOUBLE_ESCAPE_START = 25] = "SCRIPT_DATA_DOUBLE_ESCAPE_START", e[e.SCRIPT_DATA_DOUBLE_ESCAPED = 26] = "SCRIPT_DATA_DOUBLE_ESCAPED", e[e.SCRIPT_DATA_DOUBLE_ESCAPED_DASH = 27] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH", e[e.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH = 28] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH", e[e.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN = 29] = "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN", e[e.SCRIPT_DATA_DOUBLE_ESCAPE_END = 30] = "SCRIPT_DATA_DOUBLE_ESCAPE_END", e[e.BEFORE_ATTRIBUTE_NAME = 31] = "BEFORE_ATTRIBUTE_NAME", e[e.ATTRIBUTE_NAME = 32] = "ATTRIBUTE_NAME", e[e.AFTER_ATTRIBUTE_NAME = 33] = "AFTER_ATTRIBUTE_NAME", e[e.BEFORE_ATTRIBUTE_VALUE = 34] = "BEFORE_ATTRIBUTE_VALUE", e[e.ATTRIBUTE_VALUE_DOUBLE_QUOTED = 35] = "ATTRIBUTE_VALUE_DOUBLE_QUOTED", e[e.ATTRIBUTE_VALUE_SINGLE_QUOTED = 36] = "ATTRIBUTE_VALUE_SINGLE_QUOTED", e[e.ATTRIBUTE_VALUE_UNQUOTED = 37] = "ATTRIBUTE_VALUE_UNQUOTED", e[e.AFTER_ATTRIBUTE_VALUE_QUOTED = 38] = "AFTER_ATTRIBUTE_VALUE_QUOTED", e[e.SELF_CLOSING_START_TAG = 39] = "SELF_CLOSING_START_TAG", e[e.BOGUS_COMMENT = 40] = "BOGUS_COMMENT", e[e.MARKUP_DECLARATION_OPEN = 41] = "MARKUP_DECLARATION_OPEN", e[e.COMMENT_START = 42] = "COMMENT_START", e[e.COMMENT_START_DASH = 43] = "COMMENT_START_DASH", e[e.COMMENT = 44] = "COMMENT", e[e.COMMENT_LESS_THAN_SIGN = 45] = "COMMENT_LESS_THAN_SIGN", e[e.COMMENT_LESS_THAN_SIGN_BANG = 46] = "COMMENT_LESS_THAN_SIGN_BANG", e[e.COMMENT_LESS_THAN_SIGN_BANG_DASH = 47] = "COMMENT_LESS_THAN_SIGN_BANG_DASH", e[e.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH = 48] = "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH", e[e.COMMENT_END_DASH = 49] = "COMMENT_END_DASH", e[e.COMMENT_END = 50] = "COMMENT_END", e[e.COMMENT_END_BANG = 51] = "COMMENT_END_BANG", e[e.DOCTYPE = 52] = "DOCTYPE", e[e.BEFORE_DOCTYPE_NAME = 53] = "BEFORE_DOCTYPE_NAME", e[e.DOCTYPE_NAME = 54] = "DOCTYPE_NAME", e[e.AFTER_DOCTYPE_NAME = 55] = "AFTER_DOCTYPE_NAME", e[e.AFTER_DOCTYPE_PUBLIC_KEYWORD = 56] = "AFTER_DOCTYPE_PUBLIC_KEYWORD", e[e.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER = 57] = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER", e[e.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED = 58] = "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED", e[e.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED = 59] = "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED", e[e.AFTER_DOCTYPE_PUBLIC_IDENTIFIER = 60] = "AFTER_DOCTYPE_PUBLIC_IDENTIFIER", e[e.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS = 61] = "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS", e[e.AFTER_DOCTYPE_SYSTEM_KEYWORD = 62] = "AFTER_DOCTYPE_SYSTEM_KEYWORD", e[e.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER = 63] = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER", e[e.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED = 64] = "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED", e[e.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED = 65] = "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED", e[e.AFTER_DOCTYPE_SYSTEM_IDENTIFIER = 66] = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER", e[e.BOGUS_DOCTYPE = 67] = "BOGUS_DOCTYPE", e[e.CDATA_SECTION = 68] = "CDATA_SECTION", e[e.CDATA_SECTION_BRACKET = 69] = "CDATA_SECTION_BRACKET", e[e.CDATA_SECTION_END = 70] = "CDATA_SECTION_END", e[e.CHARACTER_REFERENCE = 71] = "CHARACTER_REFERENCE", e[e.AMBIGUOUS_AMPERSAND = 72] = "AMBIGUOUS_AMPERSAND";
})(W || (W = {}));
const pn = {
  DATA: W.DATA,
  RCDATA: W.RCDATA,
  RAWTEXT: W.RAWTEXT,
  SCRIPT_DATA: W.SCRIPT_DATA,
  PLAINTEXT: W.PLAINTEXT,
  CDATA_SECTION: W.CDATA_SECTION
};
function Ty(e) {
  return e >= R.DIGIT_0 && e <= R.DIGIT_9;
}
function eo(e) {
  return e >= R.LATIN_CAPITAL_A && e <= R.LATIN_CAPITAL_Z;
}
function _y(e) {
  return e >= R.LATIN_SMALL_A && e <= R.LATIN_SMALL_Z;
}
function $i(e) {
  return _y(e) || eo(e);
}
function l0(e) {
  return $i(e) || Ty(e);
}
function fu(e) {
  return e + 32;
}
function f2(e) {
  return e === R.SPACE || e === R.LINE_FEED || e === R.TABULATION || e === R.FORM_FEED;
}
function c0(e) {
  return f2(e) || e === R.SOLIDUS || e === R.GREATER_THAN_SIGN;
}
function Ay(e) {
  return e === R.NULL ? ye.nullCharacterReference : e > 1114111 ? ye.characterReferenceOutsideUnicodeRange : o2(e) ? ye.surrogateCharacterReference : l2(e) ? ye.noncharacterCharacterReference : u2(e) || e === R.CARRIAGE_RETURN ? ye.controlCharacterReference : null;
}
class wy {
  constructor(t, n) {
    this.options = t, this.handler = n, this.paused = !1, this.inLoop = !1, this.inForeignNode = !1, this.lastStartTagName = "", this.active = !1, this.state = W.DATA, this.returnState = W.DATA, this.entityStartPos = 0, this.consumedAfterSnapshot = -1, this.currentCharacterToken = null, this.currentToken = null, this.currentAttr = { name: "", value: "" }, this.preprocessor = new uy(n), this.currentLocation = this.getCurrentLocation(-1), this.entityDecoder = new gy(ly, (r, i) => {
      this.preprocessor.pos = this.entityStartPos + i - 1, this._flushCodePointConsumedAsCharacterReference(r);
    }, n.onParseError ? {
      missingSemicolonAfterCharacterReference: () => {
        this._err(ye.missingSemicolonAfterCharacterReference, 1);
      },
      absenceOfDigitsInNumericCharacterReference: (r) => {
        this._err(ye.absenceOfDigitsInNumericCharacterReference, this.entityStartPos - this.preprocessor.pos + r);
      },
      validateNumericCharacterReference: (r) => {
        const i = Ay(r);
        i && this._err(i, 1);
      }
    } : void 0);
  }
  //Errors
  _err(t, n = 0) {
    var r, i;
    (i = (r = this.handler).onParseError) === null || i === void 0 || i.call(r, this.preprocessor.getError(t, n));
  }
  // NOTE: `offset` may never run across line boundaries.
  getCurrentLocation(t) {
    return this.options.sourceCodeLocationInfo ? {
      startLine: this.preprocessor.line,
      startCol: this.preprocessor.col - t,
      startOffset: this.preprocessor.offset - t,
      endLine: -1,
      endCol: -1,
      endOffset: -1
    } : null;
  }
  _runParsingLoop() {
    if (!this.inLoop) {
      for (this.inLoop = !0; this.active && !this.paused; ) {
        this.consumedAfterSnapshot = 0;
        const t = this._consume();
        this._ensureHibernation() || this._callState(t);
      }
      this.inLoop = !1;
    }
  }
  //API
  pause() {
    this.paused = !0;
  }
  resume(t) {
    if (!this.paused)
      throw new Error("Parser was already resumed");
    this.paused = !1, !this.inLoop && (this._runParsingLoop(), this.paused || t == null || t());
  }
  write(t, n, r) {
    this.active = !0, this.preprocessor.write(t, n), this._runParsingLoop(), this.paused || r == null || r();
  }
  insertHtmlAtCurrentPos(t) {
    this.active = !0, this.preprocessor.insertHtmlAtCurrentPos(t), this._runParsingLoop();
  }
  //Hibernation
  _ensureHibernation() {
    return this.preprocessor.endOfChunkHit ? (this.preprocessor.retreat(this.consumedAfterSnapshot), this.consumedAfterSnapshot = 0, this.active = !1, !0) : !1;
  }
  //Consumption
  _consume() {
    return this.consumedAfterSnapshot++, this.preprocessor.advance();
  }
  _advanceBy(t) {
    this.consumedAfterSnapshot += t;
    for (let n = 0; n < t; n++)
      this.preprocessor.advance();
  }
  _consumeSequenceIfMatch(t, n) {
    return this.preprocessor.startsWith(t, n) ? (this._advanceBy(t.length - 1), !0) : !1;
  }
  //Token creation
  _createStartTagToken() {
    this.currentToken = {
      type: St.START_TAG,
      tagName: "",
      tagID: m.UNKNOWN,
      selfClosing: !1,
      ackSelfClosing: !1,
      attrs: [],
      location: this.getCurrentLocation(1)
    };
  }
  _createEndTagToken() {
    this.currentToken = {
      type: St.END_TAG,
      tagName: "",
      tagID: m.UNKNOWN,
      selfClosing: !1,
      ackSelfClosing: !1,
      attrs: [],
      location: this.getCurrentLocation(2)
    };
  }
  _createCommentToken(t) {
    this.currentToken = {
      type: St.COMMENT,
      data: "",
      location: this.getCurrentLocation(t)
    };
  }
  _createDoctypeToken(t) {
    this.currentToken = {
      type: St.DOCTYPE,
      name: t,
      forceQuirks: !1,
      publicId: null,
      systemId: null,
      location: this.currentLocation
    };
  }
  _createCharacterToken(t, n) {
    this.currentCharacterToken = {
      type: t,
      chars: n,
      location: this.currentLocation
    };
  }
  //Tag attributes
  _createAttr(t) {
    this.currentAttr = {
      name: t,
      value: ""
    }, this.currentLocation = this.getCurrentLocation(0);
  }
  _leaveAttrName() {
    var t, n;
    const r = this.currentToken;
    if (c2(r, this.currentAttr.name) === null) {
      if (r.attrs.push(this.currentAttr), r.location && this.currentLocation) {
        const i = (t = (n = r.location).attrs) !== null && t !== void 0 ? t : n.attrs = /* @__PURE__ */ Object.create(null);
        i[this.currentAttr.name] = this.currentLocation, this._leaveAttrValue();
      }
    } else
      this._err(ye.duplicateAttribute);
  }
  _leaveAttrValue() {
    this.currentLocation && (this.currentLocation.endLine = this.preprocessor.line, this.currentLocation.endCol = this.preprocessor.col, this.currentLocation.endOffset = this.preprocessor.offset);
  }
  //Token emission
  prepareToken(t) {
    this._emitCurrentCharacterToken(t.location), this.currentToken = null, t.location && (t.location.endLine = this.preprocessor.line, t.location.endCol = this.preprocessor.col + 1, t.location.endOffset = this.preprocessor.offset + 1), this.currentLocation = this.getCurrentLocation(-1);
  }
  emitCurrentTagToken() {
    const t = this.currentToken;
    this.prepareToken(t), t.tagID = ms(t.tagName), t.type === St.START_TAG ? (this.lastStartTagName = t.tagName, this.handler.onStartTag(t)) : (t.attrs.length > 0 && this._err(ye.endTagWithAttributes), t.selfClosing && this._err(ye.endTagWithTrailingSolidus), this.handler.onEndTag(t)), this.preprocessor.dropParsedChunk();
  }
  emitCurrentComment(t) {
    this.prepareToken(t), this.handler.onComment(t), this.preprocessor.dropParsedChunk();
  }
  emitCurrentDoctype(t) {
    this.prepareToken(t), this.handler.onDoctype(t), this.preprocessor.dropParsedChunk();
  }
  _emitCurrentCharacterToken(t) {
    if (this.currentCharacterToken) {
      switch (t && this.currentCharacterToken.location && (this.currentCharacterToken.location.endLine = t.startLine, this.currentCharacterToken.location.endCol = t.startCol, this.currentCharacterToken.location.endOffset = t.startOffset), this.currentCharacterToken.type) {
        case St.CHARACTER: {
          this.handler.onCharacter(this.currentCharacterToken);
          break;
        }
        case St.NULL_CHARACTER: {
          this.handler.onNullCharacter(this.currentCharacterToken);
          break;
        }
        case St.WHITESPACE_CHARACTER: {
          this.handler.onWhitespaceCharacter(this.currentCharacterToken);
          break;
        }
      }
      this.currentCharacterToken = null;
    }
  }
  _emitEOFToken() {
    const t = this.getCurrentLocation(0);
    t && (t.endLine = t.startLine, t.endCol = t.startCol, t.endOffset = t.startOffset), this._emitCurrentCharacterToken(t), this.handler.onEof({ type: St.EOF, location: t }), this.active = !1;
  }
  //Characters emission
  //OPTIMIZATION: The specification uses only one type of character token (one token per character).
  //This causes a huge memory overhead and a lot of unnecessary parser loops. parse5 uses 3 groups of characters.
  //If we have a sequence of characters that belong to the same group, the parser can process it
  //as a single solid character token.
  //So, there are 3 types of character tokens in parse5:
  //1)TokenType.NULL_CHARACTER - \u0000-character sequences (e.g. '\u0000\u0000\u0000')
  //2)TokenType.WHITESPACE_CHARACTER - any whitespace/new-line character sequences (e.g. '\n  \r\t   \f')
  //3)TokenType.CHARACTER - any character sequence which don't belong to groups 1 and 2 (e.g. 'abcdef1234@@#$%^')
  _appendCharToCurrentCharacterToken(t, n) {
    if (this.currentCharacterToken)
      if (this.currentCharacterToken.type === t) {
        this.currentCharacterToken.chars += n;
        return;
      } else
        this.currentLocation = this.getCurrentLocation(0), this._emitCurrentCharacterToken(this.currentLocation), this.preprocessor.dropParsedChunk();
    this._createCharacterToken(t, n);
  }
  _emitCodePoint(t) {
    const n = f2(t) ? St.WHITESPACE_CHARACTER : t === R.NULL ? St.NULL_CHARACTER : St.CHARACTER;
    this._appendCharToCurrentCharacterToken(n, String.fromCodePoint(t));
  }
  //NOTE: used when we emit characters explicitly.
  //This is always for non-whitespace and non-null characters, which allows us to avoid additional checks.
  _emitChars(t) {
    this._appendCharToCurrentCharacterToken(St.CHARACTER, t);
  }
  // Character reference helpers
  _startCharacterReference() {
    this.returnState = this.state, this.state = W.CHARACTER_REFERENCE, this.entityStartPos = this.preprocessor.pos, this.entityDecoder.startEntity(this._isCharacterReferenceInAttribute() ? vi.Attribute : vi.Legacy);
  }
  _isCharacterReferenceInAttribute() {
    return this.returnState === W.ATTRIBUTE_VALUE_DOUBLE_QUOTED || this.returnState === W.ATTRIBUTE_VALUE_SINGLE_QUOTED || this.returnState === W.ATTRIBUTE_VALUE_UNQUOTED;
  }
  _flushCodePointConsumedAsCharacterReference(t) {
    this._isCharacterReferenceInAttribute() ? this.currentAttr.value += String.fromCodePoint(t) : this._emitCodePoint(t);
  }
  // Calling states this way turns out to be much faster than any other approach.
  _callState(t) {
    switch (this.state) {
      case W.DATA: {
        this._stateData(t);
        break;
      }
      case W.RCDATA: {
        this._stateRcdata(t);
        break;
      }
      case W.RAWTEXT: {
        this._stateRawtext(t);
        break;
      }
      case W.SCRIPT_DATA: {
        this._stateScriptData(t);
        break;
      }
      case W.PLAINTEXT: {
        this._statePlaintext(t);
        break;
      }
      case W.TAG_OPEN: {
        this._stateTagOpen(t);
        break;
      }
      case W.END_TAG_OPEN: {
        this._stateEndTagOpen(t);
        break;
      }
      case W.TAG_NAME: {
        this._stateTagName(t);
        break;
      }
      case W.RCDATA_LESS_THAN_SIGN: {
        this._stateRcdataLessThanSign(t);
        break;
      }
      case W.RCDATA_END_TAG_OPEN: {
        this._stateRcdataEndTagOpen(t);
        break;
      }
      case W.RCDATA_END_TAG_NAME: {
        this._stateRcdataEndTagName(t);
        break;
      }
      case W.RAWTEXT_LESS_THAN_SIGN: {
        this._stateRawtextLessThanSign(t);
        break;
      }
      case W.RAWTEXT_END_TAG_OPEN: {
        this._stateRawtextEndTagOpen(t);
        break;
      }
      case W.RAWTEXT_END_TAG_NAME: {
        this._stateRawtextEndTagName(t);
        break;
      }
      case W.SCRIPT_DATA_LESS_THAN_SIGN: {
        this._stateScriptDataLessThanSign(t);
        break;
      }
      case W.SCRIPT_DATA_END_TAG_OPEN: {
        this._stateScriptDataEndTagOpen(t);
        break;
      }
      case W.SCRIPT_DATA_END_TAG_NAME: {
        this._stateScriptDataEndTagName(t);
        break;
      }
      case W.SCRIPT_DATA_ESCAPE_START: {
        this._stateScriptDataEscapeStart(t);
        break;
      }
      case W.SCRIPT_DATA_ESCAPE_START_DASH: {
        this._stateScriptDataEscapeStartDash(t);
        break;
      }
      case W.SCRIPT_DATA_ESCAPED: {
        this._stateScriptDataEscaped(t);
        break;
      }
      case W.SCRIPT_DATA_ESCAPED_DASH: {
        this._stateScriptDataEscapedDash(t);
        break;
      }
      case W.SCRIPT_DATA_ESCAPED_DASH_DASH: {
        this._stateScriptDataEscapedDashDash(t);
        break;
      }
      case W.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataEscapedLessThanSign(t);
        break;
      }
      case W.SCRIPT_DATA_ESCAPED_END_TAG_OPEN: {
        this._stateScriptDataEscapedEndTagOpen(t);
        break;
      }
      case W.SCRIPT_DATA_ESCAPED_END_TAG_NAME: {
        this._stateScriptDataEscapedEndTagName(t);
        break;
      }
      case W.SCRIPT_DATA_DOUBLE_ESCAPE_START: {
        this._stateScriptDataDoubleEscapeStart(t);
        break;
      }
      case W.SCRIPT_DATA_DOUBLE_ESCAPED: {
        this._stateScriptDataDoubleEscaped(t);
        break;
      }
      case W.SCRIPT_DATA_DOUBLE_ESCAPED_DASH: {
        this._stateScriptDataDoubleEscapedDash(t);
        break;
      }
      case W.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH: {
        this._stateScriptDataDoubleEscapedDashDash(t);
        break;
      }
      case W.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataDoubleEscapedLessThanSign(t);
        break;
      }
      case W.SCRIPT_DATA_DOUBLE_ESCAPE_END: {
        this._stateScriptDataDoubleEscapeEnd(t);
        break;
      }
      case W.BEFORE_ATTRIBUTE_NAME: {
        this._stateBeforeAttributeName(t);
        break;
      }
      case W.ATTRIBUTE_NAME: {
        this._stateAttributeName(t);
        break;
      }
      case W.AFTER_ATTRIBUTE_NAME: {
        this._stateAfterAttributeName(t);
        break;
      }
      case W.BEFORE_ATTRIBUTE_VALUE: {
        this._stateBeforeAttributeValue(t);
        break;
      }
      case W.ATTRIBUTE_VALUE_DOUBLE_QUOTED: {
        this._stateAttributeValueDoubleQuoted(t);
        break;
      }
      case W.ATTRIBUTE_VALUE_SINGLE_QUOTED: {
        this._stateAttributeValueSingleQuoted(t);
        break;
      }
      case W.ATTRIBUTE_VALUE_UNQUOTED: {
        this._stateAttributeValueUnquoted(t);
        break;
      }
      case W.AFTER_ATTRIBUTE_VALUE_QUOTED: {
        this._stateAfterAttributeValueQuoted(t);
        break;
      }
      case W.SELF_CLOSING_START_TAG: {
        this._stateSelfClosingStartTag(t);
        break;
      }
      case W.BOGUS_COMMENT: {
        this._stateBogusComment(t);
        break;
      }
      case W.MARKUP_DECLARATION_OPEN: {
        this._stateMarkupDeclarationOpen(t);
        break;
      }
      case W.COMMENT_START: {
        this._stateCommentStart(t);
        break;
      }
      case W.COMMENT_START_DASH: {
        this._stateCommentStartDash(t);
        break;
      }
      case W.COMMENT: {
        this._stateComment(t);
        break;
      }
      case W.COMMENT_LESS_THAN_SIGN: {
        this._stateCommentLessThanSign(t);
        break;
      }
      case W.COMMENT_LESS_THAN_SIGN_BANG: {
        this._stateCommentLessThanSignBang(t);
        break;
      }
      case W.COMMENT_LESS_THAN_SIGN_BANG_DASH: {
        this._stateCommentLessThanSignBangDash(t);
        break;
      }
      case W.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH: {
        this._stateCommentLessThanSignBangDashDash(t);
        break;
      }
      case W.COMMENT_END_DASH: {
        this._stateCommentEndDash(t);
        break;
      }
      case W.COMMENT_END: {
        this._stateCommentEnd(t);
        break;
      }
      case W.COMMENT_END_BANG: {
        this._stateCommentEndBang(t);
        break;
      }
      case W.DOCTYPE: {
        this._stateDoctype(t);
        break;
      }
      case W.BEFORE_DOCTYPE_NAME: {
        this._stateBeforeDoctypeName(t);
        break;
      }
      case W.DOCTYPE_NAME: {
        this._stateDoctypeName(t);
        break;
      }
      case W.AFTER_DOCTYPE_NAME: {
        this._stateAfterDoctypeName(t);
        break;
      }
      case W.AFTER_DOCTYPE_PUBLIC_KEYWORD: {
        this._stateAfterDoctypePublicKeyword(t);
        break;
      }
      case W.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateBeforeDoctypePublicIdentifier(t);
        break;
      }
      case W.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypePublicIdentifierDoubleQuoted(t);
        break;
      }
      case W.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypePublicIdentifierSingleQuoted(t);
        break;
      }
      case W.AFTER_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateAfterDoctypePublicIdentifier(t);
        break;
      }
      case W.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS: {
        this._stateBetweenDoctypePublicAndSystemIdentifiers(t);
        break;
      }
      case W.AFTER_DOCTYPE_SYSTEM_KEYWORD: {
        this._stateAfterDoctypeSystemKeyword(t);
        break;
      }
      case W.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateBeforeDoctypeSystemIdentifier(t);
        break;
      }
      case W.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypeSystemIdentifierDoubleQuoted(t);
        break;
      }
      case W.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypeSystemIdentifierSingleQuoted(t);
        break;
      }
      case W.AFTER_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateAfterDoctypeSystemIdentifier(t);
        break;
      }
      case W.BOGUS_DOCTYPE: {
        this._stateBogusDoctype(t);
        break;
      }
      case W.CDATA_SECTION: {
        this._stateCdataSection(t);
        break;
      }
      case W.CDATA_SECTION_BRACKET: {
        this._stateCdataSectionBracket(t);
        break;
      }
      case W.CDATA_SECTION_END: {
        this._stateCdataSectionEnd(t);
        break;
      }
      case W.CHARACTER_REFERENCE: {
        this._stateCharacterReference();
        break;
      }
      case W.AMBIGUOUS_AMPERSAND: {
        this._stateAmbiguousAmpersand(t);
        break;
      }
      default:
        throw new Error("Unknown state");
    }
  }
  // State machine
  // Data state
  //------------------------------------------------------------------
  _stateData(t) {
    switch (t) {
      case R.LESS_THAN_SIGN: {
        this.state = W.TAG_OPEN;
        break;
      }
      case R.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case R.NULL: {
        this._err(ye.unexpectedNullCharacter), this._emitCodePoint(t);
        break;
      }
      case R.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  //  RCDATA state
  //------------------------------------------------------------------
  _stateRcdata(t) {
    switch (t) {
      case R.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case R.LESS_THAN_SIGN: {
        this.state = W.RCDATA_LESS_THAN_SIGN;
        break;
      }
      case R.NULL: {
        this._err(ye.unexpectedNullCharacter), this._emitChars(en);
        break;
      }
      case R.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // RAWTEXT state
  //------------------------------------------------------------------
  _stateRawtext(t) {
    switch (t) {
      case R.LESS_THAN_SIGN: {
        this.state = W.RAWTEXT_LESS_THAN_SIGN;
        break;
      }
      case R.NULL: {
        this._err(ye.unexpectedNullCharacter), this._emitChars(en);
        break;
      }
      case R.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // Script data state
  //------------------------------------------------------------------
  _stateScriptData(t) {
    switch (t) {
      case R.LESS_THAN_SIGN: {
        this.state = W.SCRIPT_DATA_LESS_THAN_SIGN;
        break;
      }
      case R.NULL: {
        this._err(ye.unexpectedNullCharacter), this._emitChars(en);
        break;
      }
      case R.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // PLAINTEXT state
  //------------------------------------------------------------------
  _statePlaintext(t) {
    switch (t) {
      case R.NULL: {
        this._err(ye.unexpectedNullCharacter), this._emitChars(en);
        break;
      }
      case R.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // Tag open state
  //------------------------------------------------------------------
  _stateTagOpen(t) {
    if ($i(t))
      this._createStartTagToken(), this.state = W.TAG_NAME, this._stateTagName(t);
    else
      switch (t) {
        case R.EXCLAMATION_MARK: {
          this.state = W.MARKUP_DECLARATION_OPEN;
          break;
        }
        case R.SOLIDUS: {
          this.state = W.END_TAG_OPEN;
          break;
        }
        case R.QUESTION_MARK: {
          this._err(ye.unexpectedQuestionMarkInsteadOfTagName), this._createCommentToken(1), this.state = W.BOGUS_COMMENT, this._stateBogusComment(t);
          break;
        }
        case R.EOF: {
          this._err(ye.eofBeforeTagName), this._emitChars("<"), this._emitEOFToken();
          break;
        }
        default:
          this._err(ye.invalidFirstCharacterOfTagName), this._emitChars("<"), this.state = W.DATA, this._stateData(t);
      }
  }
  // End tag open state
  //------------------------------------------------------------------
  _stateEndTagOpen(t) {
    if ($i(t))
      this._createEndTagToken(), this.state = W.TAG_NAME, this._stateTagName(t);
    else
      switch (t) {
        case R.GREATER_THAN_SIGN: {
          this._err(ye.missingEndTagName), this.state = W.DATA;
          break;
        }
        case R.EOF: {
          this._err(ye.eofBeforeTagName), this._emitChars("</"), this._emitEOFToken();
          break;
        }
        default:
          this._err(ye.invalidFirstCharacterOfTagName), this._createCommentToken(2), this.state = W.BOGUS_COMMENT, this._stateBogusComment(t);
      }
  }
  // Tag name state
  //------------------------------------------------------------------
  _stateTagName(t) {
    const n = this.currentToken;
    switch (t) {
      case R.SPACE:
      case R.LINE_FEED:
      case R.TABULATION:
      case R.FORM_FEED: {
        this.state = W.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case R.SOLIDUS: {
        this.state = W.SELF_CLOSING_START_TAG;
        break;
      }
      case R.GREATER_THAN_SIGN: {
        this.state = W.DATA, this.emitCurrentTagToken();
        break;
      }
      case R.NULL: {
        this._err(ye.unexpectedNullCharacter), n.tagName += en;
        break;
      }
      case R.EOF: {
        this._err(ye.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        n.tagName += String.fromCodePoint(eo(t) ? fu(t) : t);
    }
  }
  // RCDATA less-than sign state
  //------------------------------------------------------------------
  _stateRcdataLessThanSign(t) {
    t === R.SOLIDUS ? this.state = W.RCDATA_END_TAG_OPEN : (this._emitChars("<"), this.state = W.RCDATA, this._stateRcdata(t));
  }
  // RCDATA end tag open state
  //------------------------------------------------------------------
  _stateRcdataEndTagOpen(t) {
    $i(t) ? (this.state = W.RCDATA_END_TAG_NAME, this._stateRcdataEndTagName(t)) : (this._emitChars("</"), this.state = W.RCDATA, this._stateRcdata(t));
  }
  handleSpecialEndTag(t) {
    if (!this.preprocessor.startsWith(this.lastStartTagName, !1))
      return !this._ensureHibernation();
    this._createEndTagToken();
    const n = this.currentToken;
    switch (n.tagName = this.lastStartTagName, this.preprocessor.peek(this.lastStartTagName.length)) {
      case R.SPACE:
      case R.LINE_FEED:
      case R.TABULATION:
      case R.FORM_FEED:
        return this._advanceBy(this.lastStartTagName.length), this.state = W.BEFORE_ATTRIBUTE_NAME, !1;
      case R.SOLIDUS:
        return this._advanceBy(this.lastStartTagName.length), this.state = W.SELF_CLOSING_START_TAG, !1;
      case R.GREATER_THAN_SIGN:
        return this._advanceBy(this.lastStartTagName.length), this.emitCurrentTagToken(), this.state = W.DATA, !1;
      default:
        return !this._ensureHibernation();
    }
  }
  // RCDATA end tag name state
  //------------------------------------------------------------------
  _stateRcdataEndTagName(t) {
    this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = W.RCDATA, this._stateRcdata(t));
  }
  // RAWTEXT less-than sign state
  //------------------------------------------------------------------
  _stateRawtextLessThanSign(t) {
    t === R.SOLIDUS ? this.state = W.RAWTEXT_END_TAG_OPEN : (this._emitChars("<"), this.state = W.RAWTEXT, this._stateRawtext(t));
  }
  // RAWTEXT end tag open state
  //------------------------------------------------------------------
  _stateRawtextEndTagOpen(t) {
    $i(t) ? (this.state = W.RAWTEXT_END_TAG_NAME, this._stateRawtextEndTagName(t)) : (this._emitChars("</"), this.state = W.RAWTEXT, this._stateRawtext(t));
  }
  // RAWTEXT end tag name state
  //------------------------------------------------------------------
  _stateRawtextEndTagName(t) {
    this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = W.RAWTEXT, this._stateRawtext(t));
  }
  // Script data less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataLessThanSign(t) {
    switch (t) {
      case R.SOLIDUS: {
        this.state = W.SCRIPT_DATA_END_TAG_OPEN;
        break;
      }
      case R.EXCLAMATION_MARK: {
        this.state = W.SCRIPT_DATA_ESCAPE_START, this._emitChars("<!");
        break;
      }
      default:
        this._emitChars("<"), this.state = W.SCRIPT_DATA, this._stateScriptData(t);
    }
  }
  // Script data end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEndTagOpen(t) {
    $i(t) ? (this.state = W.SCRIPT_DATA_END_TAG_NAME, this._stateScriptDataEndTagName(t)) : (this._emitChars("</"), this.state = W.SCRIPT_DATA, this._stateScriptData(t));
  }
  // Script data end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEndTagName(t) {
    this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = W.SCRIPT_DATA, this._stateScriptData(t));
  }
  // Script data escape start state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStart(t) {
    t === R.HYPHEN_MINUS ? (this.state = W.SCRIPT_DATA_ESCAPE_START_DASH, this._emitChars("-")) : (this.state = W.SCRIPT_DATA, this._stateScriptData(t));
  }
  // Script data escape start dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStartDash(t) {
    t === R.HYPHEN_MINUS ? (this.state = W.SCRIPT_DATA_ESCAPED_DASH_DASH, this._emitChars("-")) : (this.state = W.SCRIPT_DATA, this._stateScriptData(t));
  }
  // Script data escaped state
  //------------------------------------------------------------------
  _stateScriptDataEscaped(t) {
    switch (t) {
      case R.HYPHEN_MINUS: {
        this.state = W.SCRIPT_DATA_ESCAPED_DASH, this._emitChars("-");
        break;
      }
      case R.LESS_THAN_SIGN: {
        this.state = W.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case R.NULL: {
        this._err(ye.unexpectedNullCharacter), this._emitChars(en);
        break;
      }
      case R.EOF: {
        this._err(ye.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // Script data escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDash(t) {
    switch (t) {
      case R.HYPHEN_MINUS: {
        this.state = W.SCRIPT_DATA_ESCAPED_DASH_DASH, this._emitChars("-");
        break;
      }
      case R.LESS_THAN_SIGN: {
        this.state = W.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case R.NULL: {
        this._err(ye.unexpectedNullCharacter), this.state = W.SCRIPT_DATA_ESCAPED, this._emitChars(en);
        break;
      }
      case R.EOF: {
        this._err(ye.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = W.SCRIPT_DATA_ESCAPED, this._emitCodePoint(t);
    }
  }
  // Script data escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDashDash(t) {
    switch (t) {
      case R.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case R.LESS_THAN_SIGN: {
        this.state = W.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case R.GREATER_THAN_SIGN: {
        this.state = W.SCRIPT_DATA, this._emitChars(">");
        break;
      }
      case R.NULL: {
        this._err(ye.unexpectedNullCharacter), this.state = W.SCRIPT_DATA_ESCAPED, this._emitChars(en);
        break;
      }
      case R.EOF: {
        this._err(ye.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = W.SCRIPT_DATA_ESCAPED, this._emitCodePoint(t);
    }
  }
  // Script data escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataEscapedLessThanSign(t) {
    t === R.SOLIDUS ? this.state = W.SCRIPT_DATA_ESCAPED_END_TAG_OPEN : $i(t) ? (this._emitChars("<"), this.state = W.SCRIPT_DATA_DOUBLE_ESCAPE_START, this._stateScriptDataDoubleEscapeStart(t)) : (this._emitChars("<"), this.state = W.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t));
  }
  // Script data escaped end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagOpen(t) {
    $i(t) ? (this.state = W.SCRIPT_DATA_ESCAPED_END_TAG_NAME, this._stateScriptDataEscapedEndTagName(t)) : (this._emitChars("</"), this.state = W.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t));
  }
  // Script data escaped end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagName(t) {
    this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = W.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t));
  }
  // Script data double escape start state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeStart(t) {
    if (this.preprocessor.startsWith(Jn.SCRIPT, !1) && c0(this.preprocessor.peek(Jn.SCRIPT.length))) {
      this._emitCodePoint(t);
      for (let n = 0; n < Jn.SCRIPT.length; n++)
        this._emitCodePoint(this._consume());
      this.state = W.SCRIPT_DATA_DOUBLE_ESCAPED;
    } else this._ensureHibernation() || (this.state = W.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t));
  }
  // Script data double escaped state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscaped(t) {
    switch (t) {
      case R.HYPHEN_MINUS: {
        this.state = W.SCRIPT_DATA_DOUBLE_ESCAPED_DASH, this._emitChars("-");
        break;
      }
      case R.LESS_THAN_SIGN: {
        this.state = W.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case R.NULL: {
        this._err(ye.unexpectedNullCharacter), this._emitChars(en);
        break;
      }
      case R.EOF: {
        this._err(ye.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // Script data double escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDash(t) {
    switch (t) {
      case R.HYPHEN_MINUS: {
        this.state = W.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH, this._emitChars("-");
        break;
      }
      case R.LESS_THAN_SIGN: {
        this.state = W.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case R.NULL: {
        this._err(ye.unexpectedNullCharacter), this.state = W.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitChars(en);
        break;
      }
      case R.EOF: {
        this._err(ye.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = W.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitCodePoint(t);
    }
  }
  // Script data double escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDashDash(t) {
    switch (t) {
      case R.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case R.LESS_THAN_SIGN: {
        this.state = W.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case R.GREATER_THAN_SIGN: {
        this.state = W.SCRIPT_DATA, this._emitChars(">");
        break;
      }
      case R.NULL: {
        this._err(ye.unexpectedNullCharacter), this.state = W.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitChars(en);
        break;
      }
      case R.EOF: {
        this._err(ye.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = W.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitCodePoint(t);
    }
  }
  // Script data double escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedLessThanSign(t) {
    t === R.SOLIDUS ? (this.state = W.SCRIPT_DATA_DOUBLE_ESCAPE_END, this._emitChars("/")) : (this.state = W.SCRIPT_DATA_DOUBLE_ESCAPED, this._stateScriptDataDoubleEscaped(t));
  }
  // Script data double escape end state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeEnd(t) {
    if (this.preprocessor.startsWith(Jn.SCRIPT, !1) && c0(this.preprocessor.peek(Jn.SCRIPT.length))) {
      this._emitCodePoint(t);
      for (let n = 0; n < Jn.SCRIPT.length; n++)
        this._emitCodePoint(this._consume());
      this.state = W.SCRIPT_DATA_ESCAPED;
    } else this._ensureHibernation() || (this.state = W.SCRIPT_DATA_DOUBLE_ESCAPED, this._stateScriptDataDoubleEscaped(t));
  }
  // Before attribute name state
  //------------------------------------------------------------------
  _stateBeforeAttributeName(t) {
    switch (t) {
      case R.SPACE:
      case R.LINE_FEED:
      case R.TABULATION:
      case R.FORM_FEED:
        break;
      case R.SOLIDUS:
      case R.GREATER_THAN_SIGN:
      case R.EOF: {
        this.state = W.AFTER_ATTRIBUTE_NAME, this._stateAfterAttributeName(t);
        break;
      }
      case R.EQUALS_SIGN: {
        this._err(ye.unexpectedEqualsSignBeforeAttributeName), this._createAttr("="), this.state = W.ATTRIBUTE_NAME;
        break;
      }
      default:
        this._createAttr(""), this.state = W.ATTRIBUTE_NAME, this._stateAttributeName(t);
    }
  }
  // Attribute name state
  //------------------------------------------------------------------
  _stateAttributeName(t) {
    switch (t) {
      case R.SPACE:
      case R.LINE_FEED:
      case R.TABULATION:
      case R.FORM_FEED:
      case R.SOLIDUS:
      case R.GREATER_THAN_SIGN:
      case R.EOF: {
        this._leaveAttrName(), this.state = W.AFTER_ATTRIBUTE_NAME, this._stateAfterAttributeName(t);
        break;
      }
      case R.EQUALS_SIGN: {
        this._leaveAttrName(), this.state = W.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case R.QUOTATION_MARK:
      case R.APOSTROPHE:
      case R.LESS_THAN_SIGN: {
        this._err(ye.unexpectedCharacterInAttributeName), this.currentAttr.name += String.fromCodePoint(t);
        break;
      }
      case R.NULL: {
        this._err(ye.unexpectedNullCharacter), this.currentAttr.name += en;
        break;
      }
      default:
        this.currentAttr.name += String.fromCodePoint(eo(t) ? fu(t) : t);
    }
  }
  // After attribute name state
  //------------------------------------------------------------------
  _stateAfterAttributeName(t) {
    switch (t) {
      case R.SPACE:
      case R.LINE_FEED:
      case R.TABULATION:
      case R.FORM_FEED:
        break;
      case R.SOLIDUS: {
        this.state = W.SELF_CLOSING_START_TAG;
        break;
      }
      case R.EQUALS_SIGN: {
        this.state = W.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case R.GREATER_THAN_SIGN: {
        this.state = W.DATA, this.emitCurrentTagToken();
        break;
      }
      case R.EOF: {
        this._err(ye.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._createAttr(""), this.state = W.ATTRIBUTE_NAME, this._stateAttributeName(t);
    }
  }
  // Before attribute value state
  //------------------------------------------------------------------
  _stateBeforeAttributeValue(t) {
    switch (t) {
      case R.SPACE:
      case R.LINE_FEED:
      case R.TABULATION:
      case R.FORM_FEED:
        break;
      case R.QUOTATION_MARK: {
        this.state = W.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
        break;
      }
      case R.APOSTROPHE: {
        this.state = W.ATTRIBUTE_VALUE_SINGLE_QUOTED;
        break;
      }
      case R.GREATER_THAN_SIGN: {
        this._err(ye.missingAttributeValue), this.state = W.DATA, this.emitCurrentTagToken();
        break;
      }
      default:
        this.state = W.ATTRIBUTE_VALUE_UNQUOTED, this._stateAttributeValueUnquoted(t);
    }
  }
  // Attribute value (double-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueDoubleQuoted(t) {
    switch (t) {
      case R.QUOTATION_MARK: {
        this.state = W.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case R.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case R.NULL: {
        this._err(ye.unexpectedNullCharacter), this.currentAttr.value += en;
        break;
      }
      case R.EOF: {
        this._err(ye.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(t);
    }
  }
  // Attribute value (single-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueSingleQuoted(t) {
    switch (t) {
      case R.APOSTROPHE: {
        this.state = W.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case R.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case R.NULL: {
        this._err(ye.unexpectedNullCharacter), this.currentAttr.value += en;
        break;
      }
      case R.EOF: {
        this._err(ye.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(t);
    }
  }
  // Attribute value (unquoted) state
  //------------------------------------------------------------------
  _stateAttributeValueUnquoted(t) {
    switch (t) {
      case R.SPACE:
      case R.LINE_FEED:
      case R.TABULATION:
      case R.FORM_FEED: {
        this._leaveAttrValue(), this.state = W.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case R.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case R.GREATER_THAN_SIGN: {
        this._leaveAttrValue(), this.state = W.DATA, this.emitCurrentTagToken();
        break;
      }
      case R.NULL: {
        this._err(ye.unexpectedNullCharacter), this.currentAttr.value += en;
        break;
      }
      case R.QUOTATION_MARK:
      case R.APOSTROPHE:
      case R.LESS_THAN_SIGN:
      case R.EQUALS_SIGN:
      case R.GRAVE_ACCENT: {
        this._err(ye.unexpectedCharacterInUnquotedAttributeValue), this.currentAttr.value += String.fromCodePoint(t);
        break;
      }
      case R.EOF: {
        this._err(ye.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(t);
    }
  }
  // After attribute value (quoted) state
  //------------------------------------------------------------------
  _stateAfterAttributeValueQuoted(t) {
    switch (t) {
      case R.SPACE:
      case R.LINE_FEED:
      case R.TABULATION:
      case R.FORM_FEED: {
        this._leaveAttrValue(), this.state = W.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case R.SOLIDUS: {
        this._leaveAttrValue(), this.state = W.SELF_CLOSING_START_TAG;
        break;
      }
      case R.GREATER_THAN_SIGN: {
        this._leaveAttrValue(), this.state = W.DATA, this.emitCurrentTagToken();
        break;
      }
      case R.EOF: {
        this._err(ye.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._err(ye.missingWhitespaceBetweenAttributes), this.state = W.BEFORE_ATTRIBUTE_NAME, this._stateBeforeAttributeName(t);
    }
  }
  // Self-closing start tag state
  //------------------------------------------------------------------
  _stateSelfClosingStartTag(t) {
    switch (t) {
      case R.GREATER_THAN_SIGN: {
        const n = this.currentToken;
        n.selfClosing = !0, this.state = W.DATA, this.emitCurrentTagToken();
        break;
      }
      case R.EOF: {
        this._err(ye.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._err(ye.unexpectedSolidusInTag), this.state = W.BEFORE_ATTRIBUTE_NAME, this._stateBeforeAttributeName(t);
    }
  }
  // Bogus comment state
  //------------------------------------------------------------------
  _stateBogusComment(t) {
    const n = this.currentToken;
    switch (t) {
      case R.GREATER_THAN_SIGN: {
        this.state = W.DATA, this.emitCurrentComment(n);
        break;
      }
      case R.EOF: {
        this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      case R.NULL: {
        this._err(ye.unexpectedNullCharacter), n.data += en;
        break;
      }
      default:
        n.data += String.fromCodePoint(t);
    }
  }
  // Markup declaration open state
  //------------------------------------------------------------------
  _stateMarkupDeclarationOpen(t) {
    this._consumeSequenceIfMatch(Jn.DASH_DASH, !0) ? (this._createCommentToken(Jn.DASH_DASH.length + 1), this.state = W.COMMENT_START) : this._consumeSequenceIfMatch(Jn.DOCTYPE, !1) ? (this.currentLocation = this.getCurrentLocation(Jn.DOCTYPE.length + 1), this.state = W.DOCTYPE) : this._consumeSequenceIfMatch(Jn.CDATA_START, !0) ? this.inForeignNode ? this.state = W.CDATA_SECTION : (this._err(ye.cdataInHtmlContent), this._createCommentToken(Jn.CDATA_START.length + 1), this.currentToken.data = "[CDATA[", this.state = W.BOGUS_COMMENT) : this._ensureHibernation() || (this._err(ye.incorrectlyOpenedComment), this._createCommentToken(2), this.state = W.BOGUS_COMMENT, this._stateBogusComment(t));
  }
  // Comment start state
  //------------------------------------------------------------------
  _stateCommentStart(t) {
    switch (t) {
      case R.HYPHEN_MINUS: {
        this.state = W.COMMENT_START_DASH;
        break;
      }
      case R.GREATER_THAN_SIGN: {
        this._err(ye.abruptClosingOfEmptyComment), this.state = W.DATA;
        const n = this.currentToken;
        this.emitCurrentComment(n);
        break;
      }
      default:
        this.state = W.COMMENT, this._stateComment(t);
    }
  }
  // Comment start dash state
  //------------------------------------------------------------------
  _stateCommentStartDash(t) {
    const n = this.currentToken;
    switch (t) {
      case R.HYPHEN_MINUS: {
        this.state = W.COMMENT_END;
        break;
      }
      case R.GREATER_THAN_SIGN: {
        this._err(ye.abruptClosingOfEmptyComment), this.state = W.DATA, this.emitCurrentComment(n);
        break;
      }
      case R.EOF: {
        this._err(ye.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += "-", this.state = W.COMMENT, this._stateComment(t);
    }
  }
  // Comment state
  //------------------------------------------------------------------
  _stateComment(t) {
    const n = this.currentToken;
    switch (t) {
      case R.HYPHEN_MINUS: {
        this.state = W.COMMENT_END_DASH;
        break;
      }
      case R.LESS_THAN_SIGN: {
        n.data += "<", this.state = W.COMMENT_LESS_THAN_SIGN;
        break;
      }
      case R.NULL: {
        this._err(ye.unexpectedNullCharacter), n.data += en;
        break;
      }
      case R.EOF: {
        this._err(ye.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += String.fromCodePoint(t);
    }
  }
  // Comment less-than sign state
  //------------------------------------------------------------------
  _stateCommentLessThanSign(t) {
    const n = this.currentToken;
    switch (t) {
      case R.EXCLAMATION_MARK: {
        n.data += "!", this.state = W.COMMENT_LESS_THAN_SIGN_BANG;
        break;
      }
      case R.LESS_THAN_SIGN: {
        n.data += "<";
        break;
      }
      default:
        this.state = W.COMMENT, this._stateComment(t);
    }
  }
  // Comment less-than sign bang state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBang(t) {
    t === R.HYPHEN_MINUS ? this.state = W.COMMENT_LESS_THAN_SIGN_BANG_DASH : (this.state = W.COMMENT, this._stateComment(t));
  }
  // Comment less-than sign bang dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDash(t) {
    t === R.HYPHEN_MINUS ? this.state = W.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH : (this.state = W.COMMENT_END_DASH, this._stateCommentEndDash(t));
  }
  // Comment less-than sign bang dash dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDashDash(t) {
    t !== R.GREATER_THAN_SIGN && t !== R.EOF && this._err(ye.nestedComment), this.state = W.COMMENT_END, this._stateCommentEnd(t);
  }
  // Comment end dash state
  //------------------------------------------------------------------
  _stateCommentEndDash(t) {
    const n = this.currentToken;
    switch (t) {
      case R.HYPHEN_MINUS: {
        this.state = W.COMMENT_END;
        break;
      }
      case R.EOF: {
        this._err(ye.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += "-", this.state = W.COMMENT, this._stateComment(t);
    }
  }
  // Comment end state
  //------------------------------------------------------------------
  _stateCommentEnd(t) {
    const n = this.currentToken;
    switch (t) {
      case R.GREATER_THAN_SIGN: {
        this.state = W.DATA, this.emitCurrentComment(n);
        break;
      }
      case R.EXCLAMATION_MARK: {
        this.state = W.COMMENT_END_BANG;
        break;
      }
      case R.HYPHEN_MINUS: {
        n.data += "-";
        break;
      }
      case R.EOF: {
        this._err(ye.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += "--", this.state = W.COMMENT, this._stateComment(t);
    }
  }
  // Comment end bang state
  //------------------------------------------------------------------
  _stateCommentEndBang(t) {
    const n = this.currentToken;
    switch (t) {
      case R.HYPHEN_MINUS: {
        n.data += "--!", this.state = W.COMMENT_END_DASH;
        break;
      }
      case R.GREATER_THAN_SIGN: {
        this._err(ye.incorrectlyClosedComment), this.state = W.DATA, this.emitCurrentComment(n);
        break;
      }
      case R.EOF: {
        this._err(ye.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += "--!", this.state = W.COMMENT, this._stateComment(t);
    }
  }
  // DOCTYPE state
  //------------------------------------------------------------------
  _stateDoctype(t) {
    switch (t) {
      case R.SPACE:
      case R.LINE_FEED:
      case R.TABULATION:
      case R.FORM_FEED: {
        this.state = W.BEFORE_DOCTYPE_NAME;
        break;
      }
      case R.GREATER_THAN_SIGN: {
        this.state = W.BEFORE_DOCTYPE_NAME, this._stateBeforeDoctypeName(t);
        break;
      }
      case R.EOF: {
        this._err(ye.eofInDoctype), this._createDoctypeToken(null);
        const n = this.currentToken;
        n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(ye.missingWhitespaceBeforeDoctypeName), this.state = W.BEFORE_DOCTYPE_NAME, this._stateBeforeDoctypeName(t);
    }
  }
  // Before DOCTYPE name state
  //------------------------------------------------------------------
  _stateBeforeDoctypeName(t) {
    if (eo(t))
      this._createDoctypeToken(String.fromCharCode(fu(t))), this.state = W.DOCTYPE_NAME;
    else
      switch (t) {
        case R.SPACE:
        case R.LINE_FEED:
        case R.TABULATION:
        case R.FORM_FEED:
          break;
        case R.NULL: {
          this._err(ye.unexpectedNullCharacter), this._createDoctypeToken(en), this.state = W.DOCTYPE_NAME;
          break;
        }
        case R.GREATER_THAN_SIGN: {
          this._err(ye.missingDoctypeName), this._createDoctypeToken(null);
          const n = this.currentToken;
          n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = W.DATA;
          break;
        }
        case R.EOF: {
          this._err(ye.eofInDoctype), this._createDoctypeToken(null);
          const n = this.currentToken;
          n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
          break;
        }
        default:
          this._createDoctypeToken(String.fromCodePoint(t)), this.state = W.DOCTYPE_NAME;
      }
  }
  // DOCTYPE name state
  //------------------------------------------------------------------
  _stateDoctypeName(t) {
    const n = this.currentToken;
    switch (t) {
      case R.SPACE:
      case R.LINE_FEED:
      case R.TABULATION:
      case R.FORM_FEED: {
        this.state = W.AFTER_DOCTYPE_NAME;
        break;
      }
      case R.GREATER_THAN_SIGN: {
        this.state = W.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case R.NULL: {
        this._err(ye.unexpectedNullCharacter), n.name += en;
        break;
      }
      case R.EOF: {
        this._err(ye.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.name += String.fromCodePoint(eo(t) ? fu(t) : t);
    }
  }
  // After DOCTYPE name state
  //------------------------------------------------------------------
  _stateAfterDoctypeName(t) {
    const n = this.currentToken;
    switch (t) {
      case R.SPACE:
      case R.LINE_FEED:
      case R.TABULATION:
      case R.FORM_FEED:
        break;
      case R.GREATER_THAN_SIGN: {
        this.state = W.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case R.EOF: {
        this._err(ye.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._consumeSequenceIfMatch(Jn.PUBLIC, !1) ? this.state = W.AFTER_DOCTYPE_PUBLIC_KEYWORD : this._consumeSequenceIfMatch(Jn.SYSTEM, !1) ? this.state = W.AFTER_DOCTYPE_SYSTEM_KEYWORD : this._ensureHibernation() || (this._err(ye.invalidCharacterSequenceAfterDoctypeName), n.forceQuirks = !0, this.state = W.BOGUS_DOCTYPE, this._stateBogusDoctype(t));
    }
  }
  // After DOCTYPE public keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicKeyword(t) {
    const n = this.currentToken;
    switch (t) {
      case R.SPACE:
      case R.LINE_FEED:
      case R.TABULATION:
      case R.FORM_FEED: {
        this.state = W.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case R.QUOTATION_MARK: {
        this._err(ye.missingWhitespaceAfterDoctypePublicKeyword), n.publicId = "", this.state = W.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case R.APOSTROPHE: {
        this._err(ye.missingWhitespaceAfterDoctypePublicKeyword), n.publicId = "", this.state = W.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case R.GREATER_THAN_SIGN: {
        this._err(ye.missingDoctypePublicIdentifier), n.forceQuirks = !0, this.state = W.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case R.EOF: {
        this._err(ye.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(ye.missingQuoteBeforeDoctypePublicIdentifier), n.forceQuirks = !0, this.state = W.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // Before DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypePublicIdentifier(t) {
    const n = this.currentToken;
    switch (t) {
      case R.SPACE:
      case R.LINE_FEED:
      case R.TABULATION:
      case R.FORM_FEED:
        break;
      case R.QUOTATION_MARK: {
        n.publicId = "", this.state = W.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case R.APOSTROPHE: {
        n.publicId = "", this.state = W.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case R.GREATER_THAN_SIGN: {
        this._err(ye.missingDoctypePublicIdentifier), n.forceQuirks = !0, this.state = W.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case R.EOF: {
        this._err(ye.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(ye.missingQuoteBeforeDoctypePublicIdentifier), n.forceQuirks = !0, this.state = W.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // DOCTYPE public identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierDoubleQuoted(t) {
    const n = this.currentToken;
    switch (t) {
      case R.QUOTATION_MARK: {
        this.state = W.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case R.NULL: {
        this._err(ye.unexpectedNullCharacter), n.publicId += en;
        break;
      }
      case R.GREATER_THAN_SIGN: {
        this._err(ye.abruptDoctypePublicIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = W.DATA;
        break;
      }
      case R.EOF: {
        this._err(ye.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.publicId += String.fromCodePoint(t);
    }
  }
  // DOCTYPE public identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierSingleQuoted(t) {
    const n = this.currentToken;
    switch (t) {
      case R.APOSTROPHE: {
        this.state = W.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case R.NULL: {
        this._err(ye.unexpectedNullCharacter), n.publicId += en;
        break;
      }
      case R.GREATER_THAN_SIGN: {
        this._err(ye.abruptDoctypePublicIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = W.DATA;
        break;
      }
      case R.EOF: {
        this._err(ye.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.publicId += String.fromCodePoint(t);
    }
  }
  // After DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicIdentifier(t) {
    const n = this.currentToken;
    switch (t) {
      case R.SPACE:
      case R.LINE_FEED:
      case R.TABULATION:
      case R.FORM_FEED: {
        this.state = W.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS;
        break;
      }
      case R.GREATER_THAN_SIGN: {
        this.state = W.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case R.QUOTATION_MARK: {
        this._err(ye.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers), n.systemId = "", this.state = W.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case R.APOSTROPHE: {
        this._err(ye.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers), n.systemId = "", this.state = W.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case R.EOF: {
        this._err(ye.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(ye.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = W.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // Between DOCTYPE public and system identifiers state
  //------------------------------------------------------------------
  _stateBetweenDoctypePublicAndSystemIdentifiers(t) {
    const n = this.currentToken;
    switch (t) {
      case R.SPACE:
      case R.LINE_FEED:
      case R.TABULATION:
      case R.FORM_FEED:
        break;
      case R.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(n), this.state = W.DATA;
        break;
      }
      case R.QUOTATION_MARK: {
        n.systemId = "", this.state = W.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case R.APOSTROPHE: {
        n.systemId = "", this.state = W.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case R.EOF: {
        this._err(ye.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(ye.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = W.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // After DOCTYPE system keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemKeyword(t) {
    const n = this.currentToken;
    switch (t) {
      case R.SPACE:
      case R.LINE_FEED:
      case R.TABULATION:
      case R.FORM_FEED: {
        this.state = W.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case R.QUOTATION_MARK: {
        this._err(ye.missingWhitespaceAfterDoctypeSystemKeyword), n.systemId = "", this.state = W.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case R.APOSTROPHE: {
        this._err(ye.missingWhitespaceAfterDoctypeSystemKeyword), n.systemId = "", this.state = W.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case R.GREATER_THAN_SIGN: {
        this._err(ye.missingDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = W.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case R.EOF: {
        this._err(ye.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(ye.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = W.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // Before DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypeSystemIdentifier(t) {
    const n = this.currentToken;
    switch (t) {
      case R.SPACE:
      case R.LINE_FEED:
      case R.TABULATION:
      case R.FORM_FEED:
        break;
      case R.QUOTATION_MARK: {
        n.systemId = "", this.state = W.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case R.APOSTROPHE: {
        n.systemId = "", this.state = W.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case R.GREATER_THAN_SIGN: {
        this._err(ye.missingDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = W.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case R.EOF: {
        this._err(ye.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(ye.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = W.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // DOCTYPE system identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierDoubleQuoted(t) {
    const n = this.currentToken;
    switch (t) {
      case R.QUOTATION_MARK: {
        this.state = W.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case R.NULL: {
        this._err(ye.unexpectedNullCharacter), n.systemId += en;
        break;
      }
      case R.GREATER_THAN_SIGN: {
        this._err(ye.abruptDoctypeSystemIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = W.DATA;
        break;
      }
      case R.EOF: {
        this._err(ye.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.systemId += String.fromCodePoint(t);
    }
  }
  // DOCTYPE system identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierSingleQuoted(t) {
    const n = this.currentToken;
    switch (t) {
      case R.APOSTROPHE: {
        this.state = W.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case R.NULL: {
        this._err(ye.unexpectedNullCharacter), n.systemId += en;
        break;
      }
      case R.GREATER_THAN_SIGN: {
        this._err(ye.abruptDoctypeSystemIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = W.DATA;
        break;
      }
      case R.EOF: {
        this._err(ye.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.systemId += String.fromCodePoint(t);
    }
  }
  // After DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemIdentifier(t) {
    const n = this.currentToken;
    switch (t) {
      case R.SPACE:
      case R.LINE_FEED:
      case R.TABULATION:
      case R.FORM_FEED:
        break;
      case R.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(n), this.state = W.DATA;
        break;
      }
      case R.EOF: {
        this._err(ye.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(ye.unexpectedCharacterAfterDoctypeSystemIdentifier), this.state = W.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // Bogus DOCTYPE state
  //------------------------------------------------------------------
  _stateBogusDoctype(t) {
    const n = this.currentToken;
    switch (t) {
      case R.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(n), this.state = W.DATA;
        break;
      }
      case R.NULL: {
        this._err(ye.unexpectedNullCharacter);
        break;
      }
      case R.EOF: {
        this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
    }
  }
  // CDATA section state
  //------------------------------------------------------------------
  _stateCdataSection(t) {
    switch (t) {
      case R.RIGHT_SQUARE_BRACKET: {
        this.state = W.CDATA_SECTION_BRACKET;
        break;
      }
      case R.EOF: {
        this._err(ye.eofInCdata), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // CDATA section bracket state
  //------------------------------------------------------------------
  _stateCdataSectionBracket(t) {
    t === R.RIGHT_SQUARE_BRACKET ? this.state = W.CDATA_SECTION_END : (this._emitChars("]"), this.state = W.CDATA_SECTION, this._stateCdataSection(t));
  }
  // CDATA section end state
  //------------------------------------------------------------------
  _stateCdataSectionEnd(t) {
    switch (t) {
      case R.GREATER_THAN_SIGN: {
        this.state = W.DATA;
        break;
      }
      case R.RIGHT_SQUARE_BRACKET: {
        this._emitChars("]");
        break;
      }
      default:
        this._emitChars("]]"), this.state = W.CDATA_SECTION, this._stateCdataSection(t);
    }
  }
  // Character reference state
  //------------------------------------------------------------------
  _stateCharacterReference() {
    let t = this.entityDecoder.write(this.preprocessor.html, this.preprocessor.pos);
    if (t < 0)
      if (this.preprocessor.lastChunkWritten)
        t = this.entityDecoder.end();
      else {
        this.active = !1, this.preprocessor.pos = this.preprocessor.html.length - 1, this.consumedAfterSnapshot = 0, this.preprocessor.endOfChunkHit = !0;
        return;
      }
    t === 0 ? (this.preprocessor.pos = this.entityStartPos, this._flushCodePointConsumedAsCharacterReference(R.AMPERSAND), this.state = !this._isCharacterReferenceInAttribute() && l0(this.preprocessor.peek(1)) ? W.AMBIGUOUS_AMPERSAND : this.returnState) : this.state = this.returnState;
  }
  // Ambiguos ampersand state
  //------------------------------------------------------------------
  _stateAmbiguousAmpersand(t) {
    l0(t) ? this._flushCodePointConsumedAsCharacterReference(t) : (t === R.SEMICOLON && this._err(ye.unknownNamedCharacterReference), this.state = this.returnState, this._callState(t));
  }
}
const h2 = /* @__PURE__ */ new Set([m.DD, m.DT, m.LI, m.OPTGROUP, m.OPTION, m.P, m.RB, m.RP, m.RT, m.RTC]), f0 = /* @__PURE__ */ new Set([
  ...h2,
  m.CAPTION,
  m.COLGROUP,
  m.TBODY,
  m.TD,
  m.TFOOT,
  m.TH,
  m.THEAD,
  m.TR
]), Ou = /* @__PURE__ */ new Set([
  m.APPLET,
  m.CAPTION,
  m.HTML,
  m.MARQUEE,
  m.OBJECT,
  m.TABLE,
  m.TD,
  m.TEMPLATE,
  m.TH
]), xy = /* @__PURE__ */ new Set([...Ou, m.OL, m.UL]), Ny = /* @__PURE__ */ new Set([...Ou, m.BUTTON]), h0 = /* @__PURE__ */ new Set([m.ANNOTATION_XML, m.MI, m.MN, m.MO, m.MS, m.MTEXT]), d0 = /* @__PURE__ */ new Set([m.DESC, m.FOREIGN_OBJECT, m.TITLE]), vy = /* @__PURE__ */ new Set([m.TR, m.TEMPLATE, m.HTML]), Sy = /* @__PURE__ */ new Set([m.TBODY, m.TFOOT, m.THEAD, m.TEMPLATE, m.HTML]), Ly = /* @__PURE__ */ new Set([m.TABLE, m.TEMPLATE, m.HTML]), ky = /* @__PURE__ */ new Set([m.TD, m.TH]);
class Cy {
  get currentTmplContentOrNode() {
    return this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : this.current;
  }
  constructor(t, n, r) {
    this.treeAdapter = n, this.handler = r, this.items = [], this.tagIDs = [], this.stackTop = -1, this.tmplCount = 0, this.currentTagId = m.UNKNOWN, this.current = t;
  }
  //Index of element
  _indexOf(t) {
    return this.items.lastIndexOf(t, this.stackTop);
  }
  //Update current element
  _isInTemplate() {
    return this.currentTagId === m.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === Ce.HTML;
  }
  _updateCurrentElement() {
    this.current = this.items[this.stackTop], this.currentTagId = this.tagIDs[this.stackTop];
  }
  //Mutations
  push(t, n) {
    this.stackTop++, this.items[this.stackTop] = t, this.current = t, this.tagIDs[this.stackTop] = n, this.currentTagId = n, this._isInTemplate() && this.tmplCount++, this.handler.onItemPush(t, n, !0);
  }
  pop() {
    const t = this.current;
    this.tmplCount > 0 && this._isInTemplate() && this.tmplCount--, this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(t, !0);
  }
  replace(t, n) {
    const r = this._indexOf(t);
    this.items[r] = n, r === this.stackTop && (this.current = n);
  }
  insertAfter(t, n, r) {
    const i = this._indexOf(t) + 1;
    this.items.splice(i, 0, n), this.tagIDs.splice(i, 0, r), this.stackTop++, i === this.stackTop && this._updateCurrentElement(), this.current && this.currentTagId !== void 0 && this.handler.onItemPush(this.current, this.currentTagId, i === this.stackTop);
  }
  popUntilTagNamePopped(t) {
    let n = this.stackTop + 1;
    do
      n = this.tagIDs.lastIndexOf(t, n - 1);
    while (n > 0 && this.treeAdapter.getNamespaceURI(this.items[n]) !== Ce.HTML);
    this.shortenToLength(Math.max(n, 0));
  }
  shortenToLength(t) {
    for (; this.stackTop >= t; ) {
      const n = this.current;
      this.tmplCount > 0 && this._isInTemplate() && (this.tmplCount -= 1), this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(n, this.stackTop < t);
    }
  }
  popUntilElementPopped(t) {
    const n = this._indexOf(t);
    this.shortenToLength(Math.max(n, 0));
  }
  popUntilPopped(t, n) {
    const r = this._indexOfTagNames(t, n);
    this.shortenToLength(Math.max(r, 0));
  }
  popUntilNumberedHeaderPopped() {
    this.popUntilPopped(Dc, Ce.HTML);
  }
  popUntilTableCellPopped() {
    this.popUntilPopped(ky, Ce.HTML);
  }
  popAllUpToHtmlElement() {
    this.tmplCount = 0, this.shortenToLength(1);
  }
  _indexOfTagNames(t, n) {
    for (let r = this.stackTop; r >= 0; r--)
      if (t.has(this.tagIDs[r]) && this.treeAdapter.getNamespaceURI(this.items[r]) === n)
        return r;
    return -1;
  }
  clearBackTo(t, n) {
    const r = this._indexOfTagNames(t, n);
    this.shortenToLength(r + 1);
  }
  clearBackToTableContext() {
    this.clearBackTo(Ly, Ce.HTML);
  }
  clearBackToTableBodyContext() {
    this.clearBackTo(Sy, Ce.HTML);
  }
  clearBackToTableRowContext() {
    this.clearBackTo(vy, Ce.HTML);
  }
  remove(t) {
    const n = this._indexOf(t);
    n >= 0 && (n === this.stackTop ? this.pop() : (this.items.splice(n, 1), this.tagIDs.splice(n, 1), this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(t, !1)));
  }
  //Search
  tryPeekProperlyNestedBodyElement() {
    return this.stackTop >= 1 && this.tagIDs[1] === m.BODY ? this.items[1] : null;
  }
  contains(t) {
    return this._indexOf(t) > -1;
  }
  getCommonAncestor(t) {
    const n = this._indexOf(t) - 1;
    return n >= 0 ? this.items[n] : null;
  }
  isRootHtmlElementCurrent() {
    return this.stackTop === 0 && this.tagIDs[0] === m.HTML;
  }
  //Element in scope
  hasInDynamicScope(t, n) {
    for (let r = this.stackTop; r >= 0; r--) {
      const i = this.tagIDs[r];
      switch (this.treeAdapter.getNamespaceURI(this.items[r])) {
        case Ce.HTML: {
          if (i === t)
            return !0;
          if (n.has(i))
            return !1;
          break;
        }
        case Ce.SVG: {
          if (d0.has(i))
            return !1;
          break;
        }
        case Ce.MATHML: {
          if (h0.has(i))
            return !1;
          break;
        }
      }
    }
    return !0;
  }
  hasInScope(t) {
    return this.hasInDynamicScope(t, Ou);
  }
  hasInListItemScope(t) {
    return this.hasInDynamicScope(t, xy);
  }
  hasInButtonScope(t) {
    return this.hasInDynamicScope(t, Ny);
  }
  hasNumberedHeaderInScope() {
    for (let t = this.stackTop; t >= 0; t--) {
      const n = this.tagIDs[t];
      switch (this.treeAdapter.getNamespaceURI(this.items[t])) {
        case Ce.HTML: {
          if (Dc.has(n))
            return !0;
          if (Ou.has(n))
            return !1;
          break;
        }
        case Ce.SVG: {
          if (d0.has(n))
            return !1;
          break;
        }
        case Ce.MATHML: {
          if (h0.has(n))
            return !1;
          break;
        }
      }
    }
    return !0;
  }
  hasInTableScope(t) {
    for (let n = this.stackTop; n >= 0; n--)
      if (this.treeAdapter.getNamespaceURI(this.items[n]) === Ce.HTML)
        switch (this.tagIDs[n]) {
          case t:
            return !0;
          case m.TABLE:
          case m.HTML:
            return !1;
        }
    return !0;
  }
  hasTableBodyContextInTableScope() {
    for (let t = this.stackTop; t >= 0; t--)
      if (this.treeAdapter.getNamespaceURI(this.items[t]) === Ce.HTML)
        switch (this.tagIDs[t]) {
          case m.TBODY:
          case m.THEAD:
          case m.TFOOT:
            return !0;
          case m.TABLE:
          case m.HTML:
            return !1;
        }
    return !0;
  }
  hasInSelectScope(t) {
    for (let n = this.stackTop; n >= 0; n--)
      if (this.treeAdapter.getNamespaceURI(this.items[n]) === Ce.HTML)
        switch (this.tagIDs[n]) {
          case t:
            return !0;
          case m.OPTION:
          case m.OPTGROUP:
            break;
          default:
            return !1;
        }
    return !0;
  }
  //Implied end tags
  generateImpliedEndTags() {
    for (; this.currentTagId !== void 0 && h2.has(this.currentTagId); )
      this.pop();
  }
  generateImpliedEndTagsThoroughly() {
    for (; this.currentTagId !== void 0 && f0.has(this.currentTagId); )
      this.pop();
  }
  generateImpliedEndTagsWithExclusion(t) {
    for (; this.currentTagId !== void 0 && this.currentTagId !== t && f0.has(this.currentTagId); )
      this.pop();
  }
}
const Jl = 3;
var ei;
(function(e) {
  e[e.Marker = 0] = "Marker", e[e.Element = 1] = "Element";
})(ei || (ei = {}));
const p0 = { type: ei.Marker };
class Iy {
  constructor(t) {
    this.treeAdapter = t, this.entries = [], this.bookmark = null;
  }
  //Noah Ark's condition
  //OPTIMIZATION: at first we try to find possible candidates for exclusion using
  //lightweight heuristics without thorough attributes check.
  _getNoahArkConditionCandidates(t, n) {
    const r = [], i = n.length, a = this.treeAdapter.getTagName(t), s = this.treeAdapter.getNamespaceURI(t);
    for (let o = 0; o < this.entries.length; o++) {
      const u = this.entries[o];
      if (u.type === ei.Marker)
        break;
      const { element: c } = u;
      if (this.treeAdapter.getTagName(c) === a && this.treeAdapter.getNamespaceURI(c) === s) {
        const f = this.treeAdapter.getAttrList(c);
        f.length === i && r.push({ idx: o, attrs: f });
      }
    }
    return r;
  }
  _ensureNoahArkCondition(t) {
    if (this.entries.length < Jl)
      return;
    const n = this.treeAdapter.getAttrList(t), r = this._getNoahArkConditionCandidates(t, n);
    if (r.length < Jl)
      return;
    const i = new Map(n.map((s) => [s.name, s.value]));
    let a = 0;
    for (let s = 0; s < r.length; s++) {
      const o = r[s];
      o.attrs.every((u) => i.get(u.name) === u.value) && (a += 1, a >= Jl && this.entries.splice(o.idx, 1));
    }
  }
  //Mutations
  insertMarker() {
    this.entries.unshift(p0);
  }
  pushElement(t, n) {
    this._ensureNoahArkCondition(t), this.entries.unshift({
      type: ei.Element,
      element: t,
      token: n
    });
  }
  insertElementAfterBookmark(t, n) {
    const r = this.entries.indexOf(this.bookmark);
    this.entries.splice(r, 0, {
      type: ei.Element,
      element: t,
      token: n
    });
  }
  removeEntry(t) {
    const n = this.entries.indexOf(t);
    n !== -1 && this.entries.splice(n, 1);
  }
  /**
   * Clears the list of formatting elements up to the last marker.
   *
   * @see https://html.spec.whatwg.org/multipage/parsing.html#clear-the-list-of-active-formatting-elements-up-to-the-last-marker
   */
  clearToLastMarker() {
    const t = this.entries.indexOf(p0);
    t === -1 ? this.entries.length = 0 : this.entries.splice(0, t + 1);
  }
  //Search
  getElementEntryInScopeWithTagName(t) {
    const n = this.entries.find((r) => r.type === ei.Marker || this.treeAdapter.getTagName(r.element) === t);
    return n && n.type === ei.Element ? n : null;
  }
  getElementEntry(t) {
    return this.entries.find((n) => n.type === ei.Element && n.element === t);
  }
}
const Xi = {
  //Node construction
  createDocument() {
    return {
      nodeName: "#document",
      mode: vr.NO_QUIRKS,
      childNodes: []
    };
  },
  createDocumentFragment() {
    return {
      nodeName: "#document-fragment",
      childNodes: []
    };
  },
  createElement(e, t, n) {
    return {
      nodeName: e,
      tagName: e,
      attrs: n,
      namespaceURI: t,
      childNodes: [],
      parentNode: null
    };
  },
  createCommentNode(e) {
    return {
      nodeName: "#comment",
      data: e,
      parentNode: null
    };
  },
  createTextNode(e) {
    return {
      nodeName: "#text",
      value: e,
      parentNode: null
    };
  },
  //Tree mutation
  appendChild(e, t) {
    e.childNodes.push(t), t.parentNode = e;
  },
  insertBefore(e, t, n) {
    const r = e.childNodes.indexOf(n);
    e.childNodes.splice(r, 0, t), t.parentNode = e;
  },
  setTemplateContent(e, t) {
    e.content = t;
  },
  getTemplateContent(e) {
    return e.content;
  },
  setDocumentType(e, t, n, r) {
    const i = e.childNodes.find((a) => a.nodeName === "#documentType");
    if (i)
      i.name = t, i.publicId = n, i.systemId = r;
    else {
      const a = {
        nodeName: "#documentType",
        name: t,
        publicId: n,
        systemId: r,
        parentNode: null
      };
      Xi.appendChild(e, a);
    }
  },
  setDocumentMode(e, t) {
    e.mode = t;
  },
  getDocumentMode(e) {
    return e.mode;
  },
  detachNode(e) {
    if (e.parentNode) {
      const t = e.parentNode.childNodes.indexOf(e);
      e.parentNode.childNodes.splice(t, 1), e.parentNode = null;
    }
  },
  insertText(e, t) {
    if (e.childNodes.length > 0) {
      const n = e.childNodes[e.childNodes.length - 1];
      if (Xi.isTextNode(n)) {
        n.value += t;
        return;
      }
    }
    Xi.appendChild(e, Xi.createTextNode(t));
  },
  insertTextBefore(e, t, n) {
    const r = e.childNodes[e.childNodes.indexOf(n) - 1];
    r && Xi.isTextNode(r) ? r.value += t : Xi.insertBefore(e, Xi.createTextNode(t), n);
  },
  adoptAttributes(e, t) {
    const n = new Set(e.attrs.map((r) => r.name));
    for (let r = 0; r < t.length; r++)
      n.has(t[r].name) || e.attrs.push(t[r]);
  },
  //Tree traversing
  getFirstChild(e) {
    return e.childNodes[0];
  },
  getChildNodes(e) {
    return e.childNodes;
  },
  getParentNode(e) {
    return e.parentNode;
  },
  getAttrList(e) {
    return e.attrs;
  },
  //Node data
  getTagName(e) {
    return e.tagName;
  },
  getNamespaceURI(e) {
    return e.namespaceURI;
  },
  getTextNodeContent(e) {
    return e.value;
  },
  getCommentNodeContent(e) {
    return e.data;
  },
  getDocumentTypeNodeName(e) {
    return e.name;
  },
  getDocumentTypeNodePublicId(e) {
    return e.publicId;
  },
  getDocumentTypeNodeSystemId(e) {
    return e.systemId;
  },
  //Node types
  isTextNode(e) {
    return e.nodeName === "#text";
  },
  isCommentNode(e) {
    return e.nodeName === "#comment";
  },
  isDocumentTypeNode(e) {
    return e.nodeName === "#documentType";
  },
  isElementNode(e) {
    return Object.prototype.hasOwnProperty.call(e, "tagName");
  },
  // Source code location
  setNodeSourceCodeLocation(e, t) {
    e.sourceCodeLocation = t;
  },
  getNodeSourceCodeLocation(e) {
    return e.sourceCodeLocation;
  },
  updateNodeSourceCodeLocation(e, t) {
    e.sourceCodeLocation = { ...e.sourceCodeLocation, ...t };
  }
}, d2 = "html", Py = "about:legacy-compat", Oy = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd", p2 = [
  "+//silmaril//dtd html pro v0r11 19970101//",
  "-//as//dtd html 3.0 aswedit + extensions//",
  "-//advasoft ltd//dtd html 3.0 aswedit + extensions//",
  "-//ietf//dtd html 2.0 level 1//",
  "-//ietf//dtd html 2.0 level 2//",
  "-//ietf//dtd html 2.0 strict level 1//",
  "-//ietf//dtd html 2.0 strict level 2//",
  "-//ietf//dtd html 2.0 strict//",
  "-//ietf//dtd html 2.0//",
  "-//ietf//dtd html 2.1e//",
  "-//ietf//dtd html 3.0//",
  "-//ietf//dtd html 3.2 final//",
  "-//ietf//dtd html 3.2//",
  "-//ietf//dtd html 3//",
  "-//ietf//dtd html level 0//",
  "-//ietf//dtd html level 1//",
  "-//ietf//dtd html level 2//",
  "-//ietf//dtd html level 3//",
  "-//ietf//dtd html strict level 0//",
  "-//ietf//dtd html strict level 1//",
  "-//ietf//dtd html strict level 2//",
  "-//ietf//dtd html strict level 3//",
  "-//ietf//dtd html strict//",
  "-//ietf//dtd html//",
  "-//metrius//dtd metrius presentational//",
  "-//microsoft//dtd internet explorer 2.0 html strict//",
  "-//microsoft//dtd internet explorer 2.0 html//",
  "-//microsoft//dtd internet explorer 2.0 tables//",
  "-//microsoft//dtd internet explorer 3.0 html strict//",
  "-//microsoft//dtd internet explorer 3.0 html//",
  "-//microsoft//dtd internet explorer 3.0 tables//",
  "-//netscape comm. corp.//dtd html//",
  "-//netscape comm. corp.//dtd strict html//",
  "-//o'reilly and associates//dtd html 2.0//",
  "-//o'reilly and associates//dtd html extended 1.0//",
  "-//o'reilly and associates//dtd html extended relaxed 1.0//",
  "-//sq//dtd html 2.0 hotmetal + extensions//",
  "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//",
  "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//",
  "-//spyglass//dtd html 2.0 extended//",
  "-//sun microsystems corp.//dtd hotjava html//",
  "-//sun microsystems corp.//dtd hotjava strict html//",
  "-//w3c//dtd html 3 1995-03-24//",
  "-//w3c//dtd html 3.2 draft//",
  "-//w3c//dtd html 3.2 final//",
  "-//w3c//dtd html 3.2//",
  "-//w3c//dtd html 3.2s draft//",
  "-//w3c//dtd html 4.0 frameset//",
  "-//w3c//dtd html 4.0 transitional//",
  "-//w3c//dtd html experimental 19960712//",
  "-//w3c//dtd html experimental 970421//",
  "-//w3c//dtd w3 html//",
  "-//w3o//dtd w3 html 3.0//",
  "-//webtechs//dtd mozilla html 2.0//",
  "-//webtechs//dtd mozilla html//"
], Ry = [
  ...p2,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
], Dy = /* @__PURE__ */ new Set([
  "-//w3o//dtd w3 html strict 3.0//en//",
  "-/w3c/dtd html 4.0 transitional/en",
  "html"
]), m2 = ["-//w3c//dtd xhtml 1.0 frameset//", "-//w3c//dtd xhtml 1.0 transitional//"], My = [
  ...m2,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
];
function m0(e, t) {
  return t.some((n) => e.startsWith(n));
}
function Fy(e) {
  return e.name === d2 && e.publicId === null && (e.systemId === null || e.systemId === Py);
}
function By(e) {
  if (e.name !== d2)
    return vr.QUIRKS;
  const { systemId: t } = e;
  if (t && t.toLowerCase() === Oy)
    return vr.QUIRKS;
  let { publicId: n } = e;
  if (n !== null) {
    if (n = n.toLowerCase(), Dy.has(n))
      return vr.QUIRKS;
    let r = t === null ? Ry : p2;
    if (m0(n, r))
      return vr.QUIRKS;
    if (r = t === null ? m2 : My, m0(n, r))
      return vr.LIMITED_QUIRKS;
  }
  return vr.NO_QUIRKS;
}
const g0 = {
  TEXT_HTML: "text/html",
  APPLICATION_XML: "application/xhtml+xml"
}, Uy = "definitionurl", Hy = "definitionURL", jy = new Map([
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((e) => [e.toLowerCase(), e])), qy = /* @__PURE__ */ new Map([
  ["xlink:actuate", { prefix: "xlink", name: "actuate", namespace: Ce.XLINK }],
  ["xlink:arcrole", { prefix: "xlink", name: "arcrole", namespace: Ce.XLINK }],
  ["xlink:href", { prefix: "xlink", name: "href", namespace: Ce.XLINK }],
  ["xlink:role", { prefix: "xlink", name: "role", namespace: Ce.XLINK }],
  ["xlink:show", { prefix: "xlink", name: "show", namespace: Ce.XLINK }],
  ["xlink:title", { prefix: "xlink", name: "title", namespace: Ce.XLINK }],
  ["xlink:type", { prefix: "xlink", name: "type", namespace: Ce.XLINK }],
  ["xml:lang", { prefix: "xml", name: "lang", namespace: Ce.XML }],
  ["xml:space", { prefix: "xml", name: "space", namespace: Ce.XML }],
  ["xmlns", { prefix: "", name: "xmlns", namespace: Ce.XMLNS }],
  ["xmlns:xlink", { prefix: "xmlns", name: "xlink", namespace: Ce.XMLNS }]
]), zy = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((e) => [e.toLowerCase(), e])), Yy = /* @__PURE__ */ new Set([
  m.B,
  m.BIG,
  m.BLOCKQUOTE,
  m.BODY,
  m.BR,
  m.CENTER,
  m.CODE,
  m.DD,
  m.DIV,
  m.DL,
  m.DT,
  m.EM,
  m.EMBED,
  m.H1,
  m.H2,
  m.H3,
  m.H4,
  m.H5,
  m.H6,
  m.HEAD,
  m.HR,
  m.I,
  m.IMG,
  m.LI,
  m.LISTING,
  m.MENU,
  m.META,
  m.NOBR,
  m.OL,
  m.P,
  m.PRE,
  m.RUBY,
  m.S,
  m.SMALL,
  m.SPAN,
  m.STRONG,
  m.STRIKE,
  m.SUB,
  m.SUP,
  m.TABLE,
  m.TT,
  m.U,
  m.UL,
  m.VAR
]);
function Wy(e) {
  const t = e.tagID;
  return t === m.FONT && e.attrs.some(({ name: r }) => r === xa.COLOR || r === xa.SIZE || r === xa.FACE) || Yy.has(t);
}
function g2(e) {
  for (let t = 0; t < e.attrs.length; t++)
    if (e.attrs[t].name === Uy) {
      e.attrs[t].name = Hy;
      break;
    }
}
function b2(e) {
  for (let t = 0; t < e.attrs.length; t++) {
    const n = jy.get(e.attrs[t].name);
    n != null && (e.attrs[t].name = n);
  }
}
function mf(e) {
  for (let t = 0; t < e.attrs.length; t++) {
    const n = qy.get(e.attrs[t].name);
    n && (e.attrs[t].prefix = n.prefix, e.attrs[t].name = n.name, e.attrs[t].namespace = n.namespace);
  }
}
function Vy(e) {
  const t = zy.get(e.tagName);
  t != null && (e.tagName = t, e.tagID = ms(e.tagName));
}
function Gy(e, t) {
  return t === Ce.MATHML && (e === m.MI || e === m.MO || e === m.MN || e === m.MS || e === m.MTEXT);
}
function $y(e, t, n) {
  if (t === Ce.MATHML && e === m.ANNOTATION_XML) {
    for (let r = 0; r < n.length; r++)
      if (n[r].name === xa.ENCODING) {
        const i = n[r].value.toLowerCase();
        return i === g0.TEXT_HTML || i === g0.APPLICATION_XML;
      }
  }
  return t === Ce.SVG && (e === m.FOREIGN_OBJECT || e === m.DESC || e === m.TITLE);
}
function Xy(e, t, n, r) {
  return (!r || r === Ce.HTML) && $y(e, t, n) || (!r || r === Ce.MATHML) && Gy(e, t);
}
const Ky = "hidden", Qy = 8, Jy = 3;
var X;
(function(e) {
  e[e.INITIAL = 0] = "INITIAL", e[e.BEFORE_HTML = 1] = "BEFORE_HTML", e[e.BEFORE_HEAD = 2] = "BEFORE_HEAD", e[e.IN_HEAD = 3] = "IN_HEAD", e[e.IN_HEAD_NO_SCRIPT = 4] = "IN_HEAD_NO_SCRIPT", e[e.AFTER_HEAD = 5] = "AFTER_HEAD", e[e.IN_BODY = 6] = "IN_BODY", e[e.TEXT = 7] = "TEXT", e[e.IN_TABLE = 8] = "IN_TABLE", e[e.IN_TABLE_TEXT = 9] = "IN_TABLE_TEXT", e[e.IN_CAPTION = 10] = "IN_CAPTION", e[e.IN_COLUMN_GROUP = 11] = "IN_COLUMN_GROUP", e[e.IN_TABLE_BODY = 12] = "IN_TABLE_BODY", e[e.IN_ROW = 13] = "IN_ROW", e[e.IN_CELL = 14] = "IN_CELL", e[e.IN_SELECT = 15] = "IN_SELECT", e[e.IN_SELECT_IN_TABLE = 16] = "IN_SELECT_IN_TABLE", e[e.IN_TEMPLATE = 17] = "IN_TEMPLATE", e[e.AFTER_BODY = 18] = "AFTER_BODY", e[e.IN_FRAMESET = 19] = "IN_FRAMESET", e[e.AFTER_FRAMESET = 20] = "AFTER_FRAMESET", e[e.AFTER_AFTER_BODY = 21] = "AFTER_AFTER_BODY", e[e.AFTER_AFTER_FRAMESET = 22] = "AFTER_AFTER_FRAMESET";
})(X || (X = {}));
const Zy = {
  startLine: -1,
  startCol: -1,
  startOffset: -1,
  endLine: -1,
  endCol: -1,
  endOffset: -1
}, E2 = /* @__PURE__ */ new Set([m.TABLE, m.TBODY, m.TFOOT, m.THEAD, m.TR]), b0 = {
  scriptingEnabled: !0,
  sourceCodeLocationInfo: !1,
  treeAdapter: Xi,
  onParseError: null
};
class E0 {
  constructor(t, n, r = null, i = null) {
    this.fragmentContext = r, this.scriptHandler = i, this.currentToken = null, this.stopped = !1, this.insertionMode = X.INITIAL, this.originalInsertionMode = X.INITIAL, this.headElement = null, this.formElement = null, this.currentNotInHTML = !1, this.tmplInsertionModeStack = [], this.pendingCharacterTokens = [], this.hasNonWhitespacePendingCharacterToken = !1, this.framesetOk = !0, this.skipNextNewLine = !1, this.fosterParentingEnabled = !1, this.options = {
      ...b0,
      ...t
    }, this.treeAdapter = this.options.treeAdapter, this.onParseError = this.options.onParseError, this.onParseError && (this.options.sourceCodeLocationInfo = !0), this.document = n ?? this.treeAdapter.createDocument(), this.tokenizer = new wy(this.options, this), this.activeFormattingElements = new Iy(this.treeAdapter), this.fragmentContextID = r ? ms(this.treeAdapter.getTagName(r)) : m.UNKNOWN, this._setContextModes(r ?? this.document, this.fragmentContextID), this.openElements = new Cy(this.document, this.treeAdapter, this);
  }
  // API
  static parse(t, n) {
    const r = new this(n);
    return r.tokenizer.write(t, !0), r.document;
  }
  static getFragmentParser(t, n) {
    const r = {
      ...b0,
      ...n
    };
    t ?? (t = r.treeAdapter.createElement(ce.TEMPLATE, Ce.HTML, []));
    const i = r.treeAdapter.createElement("documentmock", Ce.HTML, []), a = new this(r, i, t);
    return a.fragmentContextID === m.TEMPLATE && a.tmplInsertionModeStack.unshift(X.IN_TEMPLATE), a._initTokenizerForFragmentParsing(), a._insertFakeRootElement(), a._resetInsertionMode(), a._findFormInFragmentContext(), a;
  }
  getFragment() {
    const t = this.treeAdapter.getFirstChild(this.document), n = this.treeAdapter.createDocumentFragment();
    return this._adoptNodes(t, n), n;
  }
  //Errors
  /** @internal */
  _err(t, n, r) {
    var i;
    if (!this.onParseError)
      return;
    const a = (i = t.location) !== null && i !== void 0 ? i : Zy, s = {
      code: n,
      startLine: a.startLine,
      startCol: a.startCol,
      startOffset: a.startOffset,
      endLine: r ? a.startLine : a.endLine,
      endCol: r ? a.startCol : a.endCol,
      endOffset: r ? a.startOffset : a.endOffset
    };
    this.onParseError(s);
  }
  //Stack events
  /** @internal */
  onItemPush(t, n, r) {
    var i, a;
    (a = (i = this.treeAdapter).onItemPush) === null || a === void 0 || a.call(i, t), r && this.openElements.stackTop > 0 && this._setContextModes(t, n);
  }
  /** @internal */
  onItemPop(t, n) {
    var r, i;
    if (this.options.sourceCodeLocationInfo && this._setEndLocation(t, this.currentToken), (i = (r = this.treeAdapter).onItemPop) === null || i === void 0 || i.call(r, t, this.openElements.current), n) {
      let a, s;
      this.openElements.stackTop === 0 && this.fragmentContext ? (a = this.fragmentContext, s = this.fragmentContextID) : { current: a, currentTagId: s } = this.openElements, this._setContextModes(a, s);
    }
  }
  _setContextModes(t, n) {
    const r = t === this.document || t && this.treeAdapter.getNamespaceURI(t) === Ce.HTML;
    this.currentNotInHTML = !r, this.tokenizer.inForeignNode = !r && t !== void 0 && n !== void 0 && !this._isIntegrationPoint(n, t);
  }
  /** @protected */
  _switchToTextParsing(t, n) {
    this._insertElement(t, Ce.HTML), this.tokenizer.state = n, this.originalInsertionMode = this.insertionMode, this.insertionMode = X.TEXT;
  }
  switchToPlaintextParsing() {
    this.insertionMode = X.TEXT, this.originalInsertionMode = X.IN_BODY, this.tokenizer.state = pn.PLAINTEXT;
  }
  //Fragment parsing
  /** @protected */
  _getAdjustedCurrentElement() {
    return this.openElements.stackTop === 0 && this.fragmentContext ? this.fragmentContext : this.openElements.current;
  }
  /** @protected */
  _findFormInFragmentContext() {
    let t = this.fragmentContext;
    for (; t; ) {
      if (this.treeAdapter.getTagName(t) === ce.FORM) {
        this.formElement = t;
        break;
      }
      t = this.treeAdapter.getParentNode(t);
    }
  }
  _initTokenizerForFragmentParsing() {
    if (!(!this.fragmentContext || this.treeAdapter.getNamespaceURI(this.fragmentContext) !== Ce.HTML))
      switch (this.fragmentContextID) {
        case m.TITLE:
        case m.TEXTAREA: {
          this.tokenizer.state = pn.RCDATA;
          break;
        }
        case m.STYLE:
        case m.XMP:
        case m.IFRAME:
        case m.NOEMBED:
        case m.NOFRAMES:
        case m.NOSCRIPT: {
          this.tokenizer.state = pn.RAWTEXT;
          break;
        }
        case m.SCRIPT: {
          this.tokenizer.state = pn.SCRIPT_DATA;
          break;
        }
        case m.PLAINTEXT: {
          this.tokenizer.state = pn.PLAINTEXT;
          break;
        }
      }
  }
  //Tree mutation
  /** @protected */
  _setDocumentType(t) {
    const n = t.name || "", r = t.publicId || "", i = t.systemId || "";
    if (this.treeAdapter.setDocumentType(this.document, n, r, i), t.location) {
      const s = this.treeAdapter.getChildNodes(this.document).find((o) => this.treeAdapter.isDocumentTypeNode(o));
      s && this.treeAdapter.setNodeSourceCodeLocation(s, t.location);
    }
  }
  /** @protected */
  _attachElementToTree(t, n) {
    if (this.options.sourceCodeLocationInfo) {
      const r = n && {
        ...n,
        startTag: n
      };
      this.treeAdapter.setNodeSourceCodeLocation(t, r);
    }
    if (this._shouldFosterParentOnInsertion())
      this._fosterParentElement(t);
    else {
      const r = this.openElements.currentTmplContentOrNode;
      this.treeAdapter.appendChild(r ?? this.document, t);
    }
  }
  /**
   * For self-closing tags. Add an element to the tree, but skip adding it
   * to the stack.
   */
  /** @protected */
  _appendElement(t, n) {
    const r = this.treeAdapter.createElement(t.tagName, n, t.attrs);
    this._attachElementToTree(r, t.location);
  }
  /** @protected */
  _insertElement(t, n) {
    const r = this.treeAdapter.createElement(t.tagName, n, t.attrs);
    this._attachElementToTree(r, t.location), this.openElements.push(r, t.tagID);
  }
  /** @protected */
  _insertFakeElement(t, n) {
    const r = this.treeAdapter.createElement(t, Ce.HTML, []);
    this._attachElementToTree(r, null), this.openElements.push(r, n);
  }
  /** @protected */
  _insertTemplate(t) {
    const n = this.treeAdapter.createElement(t.tagName, Ce.HTML, t.attrs), r = this.treeAdapter.createDocumentFragment();
    this.treeAdapter.setTemplateContent(n, r), this._attachElementToTree(n, t.location), this.openElements.push(n, t.tagID), this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(r, null);
  }
  /** @protected */
  _insertFakeRootElement() {
    const t = this.treeAdapter.createElement(ce.HTML, Ce.HTML, []);
    this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(t, null), this.treeAdapter.appendChild(this.openElements.current, t), this.openElements.push(t, m.HTML);
  }
  /** @protected */
  _appendCommentNode(t, n) {
    const r = this.treeAdapter.createCommentNode(t.data);
    this.treeAdapter.appendChild(n, r), this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(r, t.location);
  }
  /** @protected */
  _insertCharacters(t) {
    let n, r;
    if (this._shouldFosterParentOnInsertion() ? ({ parent: n, beforeElement: r } = this._findFosterParentingLocation(), r ? this.treeAdapter.insertTextBefore(n, t.chars, r) : this.treeAdapter.insertText(n, t.chars)) : (n = this.openElements.currentTmplContentOrNode, this.treeAdapter.insertText(n, t.chars)), !t.location)
      return;
    const i = this.treeAdapter.getChildNodes(n), a = r ? i.lastIndexOf(r) : i.length, s = i[a - 1];
    if (this.treeAdapter.getNodeSourceCodeLocation(s)) {
      const { endLine: u, endCol: c, endOffset: f } = t.location;
      this.treeAdapter.updateNodeSourceCodeLocation(s, { endLine: u, endCol: c, endOffset: f });
    } else this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(s, t.location);
  }
  /** @protected */
  _adoptNodes(t, n) {
    for (let r = this.treeAdapter.getFirstChild(t); r; r = this.treeAdapter.getFirstChild(t))
      this.treeAdapter.detachNode(r), this.treeAdapter.appendChild(n, r);
  }
  /** @protected */
  _setEndLocation(t, n) {
    if (this.treeAdapter.getNodeSourceCodeLocation(t) && n.location) {
      const r = n.location, i = this.treeAdapter.getTagName(t), a = (
        // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing
        // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.
        n.type === St.END_TAG && i === n.tagName ? {
          endTag: { ...r },
          endLine: r.endLine,
          endCol: r.endCol,
          endOffset: r.endOffset
        } : {
          endLine: r.startLine,
          endCol: r.startCol,
          endOffset: r.startOffset
        }
      );
      this.treeAdapter.updateNodeSourceCodeLocation(t, a);
    }
  }
  //Token processing
  shouldProcessStartTagTokenInForeignContent(t) {
    if (!this.currentNotInHTML)
      return !1;
    let n, r;
    return this.openElements.stackTop === 0 && this.fragmentContext ? (n = this.fragmentContext, r = this.fragmentContextID) : { current: n, currentTagId: r } = this.openElements, t.tagID === m.SVG && this.treeAdapter.getTagName(n) === ce.ANNOTATION_XML && this.treeAdapter.getNamespaceURI(n) === Ce.MATHML ? !1 : (
      // Check that `current` is not an integration point for HTML or MathML elements.
      this.tokenizer.inForeignNode || // If it _is_ an integration point, then we might have to check that it is not an HTML
      // integration point.
      (t.tagID === m.MGLYPH || t.tagID === m.MALIGNMARK) && r !== void 0 && !this._isIntegrationPoint(r, n, Ce.HTML)
    );
  }
  /** @protected */
  _processToken(t) {
    switch (t.type) {
      case St.CHARACTER: {
        this.onCharacter(t);
        break;
      }
      case St.NULL_CHARACTER: {
        this.onNullCharacter(t);
        break;
      }
      case St.COMMENT: {
        this.onComment(t);
        break;
      }
      case St.DOCTYPE: {
        this.onDoctype(t);
        break;
      }
      case St.START_TAG: {
        this._processStartTag(t);
        break;
      }
      case St.END_TAG: {
        this.onEndTag(t);
        break;
      }
      case St.EOF: {
        this.onEof(t);
        break;
      }
      case St.WHITESPACE_CHARACTER: {
        this.onWhitespaceCharacter(t);
        break;
      }
    }
  }
  //Integration points
  /** @protected */
  _isIntegrationPoint(t, n, r) {
    const i = this.treeAdapter.getNamespaceURI(n), a = this.treeAdapter.getAttrList(n);
    return Xy(t, i, a, r);
  }
  //Active formatting elements reconstruction
  /** @protected */
  _reconstructActiveFormattingElements() {
    const t = this.activeFormattingElements.entries.length;
    if (t) {
      const n = this.activeFormattingElements.entries.findIndex((i) => i.type === ei.Marker || this.openElements.contains(i.element)), r = n === -1 ? t - 1 : n - 1;
      for (let i = r; i >= 0; i--) {
        const a = this.activeFormattingElements.entries[i];
        this._insertElement(a.token, this.treeAdapter.getNamespaceURI(a.element)), a.element = this.openElements.current;
      }
    }
  }
  //Close elements
  /** @protected */
  _closeTableCell() {
    this.openElements.generateImpliedEndTags(), this.openElements.popUntilTableCellPopped(), this.activeFormattingElements.clearToLastMarker(), this.insertionMode = X.IN_ROW;
  }
  /** @protected */
  _closePElement() {
    this.openElements.generateImpliedEndTagsWithExclusion(m.P), this.openElements.popUntilTagNamePopped(m.P);
  }
  //Insertion modes
  /** @protected */
  _resetInsertionMode() {
    for (let t = this.openElements.stackTop; t >= 0; t--)
      switch (t === 0 && this.fragmentContext ? this.fragmentContextID : this.openElements.tagIDs[t]) {
        case m.TR: {
          this.insertionMode = X.IN_ROW;
          return;
        }
        case m.TBODY:
        case m.THEAD:
        case m.TFOOT: {
          this.insertionMode = X.IN_TABLE_BODY;
          return;
        }
        case m.CAPTION: {
          this.insertionMode = X.IN_CAPTION;
          return;
        }
        case m.COLGROUP: {
          this.insertionMode = X.IN_COLUMN_GROUP;
          return;
        }
        case m.TABLE: {
          this.insertionMode = X.IN_TABLE;
          return;
        }
        case m.BODY: {
          this.insertionMode = X.IN_BODY;
          return;
        }
        case m.FRAMESET: {
          this.insertionMode = X.IN_FRAMESET;
          return;
        }
        case m.SELECT: {
          this._resetInsertionModeForSelect(t);
          return;
        }
        case m.TEMPLATE: {
          this.insertionMode = this.tmplInsertionModeStack[0];
          return;
        }
        case m.HTML: {
          this.insertionMode = this.headElement ? X.AFTER_HEAD : X.BEFORE_HEAD;
          return;
        }
        case m.TD:
        case m.TH: {
          if (t > 0) {
            this.insertionMode = X.IN_CELL;
            return;
          }
          break;
        }
        case m.HEAD: {
          if (t > 0) {
            this.insertionMode = X.IN_HEAD;
            return;
          }
          break;
        }
      }
    this.insertionMode = X.IN_BODY;
  }
  /** @protected */
  _resetInsertionModeForSelect(t) {
    if (t > 0)
      for (let n = t - 1; n > 0; n--) {
        const r = this.openElements.tagIDs[n];
        if (r === m.TEMPLATE)
          break;
        if (r === m.TABLE) {
          this.insertionMode = X.IN_SELECT_IN_TABLE;
          return;
        }
      }
    this.insertionMode = X.IN_SELECT;
  }
  //Foster parenting
  /** @protected */
  _isElementCausesFosterParenting(t) {
    return E2.has(t);
  }
  /** @protected */
  _shouldFosterParentOnInsertion() {
    return this.fosterParentingEnabled && this.openElements.currentTagId !== void 0 && this._isElementCausesFosterParenting(this.openElements.currentTagId);
  }
  /** @protected */
  _findFosterParentingLocation() {
    for (let t = this.openElements.stackTop; t >= 0; t--) {
      const n = this.openElements.items[t];
      switch (this.openElements.tagIDs[t]) {
        case m.TEMPLATE: {
          if (this.treeAdapter.getNamespaceURI(n) === Ce.HTML)
            return { parent: this.treeAdapter.getTemplateContent(n), beforeElement: null };
          break;
        }
        case m.TABLE: {
          const r = this.treeAdapter.getParentNode(n);
          return r ? { parent: r, beforeElement: n } : { parent: this.openElements.items[t - 1], beforeElement: null };
        }
      }
    }
    return { parent: this.openElements.items[0], beforeElement: null };
  }
  /** @protected */
  _fosterParentElement(t) {
    const n = this._findFosterParentingLocation();
    n.beforeElement ? this.treeAdapter.insertBefore(n.parent, t, n.beforeElement) : this.treeAdapter.appendChild(n.parent, t);
  }
  //Special elements
  /** @protected */
  _isSpecialElement(t, n) {
    const r = this.treeAdapter.getNamespaceURI(t);
    return yy[r].has(n);
  }
  /** @internal */
  onCharacter(t) {
    if (this.skipNextNewLine = !1, this.tokenizer.inForeignNode) {
      k_(this, t);
      return;
    }
    switch (this.insertionMode) {
      case X.INITIAL: {
        Ks(this, t);
        break;
      }
      case X.BEFORE_HTML: {
        io(this, t);
        break;
      }
      case X.BEFORE_HEAD: {
        ao(this, t);
        break;
      }
      case X.IN_HEAD: {
        so(this, t);
        break;
      }
      case X.IN_HEAD_NO_SCRIPT: {
        oo(this, t);
        break;
      }
      case X.AFTER_HEAD: {
        uo(this, t);
        break;
      }
      case X.IN_BODY:
      case X.IN_CAPTION:
      case X.IN_CELL:
      case X.IN_TEMPLATE: {
        T2(this, t);
        break;
      }
      case X.TEXT:
      case X.IN_SELECT:
      case X.IN_SELECT_IN_TABLE: {
        this._insertCharacters(t);
        break;
      }
      case X.IN_TABLE:
      case X.IN_TABLE_BODY:
      case X.IN_ROW: {
        Zl(this, t);
        break;
      }
      case X.IN_TABLE_TEXT: {
        v2(this, t);
        break;
      }
      case X.IN_COLUMN_GROUP: {
        Ru(this, t);
        break;
      }
      case X.AFTER_BODY: {
        Du(this, t);
        break;
      }
      case X.AFTER_AFTER_BODY: {
        wu(this, t);
        break;
      }
    }
  }
  /** @internal */
  onNullCharacter(t) {
    if (this.skipNextNewLine = !1, this.tokenizer.inForeignNode) {
      L_(this, t);
      return;
    }
    switch (this.insertionMode) {
      case X.INITIAL: {
        Ks(this, t);
        break;
      }
      case X.BEFORE_HTML: {
        io(this, t);
        break;
      }
      case X.BEFORE_HEAD: {
        ao(this, t);
        break;
      }
      case X.IN_HEAD: {
        so(this, t);
        break;
      }
      case X.IN_HEAD_NO_SCRIPT: {
        oo(this, t);
        break;
      }
      case X.AFTER_HEAD: {
        uo(this, t);
        break;
      }
      case X.TEXT: {
        this._insertCharacters(t);
        break;
      }
      case X.IN_TABLE:
      case X.IN_TABLE_BODY:
      case X.IN_ROW: {
        Zl(this, t);
        break;
      }
      case X.IN_COLUMN_GROUP: {
        Ru(this, t);
        break;
      }
      case X.AFTER_BODY: {
        Du(this, t);
        break;
      }
      case X.AFTER_AFTER_BODY: {
        wu(this, t);
        break;
      }
    }
  }
  /** @internal */
  onComment(t) {
    if (this.skipNextNewLine = !1, this.currentNotInHTML) {
      Mc(this, t);
      return;
    }
    switch (this.insertionMode) {
      case X.INITIAL:
      case X.BEFORE_HTML:
      case X.BEFORE_HEAD:
      case X.IN_HEAD:
      case X.IN_HEAD_NO_SCRIPT:
      case X.AFTER_HEAD:
      case X.IN_BODY:
      case X.IN_TABLE:
      case X.IN_CAPTION:
      case X.IN_COLUMN_GROUP:
      case X.IN_TABLE_BODY:
      case X.IN_ROW:
      case X.IN_CELL:
      case X.IN_SELECT:
      case X.IN_SELECT_IN_TABLE:
      case X.IN_TEMPLATE:
      case X.IN_FRAMESET:
      case X.AFTER_FRAMESET: {
        Mc(this, t);
        break;
      }
      case X.IN_TABLE_TEXT: {
        Qs(this, t);
        break;
      }
      case X.AFTER_BODY: {
        sT(this, t);
        break;
      }
      case X.AFTER_AFTER_BODY:
      case X.AFTER_AFTER_FRAMESET: {
        oT(this, t);
        break;
      }
    }
  }
  /** @internal */
  onDoctype(t) {
    switch (this.skipNextNewLine = !1, this.insertionMode) {
      case X.INITIAL: {
        uT(this, t);
        break;
      }
      case X.BEFORE_HEAD:
      case X.IN_HEAD:
      case X.IN_HEAD_NO_SCRIPT:
      case X.AFTER_HEAD: {
        this._err(t, ye.misplacedDoctype);
        break;
      }
      case X.IN_TABLE_TEXT: {
        Qs(this, t);
        break;
      }
    }
  }
  /** @internal */
  onStartTag(t) {
    this.skipNextNewLine = !1, this.currentToken = t, this._processStartTag(t), t.selfClosing && !t.ackSelfClosing && this._err(t, ye.nonVoidHtmlElementStartTagWithTrailingSolidus);
  }
  /**
   * Processes a given start tag.
   *
   * `onStartTag` checks if a self-closing tag was recognized. When a token
   * is moved inbetween multiple insertion modes, this check for self-closing
   * could lead to false positives. To avoid this, `_processStartTag` is used
   * for nested calls.
   *
   * @param token The token to process.
   * @protected
   */
  _processStartTag(t) {
    this.shouldProcessStartTagTokenInForeignContent(t) ? C_(this, t) : this._startTagOutsideForeignContent(t);
  }
  /** @protected */
  _startTagOutsideForeignContent(t) {
    switch (this.insertionMode) {
      case X.INITIAL: {
        Ks(this, t);
        break;
      }
      case X.BEFORE_HTML: {
        lT(this, t);
        break;
      }
      case X.BEFORE_HEAD: {
        fT(this, t);
        break;
      }
      case X.IN_HEAD: {
        Ur(this, t);
        break;
      }
      case X.IN_HEAD_NO_SCRIPT: {
        pT(this, t);
        break;
      }
      case X.AFTER_HEAD: {
        gT(this, t);
        break;
      }
      case X.IN_BODY: {
        Yn(this, t);
        break;
      }
      case X.IN_TABLE: {
        fs(this, t);
        break;
      }
      case X.IN_TABLE_TEXT: {
        Qs(this, t);
        break;
      }
      case X.IN_CAPTION: {
        h_(this, t);
        break;
      }
      case X.IN_COLUMN_GROUP: {
        Ef(this, t);
        break;
      }
      case X.IN_TABLE_BODY: {
        Ju(this, t);
        break;
      }
      case X.IN_ROW: {
        Zu(this, t);
        break;
      }
      case X.IN_CELL: {
        m_(this, t);
        break;
      }
      case X.IN_SELECT: {
        k2(this, t);
        break;
      }
      case X.IN_SELECT_IN_TABLE: {
        b_(this, t);
        break;
      }
      case X.IN_TEMPLATE: {
        y_(this, t);
        break;
      }
      case X.AFTER_BODY: {
        __(this, t);
        break;
      }
      case X.IN_FRAMESET: {
        A_(this, t);
        break;
      }
      case X.AFTER_FRAMESET: {
        x_(this, t);
        break;
      }
      case X.AFTER_AFTER_BODY: {
        v_(this, t);
        break;
      }
      case X.AFTER_AFTER_FRAMESET: {
        S_(this, t);
        break;
      }
    }
  }
  /** @internal */
  onEndTag(t) {
    this.skipNextNewLine = !1, this.currentToken = t, this.currentNotInHTML ? I_(this, t) : this._endTagOutsideForeignContent(t);
  }
  /** @protected */
  _endTagOutsideForeignContent(t) {
    switch (this.insertionMode) {
      case X.INITIAL: {
        Ks(this, t);
        break;
      }
      case X.BEFORE_HTML: {
        cT(this, t);
        break;
      }
      case X.BEFORE_HEAD: {
        hT(this, t);
        break;
      }
      case X.IN_HEAD: {
        dT(this, t);
        break;
      }
      case X.IN_HEAD_NO_SCRIPT: {
        mT(this, t);
        break;
      }
      case X.AFTER_HEAD: {
        bT(this, t);
        break;
      }
      case X.IN_BODY: {
        Qu(this, t);
        break;
      }
      case X.TEXT: {
        n_(this, t);
        break;
      }
      case X.IN_TABLE: {
        mo(this, t);
        break;
      }
      case X.IN_TABLE_TEXT: {
        Qs(this, t);
        break;
      }
      case X.IN_CAPTION: {
        d_(this, t);
        break;
      }
      case X.IN_COLUMN_GROUP: {
        p_(this, t);
        break;
      }
      case X.IN_TABLE_BODY: {
        Fc(this, t);
        break;
      }
      case X.IN_ROW: {
        L2(this, t);
        break;
      }
      case X.IN_CELL: {
        g_(this, t);
        break;
      }
      case X.IN_SELECT: {
        C2(this, t);
        break;
      }
      case X.IN_SELECT_IN_TABLE: {
        E_(this, t);
        break;
      }
      case X.IN_TEMPLATE: {
        T_(this, t);
        break;
      }
      case X.AFTER_BODY: {
        P2(this, t);
        break;
      }
      case X.IN_FRAMESET: {
        w_(this, t);
        break;
      }
      case X.AFTER_FRAMESET: {
        N_(this, t);
        break;
      }
      case X.AFTER_AFTER_BODY: {
        wu(this, t);
        break;
      }
    }
  }
  /** @internal */
  onEof(t) {
    switch (this.insertionMode) {
      case X.INITIAL: {
        Ks(this, t);
        break;
      }
      case X.BEFORE_HTML: {
        io(this, t);
        break;
      }
      case X.BEFORE_HEAD: {
        ao(this, t);
        break;
      }
      case X.IN_HEAD: {
        so(this, t);
        break;
      }
      case X.IN_HEAD_NO_SCRIPT: {
        oo(this, t);
        break;
      }
      case X.AFTER_HEAD: {
        uo(this, t);
        break;
      }
      case X.IN_BODY:
      case X.IN_TABLE:
      case X.IN_CAPTION:
      case X.IN_COLUMN_GROUP:
      case X.IN_TABLE_BODY:
      case X.IN_ROW:
      case X.IN_CELL:
      case X.IN_SELECT:
      case X.IN_SELECT_IN_TABLE: {
        x2(this, t);
        break;
      }
      case X.TEXT: {
        r_(this, t);
        break;
      }
      case X.IN_TABLE_TEXT: {
        Qs(this, t);
        break;
      }
      case X.IN_TEMPLATE: {
        I2(this, t);
        break;
      }
      case X.AFTER_BODY:
      case X.IN_FRAMESET:
      case X.AFTER_FRAMESET:
      case X.AFTER_AFTER_BODY:
      case X.AFTER_AFTER_FRAMESET: {
        bf(this, t);
        break;
      }
    }
  }
  /** @internal */
  onWhitespaceCharacter(t) {
    if (this.skipNextNewLine && (this.skipNextNewLine = !1, t.chars.charCodeAt(0) === R.LINE_FEED)) {
      if (t.chars.length === 1)
        return;
      t.chars = t.chars.substr(1);
    }
    if (this.tokenizer.inForeignNode) {
      this._insertCharacters(t);
      return;
    }
    switch (this.insertionMode) {
      case X.IN_HEAD:
      case X.IN_HEAD_NO_SCRIPT:
      case X.AFTER_HEAD:
      case X.TEXT:
      case X.IN_COLUMN_GROUP:
      case X.IN_SELECT:
      case X.IN_SELECT_IN_TABLE:
      case X.IN_FRAMESET:
      case X.AFTER_FRAMESET: {
        this._insertCharacters(t);
        break;
      }
      case X.IN_BODY:
      case X.IN_CAPTION:
      case X.IN_CELL:
      case X.IN_TEMPLATE:
      case X.AFTER_BODY:
      case X.AFTER_AFTER_BODY:
      case X.AFTER_AFTER_FRAMESET: {
        y2(this, t);
        break;
      }
      case X.IN_TABLE:
      case X.IN_TABLE_BODY:
      case X.IN_ROW: {
        Zl(this, t);
        break;
      }
      case X.IN_TABLE_TEXT: {
        N2(this, t);
        break;
      }
    }
  }
}
function eT(e, t) {
  let n = e.activeFormattingElements.getElementEntryInScopeWithTagName(t.tagName);
  return n ? e.openElements.contains(n.element) ? e.openElements.hasInScope(t.tagID) || (n = null) : (e.activeFormattingElements.removeEntry(n), n = null) : w2(e, t), n;
}
function tT(e, t) {
  let n = null, r = e.openElements.stackTop;
  for (; r >= 0; r--) {
    const i = e.openElements.items[r];
    if (i === t.element)
      break;
    e._isSpecialElement(i, e.openElements.tagIDs[r]) && (n = i);
  }
  return n || (e.openElements.shortenToLength(Math.max(r, 0)), e.activeFormattingElements.removeEntry(t)), n;
}
function nT(e, t, n) {
  let r = t, i = e.openElements.getCommonAncestor(t);
  for (let a = 0, s = i; s !== n; a++, s = i) {
    i = e.openElements.getCommonAncestor(s);
    const o = e.activeFormattingElements.getElementEntry(s), u = o && a >= Jy;
    !o || u ? (u && e.activeFormattingElements.removeEntry(o), e.openElements.remove(s)) : (s = rT(e, o), r === t && (e.activeFormattingElements.bookmark = o), e.treeAdapter.detachNode(r), e.treeAdapter.appendChild(s, r), r = s);
  }
  return r;
}
function rT(e, t) {
  const n = e.treeAdapter.getNamespaceURI(t.element), r = e.treeAdapter.createElement(t.token.tagName, n, t.token.attrs);
  return e.openElements.replace(t.element, r), t.element = r, r;
}
function iT(e, t, n) {
  const r = e.treeAdapter.getTagName(t), i = ms(r);
  if (e._isElementCausesFosterParenting(i))
    e._fosterParentElement(n);
  else {
    const a = e.treeAdapter.getNamespaceURI(t);
    i === m.TEMPLATE && a === Ce.HTML && (t = e.treeAdapter.getTemplateContent(t)), e.treeAdapter.appendChild(t, n);
  }
}
function aT(e, t, n) {
  const r = e.treeAdapter.getNamespaceURI(n.element), { token: i } = n, a = e.treeAdapter.createElement(i.tagName, r, i.attrs);
  e._adoptNodes(t, a), e.treeAdapter.appendChild(t, a), e.activeFormattingElements.insertElementAfterBookmark(a, i), e.activeFormattingElements.removeEntry(n), e.openElements.remove(n.element), e.openElements.insertAfter(t, a, i.tagID);
}
function gf(e, t) {
  for (let n = 0; n < Qy; n++) {
    const r = eT(e, t);
    if (!r)
      break;
    const i = tT(e, r);
    if (!i)
      break;
    e.activeFormattingElements.bookmark = r;
    const a = nT(e, i, r.element), s = e.openElements.getCommonAncestor(r.element);
    e.treeAdapter.detachNode(a), s && iT(e, s, a), aT(e, i, r);
  }
}
function Mc(e, t) {
  e._appendCommentNode(t, e.openElements.currentTmplContentOrNode);
}
function sT(e, t) {
  e._appendCommentNode(t, e.openElements.items[0]);
}
function oT(e, t) {
  e._appendCommentNode(t, e.document);
}
function bf(e, t) {
  if (e.stopped = !0, t.location) {
    const n = e.fragmentContext ? 0 : 2;
    for (let r = e.openElements.stackTop; r >= n; r--)
      e._setEndLocation(e.openElements.items[r], t);
    if (!e.fragmentContext && e.openElements.stackTop >= 0) {
      const r = e.openElements.items[0], i = e.treeAdapter.getNodeSourceCodeLocation(r);
      if (i && !i.endTag && (e._setEndLocation(r, t), e.openElements.stackTop >= 1)) {
        const a = e.openElements.items[1], s = e.treeAdapter.getNodeSourceCodeLocation(a);
        s && !s.endTag && e._setEndLocation(a, t);
      }
    }
  }
}
function uT(e, t) {
  e._setDocumentType(t);
  const n = t.forceQuirks ? vr.QUIRKS : By(t);
  Fy(t) || e._err(t, ye.nonConformingDoctype), e.treeAdapter.setDocumentMode(e.document, n), e.insertionMode = X.BEFORE_HTML;
}
function Ks(e, t) {
  e._err(t, ye.missingDoctype, !0), e.treeAdapter.setDocumentMode(e.document, vr.QUIRKS), e.insertionMode = X.BEFORE_HTML, e._processToken(t);
}
function lT(e, t) {
  t.tagID === m.HTML ? (e._insertElement(t, Ce.HTML), e.insertionMode = X.BEFORE_HEAD) : io(e, t);
}
function cT(e, t) {
  const n = t.tagID;
  (n === m.HTML || n === m.HEAD || n === m.BODY || n === m.BR) && io(e, t);
}
function io(e, t) {
  e._insertFakeRootElement(), e.insertionMode = X.BEFORE_HEAD, e._processToken(t);
}
function fT(e, t) {
  switch (t.tagID) {
    case m.HTML: {
      Yn(e, t);
      break;
    }
    case m.HEAD: {
      e._insertElement(t, Ce.HTML), e.headElement = e.openElements.current, e.insertionMode = X.IN_HEAD;
      break;
    }
    default:
      ao(e, t);
  }
}
function hT(e, t) {
  const n = t.tagID;
  n === m.HEAD || n === m.BODY || n === m.HTML || n === m.BR ? ao(e, t) : e._err(t, ye.endTagWithoutMatchingOpenElement);
}
function ao(e, t) {
  e._insertFakeElement(ce.HEAD, m.HEAD), e.headElement = e.openElements.current, e.insertionMode = X.IN_HEAD, e._processToken(t);
}
function Ur(e, t) {
  switch (t.tagID) {
    case m.HTML: {
      Yn(e, t);
      break;
    }
    case m.BASE:
    case m.BASEFONT:
    case m.BGSOUND:
    case m.LINK:
    case m.META: {
      e._appendElement(t, Ce.HTML), t.ackSelfClosing = !0;
      break;
    }
    case m.TITLE: {
      e._switchToTextParsing(t, pn.RCDATA);
      break;
    }
    case m.NOSCRIPT: {
      e.options.scriptingEnabled ? e._switchToTextParsing(t, pn.RAWTEXT) : (e._insertElement(t, Ce.HTML), e.insertionMode = X.IN_HEAD_NO_SCRIPT);
      break;
    }
    case m.NOFRAMES:
    case m.STYLE: {
      e._switchToTextParsing(t, pn.RAWTEXT);
      break;
    }
    case m.SCRIPT: {
      e._switchToTextParsing(t, pn.SCRIPT_DATA);
      break;
    }
    case m.TEMPLATE: {
      e._insertTemplate(t), e.activeFormattingElements.insertMarker(), e.framesetOk = !1, e.insertionMode = X.IN_TEMPLATE, e.tmplInsertionModeStack.unshift(X.IN_TEMPLATE);
      break;
    }
    case m.HEAD: {
      e._err(t, ye.misplacedStartTagForHeadElement);
      break;
    }
    default:
      so(e, t);
  }
}
function dT(e, t) {
  switch (t.tagID) {
    case m.HEAD: {
      e.openElements.pop(), e.insertionMode = X.AFTER_HEAD;
      break;
    }
    case m.BODY:
    case m.BR:
    case m.HTML: {
      so(e, t);
      break;
    }
    case m.TEMPLATE: {
      Ca(e, t);
      break;
    }
    default:
      e._err(t, ye.endTagWithoutMatchingOpenElement);
  }
}
function Ca(e, t) {
  e.openElements.tmplCount > 0 ? (e.openElements.generateImpliedEndTagsThoroughly(), e.openElements.currentTagId !== m.TEMPLATE && e._err(t, ye.closingOfElementWithOpenChildElements), e.openElements.popUntilTagNamePopped(m.TEMPLATE), e.activeFormattingElements.clearToLastMarker(), e.tmplInsertionModeStack.shift(), e._resetInsertionMode()) : e._err(t, ye.endTagWithoutMatchingOpenElement);
}
function so(e, t) {
  e.openElements.pop(), e.insertionMode = X.AFTER_HEAD, e._processToken(t);
}
function pT(e, t) {
  switch (t.tagID) {
    case m.HTML: {
      Yn(e, t);
      break;
    }
    case m.BASEFONT:
    case m.BGSOUND:
    case m.HEAD:
    case m.LINK:
    case m.META:
    case m.NOFRAMES:
    case m.STYLE: {
      Ur(e, t);
      break;
    }
    case m.NOSCRIPT: {
      e._err(t, ye.nestedNoscriptInHead);
      break;
    }
    default:
      oo(e, t);
  }
}
function mT(e, t) {
  switch (t.tagID) {
    case m.NOSCRIPT: {
      e.openElements.pop(), e.insertionMode = X.IN_HEAD;
      break;
    }
    case m.BR: {
      oo(e, t);
      break;
    }
    default:
      e._err(t, ye.endTagWithoutMatchingOpenElement);
  }
}
function oo(e, t) {
  const n = t.type === St.EOF ? ye.openElementsLeftAfterEof : ye.disallowedContentInNoscriptInHead;
  e._err(t, n), e.openElements.pop(), e.insertionMode = X.IN_HEAD, e._processToken(t);
}
function gT(e, t) {
  switch (t.tagID) {
    case m.HTML: {
      Yn(e, t);
      break;
    }
    case m.BODY: {
      e._insertElement(t, Ce.HTML), e.framesetOk = !1, e.insertionMode = X.IN_BODY;
      break;
    }
    case m.FRAMESET: {
      e._insertElement(t, Ce.HTML), e.insertionMode = X.IN_FRAMESET;
      break;
    }
    case m.BASE:
    case m.BASEFONT:
    case m.BGSOUND:
    case m.LINK:
    case m.META:
    case m.NOFRAMES:
    case m.SCRIPT:
    case m.STYLE:
    case m.TEMPLATE:
    case m.TITLE: {
      e._err(t, ye.abandonedHeadElementChild), e.openElements.push(e.headElement, m.HEAD), Ur(e, t), e.openElements.remove(e.headElement);
      break;
    }
    case m.HEAD: {
      e._err(t, ye.misplacedStartTagForHeadElement);
      break;
    }
    default:
      uo(e, t);
  }
}
function bT(e, t) {
  switch (t.tagID) {
    case m.BODY:
    case m.HTML:
    case m.BR: {
      uo(e, t);
      break;
    }
    case m.TEMPLATE: {
      Ca(e, t);
      break;
    }
    default:
      e._err(t, ye.endTagWithoutMatchingOpenElement);
  }
}
function uo(e, t) {
  e._insertFakeElement(ce.BODY, m.BODY), e.insertionMode = X.IN_BODY, Ku(e, t);
}
function Ku(e, t) {
  switch (t.type) {
    case St.CHARACTER: {
      T2(e, t);
      break;
    }
    case St.WHITESPACE_CHARACTER: {
      y2(e, t);
      break;
    }
    case St.COMMENT: {
      Mc(e, t);
      break;
    }
    case St.START_TAG: {
      Yn(e, t);
      break;
    }
    case St.END_TAG: {
      Qu(e, t);
      break;
    }
    case St.EOF: {
      x2(e, t);
      break;
    }
  }
}
function y2(e, t) {
  e._reconstructActiveFormattingElements(), e._insertCharacters(t);
}
function T2(e, t) {
  e._reconstructActiveFormattingElements(), e._insertCharacters(t), e.framesetOk = !1;
}
function ET(e, t) {
  e.openElements.tmplCount === 0 && e.treeAdapter.adoptAttributes(e.openElements.items[0], t.attrs);
}
function yT(e, t) {
  const n = e.openElements.tryPeekProperlyNestedBodyElement();
  n && e.openElements.tmplCount === 0 && (e.framesetOk = !1, e.treeAdapter.adoptAttributes(n, t.attrs));
}
function TT(e, t) {
  const n = e.openElements.tryPeekProperlyNestedBodyElement();
  e.framesetOk && n && (e.treeAdapter.detachNode(n), e.openElements.popAllUpToHtmlElement(), e._insertElement(t, Ce.HTML), e.insertionMode = X.IN_FRAMESET);
}
function _T(e, t) {
  e.openElements.hasInButtonScope(m.P) && e._closePElement(), e._insertElement(t, Ce.HTML);
}
function AT(e, t) {
  e.openElements.hasInButtonScope(m.P) && e._closePElement(), e.openElements.currentTagId !== void 0 && Dc.has(e.openElements.currentTagId) && e.openElements.pop(), e._insertElement(t, Ce.HTML);
}
function wT(e, t) {
  e.openElements.hasInButtonScope(m.P) && e._closePElement(), e._insertElement(t, Ce.HTML), e.skipNextNewLine = !0, e.framesetOk = !1;
}
function xT(e, t) {
  const n = e.openElements.tmplCount > 0;
  (!e.formElement || n) && (e.openElements.hasInButtonScope(m.P) && e._closePElement(), e._insertElement(t, Ce.HTML), n || (e.formElement = e.openElements.current));
}
function NT(e, t) {
  e.framesetOk = !1;
  const n = t.tagID;
  for (let r = e.openElements.stackTop; r >= 0; r--) {
    const i = e.openElements.tagIDs[r];
    if (n === m.LI && i === m.LI || (n === m.DD || n === m.DT) && (i === m.DD || i === m.DT)) {
      e.openElements.generateImpliedEndTagsWithExclusion(i), e.openElements.popUntilTagNamePopped(i);
      break;
    }
    if (i !== m.ADDRESS && i !== m.DIV && i !== m.P && e._isSpecialElement(e.openElements.items[r], i))
      break;
  }
  e.openElements.hasInButtonScope(m.P) && e._closePElement(), e._insertElement(t, Ce.HTML);
}
function vT(e, t) {
  e.openElements.hasInButtonScope(m.P) && e._closePElement(), e._insertElement(t, Ce.HTML), e.tokenizer.state = pn.PLAINTEXT;
}
function ST(e, t) {
  e.openElements.hasInScope(m.BUTTON) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(m.BUTTON)), e._reconstructActiveFormattingElements(), e._insertElement(t, Ce.HTML), e.framesetOk = !1;
}
function LT(e, t) {
  const n = e.activeFormattingElements.getElementEntryInScopeWithTagName(ce.A);
  n && (gf(e, t), e.openElements.remove(n.element), e.activeFormattingElements.removeEntry(n)), e._reconstructActiveFormattingElements(), e._insertElement(t, Ce.HTML), e.activeFormattingElements.pushElement(e.openElements.current, t);
}
function kT(e, t) {
  e._reconstructActiveFormattingElements(), e._insertElement(t, Ce.HTML), e.activeFormattingElements.pushElement(e.openElements.current, t);
}
function CT(e, t) {
  e._reconstructActiveFormattingElements(), e.openElements.hasInScope(m.NOBR) && (gf(e, t), e._reconstructActiveFormattingElements()), e._insertElement(t, Ce.HTML), e.activeFormattingElements.pushElement(e.openElements.current, t);
}
function IT(e, t) {
  e._reconstructActiveFormattingElements(), e._insertElement(t, Ce.HTML), e.activeFormattingElements.insertMarker(), e.framesetOk = !1;
}
function PT(e, t) {
  e.treeAdapter.getDocumentMode(e.document) !== vr.QUIRKS && e.openElements.hasInButtonScope(m.P) && e._closePElement(), e._insertElement(t, Ce.HTML), e.framesetOk = !1, e.insertionMode = X.IN_TABLE;
}
function _2(e, t) {
  e._reconstructActiveFormattingElements(), e._appendElement(t, Ce.HTML), e.framesetOk = !1, t.ackSelfClosing = !0;
}
function A2(e) {
  const t = c2(e, xa.TYPE);
  return t != null && t.toLowerCase() === Ky;
}
function OT(e, t) {
  e._reconstructActiveFormattingElements(), e._appendElement(t, Ce.HTML), A2(t) || (e.framesetOk = !1), t.ackSelfClosing = !0;
}
function RT(e, t) {
  e._appendElement(t, Ce.HTML), t.ackSelfClosing = !0;
}
function DT(e, t) {
  e.openElements.hasInButtonScope(m.P) && e._closePElement(), e._appendElement(t, Ce.HTML), e.framesetOk = !1, t.ackSelfClosing = !0;
}
function MT(e, t) {
  t.tagName = ce.IMG, t.tagID = m.IMG, _2(e, t);
}
function FT(e, t) {
  e._insertElement(t, Ce.HTML), e.skipNextNewLine = !0, e.tokenizer.state = pn.RCDATA, e.originalInsertionMode = e.insertionMode, e.framesetOk = !1, e.insertionMode = X.TEXT;
}
function BT(e, t) {
  e.openElements.hasInButtonScope(m.P) && e._closePElement(), e._reconstructActiveFormattingElements(), e.framesetOk = !1, e._switchToTextParsing(t, pn.RAWTEXT);
}
function UT(e, t) {
  e.framesetOk = !1, e._switchToTextParsing(t, pn.RAWTEXT);
}
function y0(e, t) {
  e._switchToTextParsing(t, pn.RAWTEXT);
}
function HT(e, t) {
  e._reconstructActiveFormattingElements(), e._insertElement(t, Ce.HTML), e.framesetOk = !1, e.insertionMode = e.insertionMode === X.IN_TABLE || e.insertionMode === X.IN_CAPTION || e.insertionMode === X.IN_TABLE_BODY || e.insertionMode === X.IN_ROW || e.insertionMode === X.IN_CELL ? X.IN_SELECT_IN_TABLE : X.IN_SELECT;
}
function jT(e, t) {
  e.openElements.currentTagId === m.OPTION && e.openElements.pop(), e._reconstructActiveFormattingElements(), e._insertElement(t, Ce.HTML);
}
function qT(e, t) {
  e.openElements.hasInScope(m.RUBY) && e.openElements.generateImpliedEndTags(), e._insertElement(t, Ce.HTML);
}
function zT(e, t) {
  e.openElements.hasInScope(m.RUBY) && e.openElements.generateImpliedEndTagsWithExclusion(m.RTC), e._insertElement(t, Ce.HTML);
}
function YT(e, t) {
  e._reconstructActiveFormattingElements(), g2(t), mf(t), t.selfClosing ? e._appendElement(t, Ce.MATHML) : e._insertElement(t, Ce.MATHML), t.ackSelfClosing = !0;
}
function WT(e, t) {
  e._reconstructActiveFormattingElements(), b2(t), mf(t), t.selfClosing ? e._appendElement(t, Ce.SVG) : e._insertElement(t, Ce.SVG), t.ackSelfClosing = !0;
}
function T0(e, t) {
  e._reconstructActiveFormattingElements(), e._insertElement(t, Ce.HTML);
}
function Yn(e, t) {
  switch (t.tagID) {
    case m.I:
    case m.S:
    case m.B:
    case m.U:
    case m.EM:
    case m.TT:
    case m.BIG:
    case m.CODE:
    case m.FONT:
    case m.SMALL:
    case m.STRIKE:
    case m.STRONG: {
      kT(e, t);
      break;
    }
    case m.A: {
      LT(e, t);
      break;
    }
    case m.H1:
    case m.H2:
    case m.H3:
    case m.H4:
    case m.H5:
    case m.H6: {
      AT(e, t);
      break;
    }
    case m.P:
    case m.DL:
    case m.OL:
    case m.UL:
    case m.DIV:
    case m.DIR:
    case m.NAV:
    case m.MAIN:
    case m.MENU:
    case m.ASIDE:
    case m.CENTER:
    case m.FIGURE:
    case m.FOOTER:
    case m.HEADER:
    case m.HGROUP:
    case m.DIALOG:
    case m.DETAILS:
    case m.ADDRESS:
    case m.ARTICLE:
    case m.SEARCH:
    case m.SECTION:
    case m.SUMMARY:
    case m.FIELDSET:
    case m.BLOCKQUOTE:
    case m.FIGCAPTION: {
      _T(e, t);
      break;
    }
    case m.LI:
    case m.DD:
    case m.DT: {
      NT(e, t);
      break;
    }
    case m.BR:
    case m.IMG:
    case m.WBR:
    case m.AREA:
    case m.EMBED:
    case m.KEYGEN: {
      _2(e, t);
      break;
    }
    case m.HR: {
      DT(e, t);
      break;
    }
    case m.RB:
    case m.RTC: {
      qT(e, t);
      break;
    }
    case m.RT:
    case m.RP: {
      zT(e, t);
      break;
    }
    case m.PRE:
    case m.LISTING: {
      wT(e, t);
      break;
    }
    case m.XMP: {
      BT(e, t);
      break;
    }
    case m.SVG: {
      WT(e, t);
      break;
    }
    case m.HTML: {
      ET(e, t);
      break;
    }
    case m.BASE:
    case m.LINK:
    case m.META:
    case m.STYLE:
    case m.TITLE:
    case m.SCRIPT:
    case m.BGSOUND:
    case m.BASEFONT:
    case m.TEMPLATE: {
      Ur(e, t);
      break;
    }
    case m.BODY: {
      yT(e, t);
      break;
    }
    case m.FORM: {
      xT(e, t);
      break;
    }
    case m.NOBR: {
      CT(e, t);
      break;
    }
    case m.MATH: {
      YT(e, t);
      break;
    }
    case m.TABLE: {
      PT(e, t);
      break;
    }
    case m.INPUT: {
      OT(e, t);
      break;
    }
    case m.PARAM:
    case m.TRACK:
    case m.SOURCE: {
      RT(e, t);
      break;
    }
    case m.IMAGE: {
      MT(e, t);
      break;
    }
    case m.BUTTON: {
      ST(e, t);
      break;
    }
    case m.APPLET:
    case m.OBJECT:
    case m.MARQUEE: {
      IT(e, t);
      break;
    }
    case m.IFRAME: {
      UT(e, t);
      break;
    }
    case m.SELECT: {
      HT(e, t);
      break;
    }
    case m.OPTION:
    case m.OPTGROUP: {
      jT(e, t);
      break;
    }
    case m.NOEMBED:
    case m.NOFRAMES: {
      y0(e, t);
      break;
    }
    case m.FRAMESET: {
      TT(e, t);
      break;
    }
    case m.TEXTAREA: {
      FT(e, t);
      break;
    }
    case m.NOSCRIPT: {
      e.options.scriptingEnabled ? y0(e, t) : T0(e, t);
      break;
    }
    case m.PLAINTEXT: {
      vT(e, t);
      break;
    }
    case m.COL:
    case m.TH:
    case m.TD:
    case m.TR:
    case m.HEAD:
    case m.FRAME:
    case m.TBODY:
    case m.TFOOT:
    case m.THEAD:
    case m.CAPTION:
    case m.COLGROUP:
      break;
    default:
      T0(e, t);
  }
}
function VT(e, t) {
  if (e.openElements.hasInScope(m.BODY) && (e.insertionMode = X.AFTER_BODY, e.options.sourceCodeLocationInfo)) {
    const n = e.openElements.tryPeekProperlyNestedBodyElement();
    n && e._setEndLocation(n, t);
  }
}
function GT(e, t) {
  e.openElements.hasInScope(m.BODY) && (e.insertionMode = X.AFTER_BODY, P2(e, t));
}
function $T(e, t) {
  const n = t.tagID;
  e.openElements.hasInScope(n) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(n));
}
function XT(e) {
  const t = e.openElements.tmplCount > 0, { formElement: n } = e;
  t || (e.formElement = null), (n || t) && e.openElements.hasInScope(m.FORM) && (e.openElements.generateImpliedEndTags(), t ? e.openElements.popUntilTagNamePopped(m.FORM) : n && e.openElements.remove(n));
}
function KT(e) {
  e.openElements.hasInButtonScope(m.P) || e._insertFakeElement(ce.P, m.P), e._closePElement();
}
function QT(e) {
  e.openElements.hasInListItemScope(m.LI) && (e.openElements.generateImpliedEndTagsWithExclusion(m.LI), e.openElements.popUntilTagNamePopped(m.LI));
}
function JT(e, t) {
  const n = t.tagID;
  e.openElements.hasInScope(n) && (e.openElements.generateImpliedEndTagsWithExclusion(n), e.openElements.popUntilTagNamePopped(n));
}
function ZT(e) {
  e.openElements.hasNumberedHeaderInScope() && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilNumberedHeaderPopped());
}
function e_(e, t) {
  const n = t.tagID;
  e.openElements.hasInScope(n) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(n), e.activeFormattingElements.clearToLastMarker());
}
function t_(e) {
  e._reconstructActiveFormattingElements(), e._insertFakeElement(ce.BR, m.BR), e.openElements.pop(), e.framesetOk = !1;
}
function w2(e, t) {
  const n = t.tagName, r = t.tagID;
  for (let i = e.openElements.stackTop; i > 0; i--) {
    const a = e.openElements.items[i], s = e.openElements.tagIDs[i];
    if (r === s && (r !== m.UNKNOWN || e.treeAdapter.getTagName(a) === n)) {
      e.openElements.generateImpliedEndTagsWithExclusion(r), e.openElements.stackTop >= i && e.openElements.shortenToLength(i);
      break;
    }
    if (e._isSpecialElement(a, s))
      break;
  }
}
function Qu(e, t) {
  switch (t.tagID) {
    case m.A:
    case m.B:
    case m.I:
    case m.S:
    case m.U:
    case m.EM:
    case m.TT:
    case m.BIG:
    case m.CODE:
    case m.FONT:
    case m.NOBR:
    case m.SMALL:
    case m.STRIKE:
    case m.STRONG: {
      gf(e, t);
      break;
    }
    case m.P: {
      KT(e);
      break;
    }
    case m.DL:
    case m.UL:
    case m.OL:
    case m.DIR:
    case m.DIV:
    case m.NAV:
    case m.PRE:
    case m.MAIN:
    case m.MENU:
    case m.ASIDE:
    case m.BUTTON:
    case m.CENTER:
    case m.FIGURE:
    case m.FOOTER:
    case m.HEADER:
    case m.HGROUP:
    case m.DIALOG:
    case m.ADDRESS:
    case m.ARTICLE:
    case m.DETAILS:
    case m.SEARCH:
    case m.SECTION:
    case m.SUMMARY:
    case m.LISTING:
    case m.FIELDSET:
    case m.BLOCKQUOTE:
    case m.FIGCAPTION: {
      $T(e, t);
      break;
    }
    case m.LI: {
      QT(e);
      break;
    }
    case m.DD:
    case m.DT: {
      JT(e, t);
      break;
    }
    case m.H1:
    case m.H2:
    case m.H3:
    case m.H4:
    case m.H5:
    case m.H6: {
      ZT(e);
      break;
    }
    case m.BR: {
      t_(e);
      break;
    }
    case m.BODY: {
      VT(e, t);
      break;
    }
    case m.HTML: {
      GT(e, t);
      break;
    }
    case m.FORM: {
      XT(e);
      break;
    }
    case m.APPLET:
    case m.OBJECT:
    case m.MARQUEE: {
      e_(e, t);
      break;
    }
    case m.TEMPLATE: {
      Ca(e, t);
      break;
    }
    default:
      w2(e, t);
  }
}
function x2(e, t) {
  e.tmplInsertionModeStack.length > 0 ? I2(e, t) : bf(e, t);
}
function n_(e, t) {
  var n;
  t.tagID === m.SCRIPT && ((n = e.scriptHandler) === null || n === void 0 || n.call(e, e.openElements.current)), e.openElements.pop(), e.insertionMode = e.originalInsertionMode;
}
function r_(e, t) {
  e._err(t, ye.eofInElementThatCanContainOnlyText), e.openElements.pop(), e.insertionMode = e.originalInsertionMode, e.onEof(t);
}
function Zl(e, t) {
  if (e.openElements.currentTagId !== void 0 && E2.has(e.openElements.currentTagId))
    switch (e.pendingCharacterTokens.length = 0, e.hasNonWhitespacePendingCharacterToken = !1, e.originalInsertionMode = e.insertionMode, e.insertionMode = X.IN_TABLE_TEXT, t.type) {
      case St.CHARACTER: {
        v2(e, t);
        break;
      }
      case St.WHITESPACE_CHARACTER: {
        N2(e, t);
        break;
      }
    }
  else
    Ao(e, t);
}
function i_(e, t) {
  e.openElements.clearBackToTableContext(), e.activeFormattingElements.insertMarker(), e._insertElement(t, Ce.HTML), e.insertionMode = X.IN_CAPTION;
}
function a_(e, t) {
  e.openElements.clearBackToTableContext(), e._insertElement(t, Ce.HTML), e.insertionMode = X.IN_COLUMN_GROUP;
}
function s_(e, t) {
  e.openElements.clearBackToTableContext(), e._insertFakeElement(ce.COLGROUP, m.COLGROUP), e.insertionMode = X.IN_COLUMN_GROUP, Ef(e, t);
}
function o_(e, t) {
  e.openElements.clearBackToTableContext(), e._insertElement(t, Ce.HTML), e.insertionMode = X.IN_TABLE_BODY;
}
function u_(e, t) {
  e.openElements.clearBackToTableContext(), e._insertFakeElement(ce.TBODY, m.TBODY), e.insertionMode = X.IN_TABLE_BODY, Ju(e, t);
}
function l_(e, t) {
  e.openElements.hasInTableScope(m.TABLE) && (e.openElements.popUntilTagNamePopped(m.TABLE), e._resetInsertionMode(), e._processStartTag(t));
}
function c_(e, t) {
  A2(t) ? e._appendElement(t, Ce.HTML) : Ao(e, t), t.ackSelfClosing = !0;
}
function f_(e, t) {
  !e.formElement && e.openElements.tmplCount === 0 && (e._insertElement(t, Ce.HTML), e.formElement = e.openElements.current, e.openElements.pop());
}
function fs(e, t) {
  switch (t.tagID) {
    case m.TD:
    case m.TH:
    case m.TR: {
      u_(e, t);
      break;
    }
    case m.STYLE:
    case m.SCRIPT:
    case m.TEMPLATE: {
      Ur(e, t);
      break;
    }
    case m.COL: {
      s_(e, t);
      break;
    }
    case m.FORM: {
      f_(e, t);
      break;
    }
    case m.TABLE: {
      l_(e, t);
      break;
    }
    case m.TBODY:
    case m.TFOOT:
    case m.THEAD: {
      o_(e, t);
      break;
    }
    case m.INPUT: {
      c_(e, t);
      break;
    }
    case m.CAPTION: {
      i_(e, t);
      break;
    }
    case m.COLGROUP: {
      a_(e, t);
      break;
    }
    default:
      Ao(e, t);
  }
}
function mo(e, t) {
  switch (t.tagID) {
    case m.TABLE: {
      e.openElements.hasInTableScope(m.TABLE) && (e.openElements.popUntilTagNamePopped(m.TABLE), e._resetInsertionMode());
      break;
    }
    case m.TEMPLATE: {
      Ca(e, t);
      break;
    }
    case m.BODY:
    case m.CAPTION:
    case m.COL:
    case m.COLGROUP:
    case m.HTML:
    case m.TBODY:
    case m.TD:
    case m.TFOOT:
    case m.TH:
    case m.THEAD:
    case m.TR:
      break;
    default:
      Ao(e, t);
  }
}
function Ao(e, t) {
  const n = e.fosterParentingEnabled;
  e.fosterParentingEnabled = !0, Ku(e, t), e.fosterParentingEnabled = n;
}
function N2(e, t) {
  e.pendingCharacterTokens.push(t);
}
function v2(e, t) {
  e.pendingCharacterTokens.push(t), e.hasNonWhitespacePendingCharacterToken = !0;
}
function Qs(e, t) {
  let n = 0;
  if (e.hasNonWhitespacePendingCharacterToken)
    for (; n < e.pendingCharacterTokens.length; n++)
      Ao(e, e.pendingCharacterTokens[n]);
  else
    for (; n < e.pendingCharacterTokens.length; n++)
      e._insertCharacters(e.pendingCharacterTokens[n]);
  e.insertionMode = e.originalInsertionMode, e._processToken(t);
}
const S2 = /* @__PURE__ */ new Set([m.CAPTION, m.COL, m.COLGROUP, m.TBODY, m.TD, m.TFOOT, m.TH, m.THEAD, m.TR]);
function h_(e, t) {
  const n = t.tagID;
  S2.has(n) ? e.openElements.hasInTableScope(m.CAPTION) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(m.CAPTION), e.activeFormattingElements.clearToLastMarker(), e.insertionMode = X.IN_TABLE, fs(e, t)) : Yn(e, t);
}
function d_(e, t) {
  const n = t.tagID;
  switch (n) {
    case m.CAPTION:
    case m.TABLE: {
      e.openElements.hasInTableScope(m.CAPTION) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(m.CAPTION), e.activeFormattingElements.clearToLastMarker(), e.insertionMode = X.IN_TABLE, n === m.TABLE && mo(e, t));
      break;
    }
    case m.BODY:
    case m.COL:
    case m.COLGROUP:
    case m.HTML:
    case m.TBODY:
    case m.TD:
    case m.TFOOT:
    case m.TH:
    case m.THEAD:
    case m.TR:
      break;
    default:
      Qu(e, t);
  }
}
function Ef(e, t) {
  switch (t.tagID) {
    case m.HTML: {
      Yn(e, t);
      break;
    }
    case m.COL: {
      e._appendElement(t, Ce.HTML), t.ackSelfClosing = !0;
      break;
    }
    case m.TEMPLATE: {
      Ur(e, t);
      break;
    }
    default:
      Ru(e, t);
  }
}
function p_(e, t) {
  switch (t.tagID) {
    case m.COLGROUP: {
      e.openElements.currentTagId === m.COLGROUP && (e.openElements.pop(), e.insertionMode = X.IN_TABLE);
      break;
    }
    case m.TEMPLATE: {
      Ca(e, t);
      break;
    }
    case m.COL:
      break;
    default:
      Ru(e, t);
  }
}
function Ru(e, t) {
  e.openElements.currentTagId === m.COLGROUP && (e.openElements.pop(), e.insertionMode = X.IN_TABLE, e._processToken(t));
}
function Ju(e, t) {
  switch (t.tagID) {
    case m.TR: {
      e.openElements.clearBackToTableBodyContext(), e._insertElement(t, Ce.HTML), e.insertionMode = X.IN_ROW;
      break;
    }
    case m.TH:
    case m.TD: {
      e.openElements.clearBackToTableBodyContext(), e._insertFakeElement(ce.TR, m.TR), e.insertionMode = X.IN_ROW, Zu(e, t);
      break;
    }
    case m.CAPTION:
    case m.COL:
    case m.COLGROUP:
    case m.TBODY:
    case m.TFOOT:
    case m.THEAD: {
      e.openElements.hasTableBodyContextInTableScope() && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), e.insertionMode = X.IN_TABLE, fs(e, t));
      break;
    }
    default:
      fs(e, t);
  }
}
function Fc(e, t) {
  const n = t.tagID;
  switch (t.tagID) {
    case m.TBODY:
    case m.TFOOT:
    case m.THEAD: {
      e.openElements.hasInTableScope(n) && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), e.insertionMode = X.IN_TABLE);
      break;
    }
    case m.TABLE: {
      e.openElements.hasTableBodyContextInTableScope() && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), e.insertionMode = X.IN_TABLE, mo(e, t));
      break;
    }
    case m.BODY:
    case m.CAPTION:
    case m.COL:
    case m.COLGROUP:
    case m.HTML:
    case m.TD:
    case m.TH:
    case m.TR:
      break;
    default:
      mo(e, t);
  }
}
function Zu(e, t) {
  switch (t.tagID) {
    case m.TH:
    case m.TD: {
      e.openElements.clearBackToTableRowContext(), e._insertElement(t, Ce.HTML), e.insertionMode = X.IN_CELL, e.activeFormattingElements.insertMarker();
      break;
    }
    case m.CAPTION:
    case m.COL:
    case m.COLGROUP:
    case m.TBODY:
    case m.TFOOT:
    case m.THEAD:
    case m.TR: {
      e.openElements.hasInTableScope(m.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = X.IN_TABLE_BODY, Ju(e, t));
      break;
    }
    default:
      fs(e, t);
  }
}
function L2(e, t) {
  switch (t.tagID) {
    case m.TR: {
      e.openElements.hasInTableScope(m.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = X.IN_TABLE_BODY);
      break;
    }
    case m.TABLE: {
      e.openElements.hasInTableScope(m.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = X.IN_TABLE_BODY, Fc(e, t));
      break;
    }
    case m.TBODY:
    case m.TFOOT:
    case m.THEAD: {
      (e.openElements.hasInTableScope(t.tagID) || e.openElements.hasInTableScope(m.TR)) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = X.IN_TABLE_BODY, Fc(e, t));
      break;
    }
    case m.BODY:
    case m.CAPTION:
    case m.COL:
    case m.COLGROUP:
    case m.HTML:
    case m.TD:
    case m.TH:
      break;
    default:
      mo(e, t);
  }
}
function m_(e, t) {
  const n = t.tagID;
  S2.has(n) ? (e.openElements.hasInTableScope(m.TD) || e.openElements.hasInTableScope(m.TH)) && (e._closeTableCell(), Zu(e, t)) : Yn(e, t);
}
function g_(e, t) {
  const n = t.tagID;
  switch (n) {
    case m.TD:
    case m.TH: {
      e.openElements.hasInTableScope(n) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(n), e.activeFormattingElements.clearToLastMarker(), e.insertionMode = X.IN_ROW);
      break;
    }
    case m.TABLE:
    case m.TBODY:
    case m.TFOOT:
    case m.THEAD:
    case m.TR: {
      e.openElements.hasInTableScope(n) && (e._closeTableCell(), L2(e, t));
      break;
    }
    case m.BODY:
    case m.CAPTION:
    case m.COL:
    case m.COLGROUP:
    case m.HTML:
      break;
    default:
      Qu(e, t);
  }
}
function k2(e, t) {
  switch (t.tagID) {
    case m.HTML: {
      Yn(e, t);
      break;
    }
    case m.OPTION: {
      e.openElements.currentTagId === m.OPTION && e.openElements.pop(), e._insertElement(t, Ce.HTML);
      break;
    }
    case m.OPTGROUP: {
      e.openElements.currentTagId === m.OPTION && e.openElements.pop(), e.openElements.currentTagId === m.OPTGROUP && e.openElements.pop(), e._insertElement(t, Ce.HTML);
      break;
    }
    case m.HR: {
      e.openElements.currentTagId === m.OPTION && e.openElements.pop(), e.openElements.currentTagId === m.OPTGROUP && e.openElements.pop(), e._appendElement(t, Ce.HTML), t.ackSelfClosing = !0;
      break;
    }
    case m.INPUT:
    case m.KEYGEN:
    case m.TEXTAREA:
    case m.SELECT: {
      e.openElements.hasInSelectScope(m.SELECT) && (e.openElements.popUntilTagNamePopped(m.SELECT), e._resetInsertionMode(), t.tagID !== m.SELECT && e._processStartTag(t));
      break;
    }
    case m.SCRIPT:
    case m.TEMPLATE: {
      Ur(e, t);
      break;
    }
  }
}
function C2(e, t) {
  switch (t.tagID) {
    case m.OPTGROUP: {
      e.openElements.stackTop > 0 && e.openElements.currentTagId === m.OPTION && e.openElements.tagIDs[e.openElements.stackTop - 1] === m.OPTGROUP && e.openElements.pop(), e.openElements.currentTagId === m.OPTGROUP && e.openElements.pop();
      break;
    }
    case m.OPTION: {
      e.openElements.currentTagId === m.OPTION && e.openElements.pop();
      break;
    }
    case m.SELECT: {
      e.openElements.hasInSelectScope(m.SELECT) && (e.openElements.popUntilTagNamePopped(m.SELECT), e._resetInsertionMode());
      break;
    }
    case m.TEMPLATE: {
      Ca(e, t);
      break;
    }
  }
}
function b_(e, t) {
  const n = t.tagID;
  n === m.CAPTION || n === m.TABLE || n === m.TBODY || n === m.TFOOT || n === m.THEAD || n === m.TR || n === m.TD || n === m.TH ? (e.openElements.popUntilTagNamePopped(m.SELECT), e._resetInsertionMode(), e._processStartTag(t)) : k2(e, t);
}
function E_(e, t) {
  const n = t.tagID;
  n === m.CAPTION || n === m.TABLE || n === m.TBODY || n === m.TFOOT || n === m.THEAD || n === m.TR || n === m.TD || n === m.TH ? e.openElements.hasInTableScope(n) && (e.openElements.popUntilTagNamePopped(m.SELECT), e._resetInsertionMode(), e.onEndTag(t)) : C2(e, t);
}
function y_(e, t) {
  switch (t.tagID) {
    // First, handle tags that can start without a mode change
    case m.BASE:
    case m.BASEFONT:
    case m.BGSOUND:
    case m.LINK:
    case m.META:
    case m.NOFRAMES:
    case m.SCRIPT:
    case m.STYLE:
    case m.TEMPLATE:
    case m.TITLE: {
      Ur(e, t);
      break;
    }
    // Re-process the token in the appropriate mode
    case m.CAPTION:
    case m.COLGROUP:
    case m.TBODY:
    case m.TFOOT:
    case m.THEAD: {
      e.tmplInsertionModeStack[0] = X.IN_TABLE, e.insertionMode = X.IN_TABLE, fs(e, t);
      break;
    }
    case m.COL: {
      e.tmplInsertionModeStack[0] = X.IN_COLUMN_GROUP, e.insertionMode = X.IN_COLUMN_GROUP, Ef(e, t);
      break;
    }
    case m.TR: {
      e.tmplInsertionModeStack[0] = X.IN_TABLE_BODY, e.insertionMode = X.IN_TABLE_BODY, Ju(e, t);
      break;
    }
    case m.TD:
    case m.TH: {
      e.tmplInsertionModeStack[0] = X.IN_ROW, e.insertionMode = X.IN_ROW, Zu(e, t);
      break;
    }
    default:
      e.tmplInsertionModeStack[0] = X.IN_BODY, e.insertionMode = X.IN_BODY, Yn(e, t);
  }
}
function T_(e, t) {
  t.tagID === m.TEMPLATE && Ca(e, t);
}
function I2(e, t) {
  e.openElements.tmplCount > 0 ? (e.openElements.popUntilTagNamePopped(m.TEMPLATE), e.activeFormattingElements.clearToLastMarker(), e.tmplInsertionModeStack.shift(), e._resetInsertionMode(), e.onEof(t)) : bf(e, t);
}
function __(e, t) {
  t.tagID === m.HTML ? Yn(e, t) : Du(e, t);
}
function P2(e, t) {
  var n;
  if (t.tagID === m.HTML) {
    if (e.fragmentContext || (e.insertionMode = X.AFTER_AFTER_BODY), e.options.sourceCodeLocationInfo && e.openElements.tagIDs[0] === m.HTML) {
      e._setEndLocation(e.openElements.items[0], t);
      const r = e.openElements.items[1];
      r && !(!((n = e.treeAdapter.getNodeSourceCodeLocation(r)) === null || n === void 0) && n.endTag) && e._setEndLocation(r, t);
    }
  } else
    Du(e, t);
}
function Du(e, t) {
  e.insertionMode = X.IN_BODY, Ku(e, t);
}
function A_(e, t) {
  switch (t.tagID) {
    case m.HTML: {
      Yn(e, t);
      break;
    }
    case m.FRAMESET: {
      e._insertElement(t, Ce.HTML);
      break;
    }
    case m.FRAME: {
      e._appendElement(t, Ce.HTML), t.ackSelfClosing = !0;
      break;
    }
    case m.NOFRAMES: {
      Ur(e, t);
      break;
    }
  }
}
function w_(e, t) {
  t.tagID === m.FRAMESET && !e.openElements.isRootHtmlElementCurrent() && (e.openElements.pop(), !e.fragmentContext && e.openElements.currentTagId !== m.FRAMESET && (e.insertionMode = X.AFTER_FRAMESET));
}
function x_(e, t) {
  switch (t.tagID) {
    case m.HTML: {
      Yn(e, t);
      break;
    }
    case m.NOFRAMES: {
      Ur(e, t);
      break;
    }
  }
}
function N_(e, t) {
  t.tagID === m.HTML && (e.insertionMode = X.AFTER_AFTER_FRAMESET);
}
function v_(e, t) {
  t.tagID === m.HTML ? Yn(e, t) : wu(e, t);
}
function wu(e, t) {
  e.insertionMode = X.IN_BODY, Ku(e, t);
}
function S_(e, t) {
  switch (t.tagID) {
    case m.HTML: {
      Yn(e, t);
      break;
    }
    case m.NOFRAMES: {
      Ur(e, t);
      break;
    }
  }
}
function L_(e, t) {
  t.chars = en, e._insertCharacters(t);
}
function k_(e, t) {
  e._insertCharacters(t), e.framesetOk = !1;
}
function O2(e) {
  for (; e.treeAdapter.getNamespaceURI(e.openElements.current) !== Ce.HTML && e.openElements.currentTagId !== void 0 && !e._isIntegrationPoint(e.openElements.currentTagId, e.openElements.current); )
    e.openElements.pop();
}
function C_(e, t) {
  if (Wy(t))
    O2(e), e._startTagOutsideForeignContent(t);
  else {
    const n = e._getAdjustedCurrentElement(), r = e.treeAdapter.getNamespaceURI(n);
    r === Ce.MATHML ? g2(t) : r === Ce.SVG && (Vy(t), b2(t)), mf(t), t.selfClosing ? e._appendElement(t, r) : e._insertElement(t, r), t.ackSelfClosing = !0;
  }
}
function I_(e, t) {
  if (t.tagID === m.P || t.tagID === m.BR) {
    O2(e), e._endTagOutsideForeignContent(t);
    return;
  }
  for (let n = e.openElements.stackTop; n > 0; n--) {
    const r = e.openElements.items[n];
    if (e.treeAdapter.getNamespaceURI(r) === Ce.HTML) {
      e._endTagOutsideForeignContent(t);
      break;
    }
    const i = e.treeAdapter.getTagName(r);
    if (i.toLowerCase() === t.tagName) {
      t.tagName = i, e.openElements.shortenToLength(n);
      break;
    }
  }
}
ce.AREA, ce.BASE, ce.BASEFONT, ce.BGSOUND, ce.BR, ce.COL, ce.EMBED, ce.FRAME, ce.HR, ce.IMG, ce.INPUT, ce.KEYGEN, ce.LINK, ce.META, ce.PARAM, ce.SOURCE, ce.TRACK, ce.WBR;
const P_ = /<(\/?)(iframe|noembed|noframes|plaintext|script|style|textarea|title|xmp)(?=[\t\n\f\r />])/gi, O_ = /* @__PURE__ */ new Set([
  "mdxFlowExpression",
  "mdxJsxFlowElement",
  "mdxJsxTextElement",
  "mdxTextExpression",
  "mdxjsEsm"
]), _0 = { sourceCodeLocationInfo: !0, scriptingEnabled: !1 };
function R2(e, t) {
  const n = z_(e), r = F1("type", {
    handlers: { root: R_, element: D_, text: M_, comment: M2, doctype: F_, raw: U_ },
    unknown: H_
  }), i = {
    parser: n ? new E0(_0) : E0.getFragmentParser(void 0, _0),
    handle(o) {
      r(o, i);
    },
    stitches: !1,
    options: t || {}
  };
  r(e, i), gs(i, ni());
  const a = n ? i.parser.document : i.parser.getFragment(), s = Y6(a, {
    // To do: support `space`?
    file: i.options.file
  });
  return i.stitches && Xu(s, "comment", function(o, u, c) {
    const f = (
      /** @type {Stitch} */
      /** @type {unknown} */
      o
    );
    if (f.value.stitch && c && u !== void 0) {
      const p = c.children;
      return p[u] = f.value.stitch, u;
    }
  }), s.type === "root" && s.children.length === 1 && s.children[0].type === e.type ? s.children[0] : s;
}
function D2(e, t) {
  let n = -1;
  if (e)
    for (; ++n < e.length; )
      t.handle(e[n]);
}
function R_(e, t) {
  D2(e.children, t);
}
function D_(e, t) {
  j_(e, t), D2(e.children, t), q_(e, t);
}
function M_(e, t) {
  t.parser.tokenizer.state > 4 && (t.parser.tokenizer.state = 0);
  const n = {
    type: St.CHARACTER,
    chars: e.value,
    location: wo(e)
  };
  gs(t, ni(e)), t.parser.currentToken = n, t.parser._processToken(t.parser.currentToken);
}
function F_(e, t) {
  const n = {
    type: St.DOCTYPE,
    name: "html",
    forceQuirks: !1,
    publicId: "",
    systemId: "",
    location: wo(e)
  };
  gs(t, ni(e)), t.parser.currentToken = n, t.parser._processToken(t.parser.currentToken);
}
function B_(e, t) {
  t.stitches = !0;
  const n = Y_(e);
  if ("children" in e && "children" in n) {
    const r = (
      /** @type {Root} */
      R2({ type: "root", children: e.children }, t.options)
    );
    n.children = r.children;
  }
  M2({ type: "comment", value: { stitch: n } }, t);
}
function M2(e, t) {
  const n = e.value, r = {
    type: St.COMMENT,
    data: n,
    location: wo(e)
  };
  gs(t, ni(e)), t.parser.currentToken = r, t.parser._processToken(t.parser.currentToken);
}
function U_(e, t) {
  if (t.parser.tokenizer.preprocessor.html = "", t.parser.tokenizer.preprocessor.pos = -1, t.parser.tokenizer.preprocessor.lastGapPos = -2, t.parser.tokenizer.preprocessor.gapStack = [], t.parser.tokenizer.preprocessor.skipNextNewLine = !1, t.parser.tokenizer.preprocessor.lastChunkWritten = !1, t.parser.tokenizer.preprocessor.endOfChunkHit = !1, t.parser.tokenizer.preprocessor.isEol = !1, F2(t, ni(e)), t.parser.tokenizer.write(
    t.options.tagfilter ? e.value.replace(P_, "&lt;$1$2") : e.value,
    !1
  ), t.parser.tokenizer._runParsingLoop(), t.parser.tokenizer.state === 72 || // @ts-expect-error: removed.
  t.parser.tokenizer.state === 78) {
    t.parser.tokenizer.preprocessor.lastChunkWritten = !0;
    const n = t.parser.tokenizer._consume();
    t.parser.tokenizer._callState(n);
  }
}
function H_(e, t) {
  const n = (
    /** @type {Nodes} */
    e
  );
  if (t.options.passThrough && t.options.passThrough.includes(n.type))
    B_(n, t);
  else {
    let r = "";
    throw O_.has(n.type) && (r = ". It looks like you are using MDX nodes with `hast-util-raw` (or `rehype-raw`). If you use this because you are using remark or rehype plugins that inject `'html'` nodes, then please raise an issue with that plugin, as its a bad and slow idea. If you use this because you are using markdown syntax, then you have to configure this utility (or plugin) to pass through these nodes (see `passThrough` in docs), but you can also migrate to use the MDX syntax"), new Error("Cannot compile `" + n.type + "` node" + r);
  }
}
function gs(e, t) {
  F2(e, t);
  const n = e.parser.tokenizer.currentCharacterToken;
  n && n.location && (n.location.endLine = e.parser.tokenizer.preprocessor.line, n.location.endCol = e.parser.tokenizer.preprocessor.col + 1, n.location.endOffset = e.parser.tokenizer.preprocessor.offset + 1, e.parser.currentToken = n, e.parser._processToken(e.parser.currentToken)), e.parser.tokenizer.paused = !1, e.parser.tokenizer.inLoop = !1, e.parser.tokenizer.active = !1, e.parser.tokenizer.returnState = pn.DATA, e.parser.tokenizer.charRefCode = -1, e.parser.tokenizer.consumedAfterSnapshot = -1, e.parser.tokenizer.currentLocation = null, e.parser.tokenizer.currentCharacterToken = null, e.parser.tokenizer.currentToken = null, e.parser.tokenizer.currentAttr = { name: "", value: "" };
}
function F2(e, t) {
  if (t && t.offset !== void 0) {
    const n = {
      startLine: t.line,
      startCol: t.column,
      startOffset: t.offset,
      endLine: -1,
      endCol: -1,
      endOffset: -1
    };
    e.parser.tokenizer.preprocessor.lineStartPos = -t.column + 1, e.parser.tokenizer.preprocessor.droppedBufferSize = t.offset, e.parser.tokenizer.preprocessor.line = t.line, e.parser.tokenizer.currentLocation = n;
  }
}
function j_(e, t) {
  const n = e.tagName.toLowerCase();
  if (t.parser.tokenizer.state === pn.PLAINTEXT) return;
  gs(t, ni(e));
  const r = t.parser.openElements.current;
  let i = "namespaceURI" in r ? r.namespaceURI : wa.html;
  i === wa.html && n === "svg" && (i = wa.svg);
  const a = X6(
    // Shallow clone to not delve into `children`: we only need the attributes.
    { ...e, children: [] },
    { space: i === wa.svg ? "svg" : "html" }
  ), s = {
    type: St.START_TAG,
    tagName: n,
    tagID: ms(n),
    // We always send start and end tags.
    selfClosing: !1,
    ackSelfClosing: !1,
    // Always element.
    /* c8 ignore next */
    attrs: "attrs" in a ? a.attrs : [],
    location: wo(e)
  };
  t.parser.currentToken = s, t.parser._processToken(t.parser.currentToken), t.parser.tokenizer.lastStartTagName = n;
}
function q_(e, t) {
  const n = e.tagName.toLowerCase();
  if (!t.parser.tokenizer.inForeignNode && ry.includes(n) || t.parser.tokenizer.state === pn.PLAINTEXT) return;
  gs(t, zu(e));
  const r = {
    type: St.END_TAG,
    tagName: n,
    tagID: ms(n),
    selfClosing: !1,
    ackSelfClosing: !1,
    attrs: [],
    location: wo(e)
  };
  t.parser.currentToken = r, t.parser._processToken(t.parser.currentToken), // Current element is closed.
  n === t.parser.tokenizer.lastStartTagName && // `<textarea>` and `<title>`
  (t.parser.tokenizer.state === pn.RCDATA || // `<iframe>`, `<noembed>`, `<noframes>`, `<style>`, `<xmp>`
  t.parser.tokenizer.state === pn.RAWTEXT || // `<script>`
  t.parser.tokenizer.state === pn.SCRIPT_DATA) && (t.parser.tokenizer.state = pn.DATA);
}
function z_(e) {
  const t = e.type === "root" ? e.children[0] : e;
  return !!(t && (t.type === "doctype" || t.type === "element" && t.tagName.toLowerCase() === "html"));
}
function wo(e) {
  const t = ni(e) || {
    line: void 0,
    column: void 0,
    offset: void 0
  }, n = zu(e) || {
    line: void 0,
    column: void 0,
    offset: void 0
  };
  return {
    startLine: t.line,
    startCol: t.column,
    startOffset: t.offset,
    endLine: n.line,
    endCol: n.column,
    endOffset: n.offset
  };
}
function Y_(e) {
  return "children" in e ? cs({ ...e, children: [] }) : cs(e);
}
function W_(e) {
  return function(t, n) {
    return (
      /** @type {Root} */
      R2(t, { ...e, file: n })
    );
  };
}
const V_ = ({
  markdown: e,
  config: t,
  splitPages: n,
  pageRefs: r
}) => {
  const i = Vd[t.theme], a = xm(() => {
    if (!n) return [{ content: e, id: "main" }];
    let u;
    switch (t.splitMode) {
      case "hr":
        u = /\n---\n/;
        break;
      case "h1-h2":
        u = /\n(?=# )|\n(?=## )/;
        break;
      case "all-headers":
        u = /\n(?=#+ )/;
        break;
      case "auto":
      default:
        u = /\n---\n|\n(?=# )|\n(?=## )/;
        break;
    }
    return e.split(u).filter((f) => f.trim()).map((f, p) => ({
      content: f.trim(),
      id: `page-${p}`
    }));
  }, [e, n, t.splitMode]), s = t.fontFamily === "serif" ? "font-serif" : t.fontFamily === "mono" ? "mono" : "font-sans", o = () => {
    switch (t.imageAlignment) {
      case "left":
        return "justify-start";
      case "right":
        return "justify-end";
      default:
        return "justify-center";
    }
  };
  return /* @__PURE__ */ De("div", { className: "flex flex-col items-center gap-12 p-8 min-h-full", children: a.map((u, c) => /* @__PURE__ */ De(
    "div",
    {
      ref: (f) => {
        r.current[c] = f;
      },
      style: { width: `${t.width}px` },
      className: `${i.bg} transition-all duration-300`,
      children: /* @__PURE__ */ De(
        "div",
        {
          className: `${i.container} overflow-hidden`,
          style: { padding: `${t.padding}px` },
          children: /* @__PURE__ */ Ke(
            "article",
            {
              className: `prose prose-slate max-w-none ${s} ${i.text}`,
              style: {
                fontSize: `${t.fontSize}px`,
                lineHeight: t.lineHeight
              },
              children: [
                /* @__PURE__ */ De(
                  T4,
                  {
                    remarkPlugins: [O6],
                    rehypePlugins: [W_],
                    components: {
                      h1: ({ node: f, ...p }) => /* @__PURE__ */ De("h1", { className: `text-3xl font-bold mb-6 ${i.accent}`, ...p }),
                      h2: ({ node: f, ...p }) => /* @__PURE__ */ De("h2", { className: "text-2xl font-bold mb-4 mt-8 pb-2 border-b border-slate-200", ...p }),
                      h3: ({ node: f, ...p }) => /* @__PURE__ */ De("h3", { className: "text-xl font-bold mb-3 mt-6", ...p }),
                      p: ({ node: f, ...p }) => /* @__PURE__ */ De("p", { className: "mb-4 text-inherit opacity-95", ...p }),
                      ul: ({ node: f, ...p }) => /* @__PURE__ */ De("ul", { className: "list-disc pl-5 mb-4 space-y-2", ...p }),
                      li: ({ node: f, ...p }) => /* @__PURE__ */ De("li", { className: "text-inherit", ...p }),
                      blockquote: ({ node: f, ...p }) => /* @__PURE__ */ De("blockquote", { className: "border-l-4 border-blue-500 pl-4 italic my-6 text-slate-500", ...p }),
                      code: ({ node: f, ...p }) => /* @__PURE__ */ De("code", { className: `px-1.5 py-0.5 rounded text-[0.9em] font-bold mono ${i.code}`, ...p }),
                      pre: ({ node: f, ...p }) => /* @__PURE__ */ De("pre", { className: "bg-slate-900 text-slate-100 p-4 rounded-xl my-6 overflow-x-auto shadow-inner mono text-sm", ...p }),
                      img: ({ node: f, ...p }) => /* @__PURE__ */ De("div", { className: `flex w-full my-6 ${o()}`, children: /* @__PURE__ */ De(
                        "img",
                        {
                          className: "max-w-full h-auto block",
                          style: {
                            borderRadius: `${t.imageBorderRadius}px`,
                            boxShadow: t.imageShadow > 0 ? `0 ${t.imageShadow / 2}px ${t.imageShadow}px rgba(0,0,0,0.15)` : "none",
                            width: `${t.imageWidthPercent}%`
                          },
                          ...p
                        }
                      ) }),
                      hr: ({ node: f, ...p }) => /* @__PURE__ */ De("hr", { className: "my-8 border-slate-200", ...p }),
                      // Table rendering support
                      table: ({ node: f, ...p }) => /* @__PURE__ */ De("div", { className: "overflow-x-auto my-6", children: /* @__PURE__ */ De("table", { className: "min-w-full border-collapse border border-slate-300 text-sm", ...p }) }),
                      thead: ({ node: f, ...p }) => /* @__PURE__ */ De("thead", { className: "bg-slate-100/50", ...p }),
                      th: ({ node: f, ...p }) => /* @__PURE__ */ De("th", { className: "border border-slate-300 px-4 py-2 font-bold text-left", ...p }),
                      td: ({ node: f, ...p }) => /* @__PURE__ */ De("td", { className: "border border-slate-300 px-4 py-2", ...p })
                    },
                    children: u.content
                  }
                ),
                t.showWatermark && /* @__PURE__ */ Ke("div", { className: "mt-12 pt-6 border-t border-slate-100 flex justify-between items-center opacity-40 text-xs", children: [
                  /* @__PURE__ */ De("span", { children: t.watermarkText }),
                  /* @__PURE__ */ De("span", { className: "font-medium", children: "Vision Pro" })
                ] })
              ]
            }
          )
        }
      )
    },
    u.id
  )) });
};
function G_(e, t) {
  if (e.match(/^[a-z]+:\/\//i))
    return e;
  if (e.match(/^\/\//))
    return window.location.protocol + e;
  if (e.match(/^[a-z]+:/i))
    return e;
  const n = document.implementation.createHTMLDocument(), r = n.createElement("base"), i = n.createElement("a");
  return n.head.appendChild(r), n.body.appendChild(i), t && (r.href = t), i.href = e, i.href;
}
const $_ = /* @__PURE__ */ (() => {
  let e = 0;
  const t = () => (
    // eslint-disable-next-line no-bitwise
    `0000${(Math.random() * 36 ** 4 << 0).toString(36)}`.slice(-4)
  );
  return () => (e += 1, `u${t()}${e}`);
})();
function Ji(e) {
  const t = [];
  for (let n = 0, r = e.length; n < r; n++)
    t.push(e[n]);
  return t;
}
let $a = null;
function B2(e = {}) {
  return $a || (e.includeStyleProperties ? ($a = e.includeStyleProperties, $a) : ($a = Ji(window.getComputedStyle(document.documentElement)), $a));
}
function Mu(e, t) {
  const r = (e.ownerDocument.defaultView || window).getComputedStyle(e).getPropertyValue(t);
  return r ? parseFloat(r.replace("px", "")) : 0;
}
function X_(e) {
  const t = Mu(e, "border-left-width"), n = Mu(e, "border-right-width");
  return e.clientWidth + t + n;
}
function K_(e) {
  const t = Mu(e, "border-top-width"), n = Mu(e, "border-bottom-width");
  return e.clientHeight + t + n;
}
function U2(e, t = {}) {
  const n = t.width || X_(e), r = t.height || K_(e);
  return { width: n, height: r };
}
function Q_() {
  let e, t;
  try {
    t = process;
  } catch {
  }
  const n = t && t.env ? t.env.devicePixelRatio : null;
  return n && (e = parseInt(n, 10), Number.isNaN(e) && (e = 1)), e || window.devicePixelRatio || 1;
}
const fr = 16384;
function J_(e) {
  (e.width > fr || e.height > fr) && (e.width > fr && e.height > fr ? e.width > e.height ? (e.height *= fr / e.width, e.width = fr) : (e.width *= fr / e.height, e.height = fr) : e.width > fr ? (e.height *= fr / e.width, e.width = fr) : (e.width *= fr / e.height, e.height = fr));
}
function Fu(e) {
  return new Promise((t, n) => {
    const r = new Image();
    r.onload = () => {
      r.decode().then(() => {
        requestAnimationFrame(() => t(r));
      });
    }, r.onerror = n, r.crossOrigin = "anonymous", r.decoding = "async", r.src = e;
  });
}
async function Z_(e) {
  return Promise.resolve().then(() => new XMLSerializer().serializeToString(e)).then(encodeURIComponent).then((t) => `data:image/svg+xml;charset=utf-8,${t}`);
}
async function eA(e, t, n) {
  const r = "http://www.w3.org/2000/svg", i = document.createElementNS(r, "svg"), a = document.createElementNS(r, "foreignObject");
  return i.setAttribute("width", `${t}`), i.setAttribute("height", `${n}`), i.setAttribute("viewBox", `0 0 ${t} ${n}`), a.setAttribute("width", "100%"), a.setAttribute("height", "100%"), a.setAttribute("x", "0"), a.setAttribute("y", "0"), a.setAttribute("externalResourcesRequired", "true"), i.appendChild(a), a.appendChild(e), Z_(i);
}
const er = (e, t) => {
  if (e instanceof t)
    return !0;
  const n = Object.getPrototypeOf(e);
  return n === null ? !1 : n.constructor.name === t.name || er(n, t);
};
function tA(e) {
  const t = e.getPropertyValue("content");
  return `${e.cssText} content: '${t.replace(/'|"/g, "")}';`;
}
function nA(e, t) {
  return B2(t).map((n) => {
    const r = e.getPropertyValue(n), i = e.getPropertyPriority(n);
    return `${n}: ${r}${i ? " !important" : ""};`;
  }).join(" ");
}
function rA(e, t, n, r) {
  const i = `.${e}:${t}`, a = n.cssText ? tA(n) : nA(n, r);
  return document.createTextNode(`${i}{${a}}`);
}
function A0(e, t, n, r) {
  const i = window.getComputedStyle(e, n), a = i.getPropertyValue("content");
  if (a === "" || a === "none")
    return;
  const s = $_();
  try {
    t.className = `${t.className} ${s}`;
  } catch {
    return;
  }
  const o = document.createElement("style");
  o.appendChild(rA(s, n, i, r)), t.appendChild(o);
}
function iA(e, t, n) {
  A0(e, t, ":before", n), A0(e, t, ":after", n);
}
const w0 = "application/font-woff", x0 = "image/jpeg", aA = {
  woff: w0,
  woff2: w0,
  ttf: "application/font-truetype",
  eot: "application/vnd.ms-fontobject",
  png: "image/png",
  jpg: x0,
  jpeg: x0,
  gif: "image/gif",
  tiff: "image/tiff",
  svg: "image/svg+xml",
  webp: "image/webp"
};
function sA(e) {
  const t = /\.([^./]*?)$/g.exec(e);
  return t ? t[1] : "";
}
function yf(e) {
  const t = sA(e).toLowerCase();
  return aA[t] || "";
}
function oA(e) {
  return e.split(/,/)[1];
}
function Bc(e) {
  return e.search(/^(data:)/) !== -1;
}
function uA(e, t) {
  return `data:${t};base64,${e}`;
}
async function H2(e, t, n) {
  const r = await fetch(e, t);
  if (r.status === 404)
    throw new Error(`Resource "${r.url}" not found`);
  const i = await r.blob();
  return new Promise((a, s) => {
    const o = new FileReader();
    o.onerror = s, o.onloadend = () => {
      try {
        a(n({ res: r, result: o.result }));
      } catch (u) {
        s(u);
      }
    }, o.readAsDataURL(i);
  });
}
const ec = {};
function lA(e, t, n) {
  let r = e.replace(/\?.*/, "");
  return n && (r = e), /ttf|otf|eot|woff2?/i.test(r) && (r = r.replace(/.*\//, "")), t ? `[${t}]${r}` : r;
}
async function Tf(e, t, n) {
  const r = lA(e, t, n.includeQueryParams);
  if (ec[r] != null)
    return ec[r];
  n.cacheBust && (e += (/\?/.test(e) ? "&" : "?") + (/* @__PURE__ */ new Date()).getTime());
  let i;
  try {
    const a = await H2(e, n.fetchRequestInit, ({ res: s, result: o }) => (t || (t = s.headers.get("Content-Type") || ""), oA(o)));
    i = uA(a, t);
  } catch (a) {
    i = n.imagePlaceholder || "";
    let s = `Failed to fetch resource: ${e}`;
    a && (s = typeof a == "string" ? a : a.message), s && console.warn(s);
  }
  return ec[r] = i, i;
}
async function cA(e) {
  const t = e.toDataURL();
  return t === "data:," ? e.cloneNode(!1) : Fu(t);
}
async function fA(e, t) {
  if (e.currentSrc) {
    const a = document.createElement("canvas"), s = a.getContext("2d");
    a.width = e.clientWidth, a.height = e.clientHeight, s == null || s.drawImage(e, 0, 0, a.width, a.height);
    const o = a.toDataURL();
    return Fu(o);
  }
  const n = e.poster, r = yf(n), i = await Tf(n, r, t);
  return Fu(i);
}
async function hA(e, t) {
  var n;
  try {
    if (!((n = e == null ? void 0 : e.contentDocument) === null || n === void 0) && n.body)
      return await el(e.contentDocument.body, t, !0);
  } catch {
  }
  return e.cloneNode(!1);
}
async function dA(e, t) {
  return er(e, HTMLCanvasElement) ? cA(e) : er(e, HTMLVideoElement) ? fA(e, t) : er(e, HTMLIFrameElement) ? hA(e, t) : e.cloneNode(j2(e));
}
const pA = (e) => e.tagName != null && e.tagName.toUpperCase() === "SLOT", j2 = (e) => e.tagName != null && e.tagName.toUpperCase() === "SVG";
async function mA(e, t, n) {
  var r, i;
  if (j2(t))
    return t;
  let a = [];
  return pA(e) && e.assignedNodes ? a = Ji(e.assignedNodes()) : er(e, HTMLIFrameElement) && (!((r = e.contentDocument) === null || r === void 0) && r.body) ? a = Ji(e.contentDocument.body.childNodes) : a = Ji(((i = e.shadowRoot) !== null && i !== void 0 ? i : e).childNodes), a.length === 0 || er(e, HTMLVideoElement) || await a.reduce((s, o) => s.then(() => el(o, n)).then((u) => {
    u && t.appendChild(u);
  }), Promise.resolve()), t;
}
function gA(e, t, n) {
  const r = t.style;
  if (!r)
    return;
  const i = window.getComputedStyle(e);
  i.cssText ? (r.cssText = i.cssText, r.transformOrigin = i.transformOrigin) : B2(n).forEach((a) => {
    let s = i.getPropertyValue(a);
    a === "font-size" && s.endsWith("px") && (s = `${Math.floor(parseFloat(s.substring(0, s.length - 2))) - 0.1}px`), er(e, HTMLIFrameElement) && a === "display" && s === "inline" && (s = "block"), a === "d" && t.getAttribute("d") && (s = `path(${t.getAttribute("d")})`), r.setProperty(a, s, i.getPropertyPriority(a));
  });
}
function bA(e, t) {
  er(e, HTMLTextAreaElement) && (t.innerHTML = e.value), er(e, HTMLInputElement) && t.setAttribute("value", e.value);
}
function EA(e, t) {
  if (er(e, HTMLSelectElement)) {
    const r = Array.from(t.children).find((i) => e.value === i.getAttribute("value"));
    r && r.setAttribute("selected", "");
  }
}
function yA(e, t, n) {
  return er(t, Element) && (gA(e, t, n), iA(e, t, n), bA(e, t), EA(e, t)), t;
}
async function TA(e, t) {
  const n = e.querySelectorAll ? e.querySelectorAll("use") : [];
  if (n.length === 0)
    return e;
  const r = {};
  for (let a = 0; a < n.length; a++) {
    const o = n[a].getAttribute("xlink:href");
    if (o) {
      const u = e.querySelector(o), c = document.querySelector(o);
      !u && c && !r[o] && (r[o] = await el(c, t, !0));
    }
  }
  const i = Object.values(r);
  if (i.length) {
    const a = "http://www.w3.org/1999/xhtml", s = document.createElementNS(a, "svg");
    s.setAttribute("xmlns", a), s.style.position = "absolute", s.style.width = "0", s.style.height = "0", s.style.overflow = "hidden", s.style.display = "none";
    const o = document.createElementNS(a, "defs");
    s.appendChild(o);
    for (let u = 0; u < i.length; u++)
      o.appendChild(i[u]);
    e.appendChild(s);
  }
  return e;
}
async function el(e, t, n) {
  return !n && t.filter && !t.filter(e) ? null : Promise.resolve(e).then((r) => dA(r, t)).then((r) => mA(e, r, t)).then((r) => yA(e, r, t)).then((r) => TA(r, t));
}
const q2 = /url\((['"]?)([^'"]+?)\1\)/g, _A = /url\([^)]+\)\s*format\((["']?)([^"']+)\1\)/g, AA = /src:\s*(?:url\([^)]+\)\s*format\([^)]+\)[,;]\s*)+/g;
function wA(e) {
  const t = e.replace(/([.*+?^${}()|\[\]\/\\])/g, "\\$1");
  return new RegExp(`(url\\(['"]?)(${t})(['"]?\\))`, "g");
}
function xA(e) {
  const t = [];
  return e.replace(q2, (n, r, i) => (t.push(i), n)), t.filter((n) => !Bc(n));
}
async function NA(e, t, n, r, i) {
  try {
    const a = n ? G_(t, n) : t, s = yf(t);
    let o;
    return i || (o = await Tf(a, s, r)), e.replace(wA(t), `$1${o}$3`);
  } catch {
  }
  return e;
}
function vA(e, { preferredFontFormat: t }) {
  return t ? e.replace(AA, (n) => {
    for (; ; ) {
      const [r, , i] = _A.exec(n) || [];
      if (!i)
        return "";
      if (i === t)
        return `src: ${r};`;
    }
  }) : e;
}
function z2(e) {
  return e.search(q2) !== -1;
}
async function Y2(e, t, n) {
  if (!z2(e))
    return e;
  const r = vA(e, n);
  return xA(r).reduce((a, s) => a.then((o) => NA(o, s, t, n)), Promise.resolve(r));
}
async function Xa(e, t, n) {
  var r;
  const i = (r = t.style) === null || r === void 0 ? void 0 : r.getPropertyValue(e);
  if (i) {
    const a = await Y2(i, null, n);
    return t.style.setProperty(e, a, t.style.getPropertyPriority(e)), !0;
  }
  return !1;
}
async function SA(e, t) {
  await Xa("background", e, t) || await Xa("background-image", e, t), await Xa("mask", e, t) || await Xa("-webkit-mask", e, t) || await Xa("mask-image", e, t) || await Xa("-webkit-mask-image", e, t);
}
async function LA(e, t) {
  const n = er(e, HTMLImageElement);
  if (!(n && !Bc(e.src)) && !(er(e, SVGImageElement) && !Bc(e.href.baseVal)))
    return;
  const r = n ? e.src : e.href.baseVal, i = await Tf(r, yf(r), t);
  await new Promise((a, s) => {
    e.onload = a, e.onerror = t.onImageErrorHandler ? (...u) => {
      try {
        a(t.onImageErrorHandler(...u));
      } catch (c) {
        s(c);
      }
    } : s;
    const o = e;
    o.decode && (o.decode = a), o.loading === "lazy" && (o.loading = "eager"), n ? (e.srcset = "", e.src = i) : e.href.baseVal = i;
  });
}
async function kA(e, t) {
  const r = Ji(e.childNodes).map((i) => W2(i, t));
  await Promise.all(r).then(() => e);
}
async function W2(e, t) {
  er(e, Element) && (await SA(e, t), await LA(e, t), await kA(e, t));
}
function CA(e, t) {
  const { style: n } = e;
  t.backgroundColor && (n.backgroundColor = t.backgroundColor), t.width && (n.width = `${t.width}px`), t.height && (n.height = `${t.height}px`);
  const r = t.style;
  return r != null && Object.keys(r).forEach((i) => {
    n[i] = r[i];
  }), e;
}
const N0 = {};
async function v0(e) {
  let t = N0[e];
  if (t != null)
    return t;
  const r = await (await fetch(e)).text();
  return t = { url: e, cssText: r }, N0[e] = t, t;
}
async function S0(e, t) {
  let n = e.cssText;
  const r = /url\(["']?([^"')]+)["']?\)/g, a = (n.match(/url\([^)]+\)/g) || []).map(async (s) => {
    let o = s.replace(r, "$1");
    return o.startsWith("https://") || (o = new URL(o, e.url).href), H2(o, t.fetchRequestInit, ({ result: u }) => (n = n.replace(s, `url(${u})`), [s, u]));
  });
  return Promise.all(a).then(() => n);
}
function L0(e) {
  if (e == null)
    return [];
  const t = [], n = /(\/\*[\s\S]*?\*\/)/gi;
  let r = e.replace(n, "");
  const i = new RegExp("((@.*?keyframes [\\s\\S]*?){([\\s\\S]*?}\\s*?)})", "gi");
  for (; ; ) {
    const u = i.exec(r);
    if (u === null)
      break;
    t.push(u[0]);
  }
  r = r.replace(i, "");
  const a = /@import[\s\S]*?url\([^)]*\)[\s\S]*?;/gi, s = "((\\s*?(?:\\/\\*[\\s\\S]*?\\*\\/)?\\s*?@media[\\s\\S]*?){([\\s\\S]*?)}\\s*?})|(([\\s\\S]*?){([\\s\\S]*?)})", o = new RegExp(s, "gi");
  for (; ; ) {
    let u = a.exec(r);
    if (u === null) {
      if (u = o.exec(r), u === null)
        break;
      a.lastIndex = o.lastIndex;
    } else
      o.lastIndex = a.lastIndex;
    t.push(u[0]);
  }
  return t;
}
async function IA(e, t) {
  const n = [], r = [];
  return e.forEach((i) => {
    if ("cssRules" in i)
      try {
        Ji(i.cssRules || []).forEach((a, s) => {
          if (a.type === CSSRule.IMPORT_RULE) {
            let o = s + 1;
            const u = a.href, c = v0(u).then((f) => S0(f, t)).then((f) => L0(f).forEach((p) => {
              try {
                i.insertRule(p, p.startsWith("@import") ? o += 1 : i.cssRules.length);
              } catch (E) {
                console.error("Error inserting rule from remote css", {
                  rule: p,
                  error: E
                });
              }
            })).catch((f) => {
              console.error("Error loading remote css", f.toString());
            });
            r.push(c);
          }
        });
      } catch (a) {
        const s = e.find((o) => o.href == null) || document.styleSheets[0];
        i.href != null && r.push(v0(i.href).then((o) => S0(o, t)).then((o) => L0(o).forEach((u) => {
          s.insertRule(u, s.cssRules.length);
        })).catch((o) => {
          console.error("Error loading remote stylesheet", o);
        })), console.error("Error inlining remote css file", a);
      }
  }), Promise.all(r).then(() => (e.forEach((i) => {
    if ("cssRules" in i)
      try {
        Ji(i.cssRules || []).forEach((a) => {
          n.push(a);
        });
      } catch (a) {
        console.error(`Error while reading CSS rules from ${i.href}`, a);
      }
  }), n));
}
function PA(e) {
  return e.filter((t) => t.type === CSSRule.FONT_FACE_RULE).filter((t) => z2(t.style.getPropertyValue("src")));
}
async function OA(e, t) {
  if (e.ownerDocument == null)
    throw new Error("Provided element is not within a Document");
  const n = Ji(e.ownerDocument.styleSheets), r = await IA(n, t);
  return PA(r);
}
function V2(e) {
  return e.trim().replace(/["']/g, "");
}
function RA(e) {
  const t = /* @__PURE__ */ new Set();
  function n(r) {
    (r.style.fontFamily || getComputedStyle(r).fontFamily).split(",").forEach((a) => {
      t.add(V2(a));
    }), Array.from(r.children).forEach((a) => {
      a instanceof HTMLElement && n(a);
    });
  }
  return n(e), t;
}
async function DA(e, t) {
  const n = await OA(e, t), r = RA(e);
  return (await Promise.all(n.filter((a) => r.has(V2(a.style.fontFamily))).map((a) => {
    const s = a.parentStyleSheet ? a.parentStyleSheet.href : null;
    return Y2(a.cssText, s, t);
  }))).join(`
`);
}
async function MA(e, t) {
  const n = t.fontEmbedCSS != null ? t.fontEmbedCSS : t.skipFonts ? null : await DA(e, t);
  if (n) {
    const r = document.createElement("style"), i = document.createTextNode(n);
    r.appendChild(i), e.firstChild ? e.insertBefore(r, e.firstChild) : e.appendChild(r);
  }
}
async function FA(e, t = {}) {
  const { width: n, height: r } = U2(e, t), i = await el(e, t, !0);
  return await MA(i, t), await W2(i, t), CA(i, t), await eA(i, n, r);
}
async function _f(e, t = {}) {
  const { width: n, height: r } = U2(e, t), i = await FA(e, t), a = await Fu(i), s = document.createElement("canvas"), o = s.getContext("2d"), u = t.pixelRatio || Q_(), c = t.canvasWidth || n, f = t.canvasHeight || r;
  return s.width = c * u, s.height = f * u, t.skipAutoScale || J_(s), s.style.width = `${c}`, s.style.height = `${f}`, t.backgroundColor && (o.fillStyle = t.backgroundColor, o.fillRect(0, 0, s.width, s.height)), o.drawImage(a, 0, 0, s.width, s.height), s;
}
async function k0(e, t = {}) {
  return (await _f(e, t)).toDataURL();
}
async function C0(e, t = {}) {
  return (await _f(e, t)).toDataURL("image/jpeg", t.quality || 1);
}
function qt(e) {
  "@babel/helpers - typeof";
  return qt = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, qt(e);
}
var Br = Uint8Array, pr = Uint16Array, Af = Int32Array, wf = new Br([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), xf = new Br([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), I0 = new Br([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), G2 = function(e, t) {
  for (var n = new pr(31), r = 0; r < 31; ++r)
    n[r] = t += 1 << e[r - 1];
  for (var i = new Af(n[30]), r = 1; r < 30; ++r)
    for (var a = n[r]; a < n[r + 1]; ++a)
      i[a] = a - n[r] << 5 | r;
  return { b: n, r: i };
}, $2 = G2(wf, 2), BA = $2.b, Uc = $2.r;
BA[28] = 258, Uc[258] = 28;
var UA = G2(xf, 0), P0 = UA.r, Hc = new pr(32768);
for (var Qt = 0; Qt < 32768; ++Qt) {
  var Vi = (Qt & 43690) >> 1 | (Qt & 21845) << 1;
  Vi = (Vi & 52428) >> 2 | (Vi & 13107) << 2, Vi = (Vi & 61680) >> 4 | (Vi & 3855) << 4, Hc[Qt] = ((Vi & 65280) >> 8 | (Vi & 255) << 8) >> 1;
}
var lo = (function(e, t, n) {
  for (var r = e.length, i = 0, a = new pr(t); i < r; ++i)
    e[i] && ++a[e[i] - 1];
  var s = new pr(t);
  for (i = 1; i < t; ++i)
    s[i] = s[i - 1] + a[i - 1] << 1;
  var o;
  if (n) {
    o = new pr(1 << t);
    var u = 15 - t;
    for (i = 0; i < r; ++i)
      if (e[i])
        for (var c = i << 4 | e[i], f = t - e[i], p = s[e[i] - 1]++ << f, E = p | (1 << f) - 1; p <= E; ++p)
          o[Hc[p] >> u] = c;
  } else
    for (o = new pr(r), i = 0; i < r; ++i)
      e[i] && (o[i] = Hc[s[e[i] - 1]++] >> 15 - e[i]);
  return o;
}), Sa = new Br(288);
for (var Qt = 0; Qt < 144; ++Qt)
  Sa[Qt] = 8;
for (var Qt = 144; Qt < 256; ++Qt)
  Sa[Qt] = 9;
for (var Qt = 256; Qt < 280; ++Qt)
  Sa[Qt] = 7;
for (var Qt = 280; Qt < 288; ++Qt)
  Sa[Qt] = 8;
var Bu = new Br(32);
for (var Qt = 0; Qt < 32; ++Qt)
  Bu[Qt] = 5;
var HA = /* @__PURE__ */ lo(Sa, 9, 0), jA = /* @__PURE__ */ lo(Bu, 5, 0), X2 = function(e) {
  return (e + 7) / 8 | 0;
}, qA = function(e, t, n) {
  return (n == null || n > e.length) && (n = e.length), new Br(e.subarray(t, n));
}, wi = function(e, t, n) {
  n <<= t & 7;
  var r = t / 8 | 0;
  e[r] |= n, e[r + 1] |= n >> 8;
}, Js = function(e, t, n) {
  n <<= t & 7;
  var r = t / 8 | 0;
  e[r] |= n, e[r + 1] |= n >> 8, e[r + 2] |= n >> 16;
}, tc = function(e, t) {
  for (var n = [], r = 0; r < e.length; ++r)
    e[r] && n.push({ s: r, f: e[r] });
  var i = n.length, a = n.slice();
  if (!i)
    return { t: Q2, l: 0 };
  if (i == 1) {
    var s = new Br(n[0].s + 1);
    return s[n[0].s] = 1, { t: s, l: 1 };
  }
  n.sort(function(ie, K) {
    return ie.f - K.f;
  }), n.push({ s: -1, f: 25001 });
  var o = n[0], u = n[1], c = 0, f = 1, p = 2;
  for (n[0] = { s: -1, f: o.f + u.f, l: o, r: u }; f != i - 1; )
    o = n[n[c].f < n[p].f ? c++ : p++], u = n[c != f && n[c].f < n[p].f ? c++ : p++], n[f++] = { s: -1, f: o.f + u.f, l: o, r: u };
  for (var E = a[0].s, r = 1; r < i; ++r)
    a[r].s > E && (E = a[r].s);
  var d = new pr(E + 1), A = jc(n[f - 1], d, 0);
  if (A > t) {
    var r = 0, v = 0, C = A - t, _ = 1 << C;
    for (a.sort(function(K, fe) {
      return d[fe.s] - d[K.s] || K.f - fe.f;
    }); r < i; ++r) {
      var U = a[r].s;
      if (d[U] > t)
        v += _ - (1 << A - d[U]), d[U] = t;
      else
        break;
    }
    for (v >>= C; v > 0; ) {
      var B = a[r].s;
      d[B] < t ? v -= 1 << t - d[B]++ - 1 : ++r;
    }
    for (; r >= 0 && v; --r) {
      var V = a[r].s;
      d[V] == t && (--d[V], ++v);
    }
    A = t;
  }
  return { t: new Br(d), l: A };
}, jc = function(e, t, n) {
  return e.s == -1 ? Math.max(jc(e.l, t, n + 1), jc(e.r, t, n + 1)) : t[e.s] = n;
}, O0 = function(e) {
  for (var t = e.length; t && !e[--t]; )
    ;
  for (var n = new pr(++t), r = 0, i = e[0], a = 1, s = function(u) {
    n[r++] = u;
  }, o = 1; o <= t; ++o)
    if (e[o] == i && o != t)
      ++a;
    else {
      if (!i && a > 2) {
        for (; a > 138; a -= 138)
          s(32754);
        a > 2 && (s(a > 10 ? a - 11 << 5 | 28690 : a - 3 << 5 | 12305), a = 0);
      } else if (a > 3) {
        for (s(i), --a; a > 6; a -= 6)
          s(8304);
        a > 2 && (s(a - 3 << 5 | 8208), a = 0);
      }
      for (; a--; )
        s(i);
      a = 1, i = e[o];
    }
  return { c: n.subarray(0, r), n: t };
}, Zs = function(e, t) {
  for (var n = 0, r = 0; r < t.length; ++r)
    n += e[r] * t[r];
  return n;
}, K2 = function(e, t, n) {
  var r = n.length, i = X2(t + 2);
  e[i] = r & 255, e[i + 1] = r >> 8, e[i + 2] = e[i] ^ 255, e[i + 3] = e[i + 1] ^ 255;
  for (var a = 0; a < r; ++a)
    e[i + a + 4] = n[a];
  return (i + 4 + r) * 8;
}, R0 = function(e, t, n, r, i, a, s, o, u, c, f) {
  wi(t, f++, n), ++i[256];
  for (var p = tc(i, 15), E = p.t, d = p.l, A = tc(a, 15), v = A.t, C = A.l, _ = O0(E), U = _.c, B = _.n, V = O0(v), ie = V.c, K = V.n, fe = new pr(19), Z = 0; Z < U.length; ++Z)
    ++fe[U[Z] & 31];
  for (var Z = 0; Z < ie.length; ++Z)
    ++fe[ie[Z] & 31];
  for (var z = tc(fe, 7), D = z.t, N = z.l, I = 19; I > 4 && !D[I0[I - 1]]; --I)
    ;
  var $ = c + 5 << 3, Y = Zs(i, Sa) + Zs(a, Bu) + s, J = Zs(i, E) + Zs(a, v) + s + 14 + 3 * I + Zs(fe, D) + 2 * fe[16] + 3 * fe[17] + 7 * fe[18];
  if (u >= 0 && $ <= Y && $ <= J)
    return K2(t, f, e.subarray(u, u + c));
  var ue, me, se, Ee;
  if (wi(t, f, 1 + (J < Y)), f += 2, J < Y) {
    ue = lo(E, d, 0), me = E, se = lo(v, C, 0), Ee = v;
    var M = lo(D, N, 0);
    wi(t, f, B - 257), wi(t, f + 5, K - 1), wi(t, f + 10, I - 4), f += 14;
    for (var Z = 0; Z < I; ++Z)
      wi(t, f + 3 * Z, D[I0[Z]]);
    f += 3 * I;
    for (var xe = [U, ie], L = 0; L < 2; ++L)
      for (var T = xe[L], Z = 0; Z < T.length; ++Z) {
        var G = T[Z] & 31;
        wi(t, f, M[G]), f += D[G], G > 15 && (wi(t, f, T[Z] >> 5 & 127), f += T[Z] >> 12);
      }
  } else
    ue = HA, me = Sa, se = jA, Ee = Bu;
  for (var Z = 0; Z < o; ++Z) {
    var ee = r[Z];
    if (ee > 255) {
      var G = ee >> 18 & 31;
      Js(t, f, ue[G + 257]), f += me[G + 257], G > 7 && (wi(t, f, ee >> 23 & 31), f += wf[G]);
      var te = ee & 31;
      Js(t, f, se[te]), f += Ee[te], te > 3 && (Js(t, f, ee >> 5 & 8191), f += xf[te]);
    } else
      Js(t, f, ue[ee]), f += me[ee];
  }
  return Js(t, f, ue[256]), f + me[256];
}, zA = /* @__PURE__ */ new Af([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]), Q2 = /* @__PURE__ */ new Br(0), YA = function(e, t, n, r, i, a) {
  var s = a.z || e.length, o = new Br(r + s + 5 * (1 + Math.ceil(s / 7e3)) + i), u = o.subarray(r, o.length - i), c = a.l, f = (a.r || 0) & 7;
  if (t) {
    f && (u[0] = a.r >> 3);
    for (var p = zA[t - 1], E = p >> 13, d = p & 8191, A = (1 << n) - 1, v = a.p || new pr(32768), C = a.h || new pr(A + 1), _ = Math.ceil(n / 3), U = 2 * _, B = function(tt) {
      return (e[tt] ^ e[tt + 1] << _ ^ e[tt + 2] << U) & A;
    }, V = new Af(25e3), ie = new pr(288), K = new pr(32), fe = 0, Z = 0, z = a.i || 0, D = 0, N = a.w || 0, I = 0; z + 2 < s; ++z) {
      var $ = B(z), Y = z & 32767, J = C[$];
      if (v[Y] = J, C[$] = Y, N <= z) {
        var ue = s - z;
        if ((fe > 7e3 || D > 24576) && (ue > 423 || !c)) {
          f = R0(e, u, 0, V, ie, K, Z, D, I, z - I, f), D = fe = Z = 0, I = z;
          for (var me = 0; me < 286; ++me)
            ie[me] = 0;
          for (var me = 0; me < 30; ++me)
            K[me] = 0;
        }
        var se = 2, Ee = 0, M = d, xe = Y - J & 32767;
        if (ue > 2 && $ == B(z - xe))
          for (var L = Math.min(E, ue) - 1, T = Math.min(32767, z), G = Math.min(258, ue); xe <= T && --M && Y != J; ) {
            if (e[z + se] == e[z + se - xe]) {
              for (var ee = 0; ee < G && e[z + ee] == e[z + ee - xe]; ++ee)
                ;
              if (ee > se) {
                if (se = ee, Ee = xe, ee > L)
                  break;
                for (var te = Math.min(xe, ee - 2), le = 0, me = 0; me < te; ++me) {
                  var ge = z - xe + me & 32767, be = v[ge], Ae = ge - be & 32767;
                  Ae > le && (le = Ae, J = ge);
                }
              }
            }
            Y = J, J = v[Y], xe += Y - J & 32767;
          }
        if (Ee) {
          V[D++] = 268435456 | Uc[se] << 18 | P0[Ee];
          var Ie = Uc[se] & 31, je = P0[Ee] & 31;
          Z += wf[Ie] + xf[je], ++ie[257 + Ie], ++K[je], N = z + se, ++fe;
        } else
          V[D++] = e[z], ++ie[e[z]];
      }
    }
    for (z = Math.max(z, N); z < s; ++z)
      V[D++] = e[z], ++ie[e[z]];
    f = R0(e, u, c, V, ie, K, Z, D, I, z - I, f), c || (a.r = f & 7 | u[f / 8 | 0] << 3, f -= 7, a.h = C, a.p = v, a.i = z, a.w = N);
  } else {
    for (var z = a.w || 0; z < s + c; z += 65535) {
      var He = z + 65535;
      He >= s && (u[f / 8 | 0] = c, He = s), f = K2(u, f + 1, e.subarray(z, He));
    }
    a.i = s;
  }
  return qA(o, 0, r + X2(f) + i);
}, J2 = function() {
  var e = 1, t = 0;
  return {
    p: function(n) {
      for (var r = e, i = t, a = n.length | 0, s = 0; s != a; ) {
        for (var o = Math.min(s + 2655, a); s < o; ++s)
          i += r += n[s];
        r = (r & 65535) + 15 * (r >> 16), i = (i & 65535) + 15 * (i >> 16);
      }
      e = r, t = i;
    },
    d: function() {
      return e %= 65521, t %= 65521, (e & 255) << 24 | (e & 65280) << 8 | (t & 255) << 8 | t >> 8;
    }
  };
}, WA = function(e, t, n, r, i) {
  if (!i && (i = { l: 1 }, t.dictionary)) {
    var a = t.dictionary.subarray(-32768), s = new Br(a.length + e.length);
    s.set(a), s.set(e, a.length), e = s, i.w = a.length;
  }
  return YA(e, t.level == null ? 6 : t.level, t.mem == null ? i.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(e.length))) * 1.5) : 20 : 12 + t.mem, n, r, i);
}, Z2 = function(e, t, n) {
  for (; n; ++t)
    e[t] = n, n >>>= 8;
}, VA = function(e, t) {
  var n = t.level, r = n == 0 ? 0 : n < 6 ? 1 : n == 9 ? 3 : 2;
  if (e[0] = 120, e[1] = r << 6 | (t.dictionary && 32), e[1] |= 31 - (e[0] << 8 | e[1]) % 31, t.dictionary) {
    var i = J2();
    i.p(t.dictionary), Z2(e, 2, i.d());
  }
};
function qc(e, t) {
  t || (t = {});
  var n = J2();
  n.p(e);
  var r = WA(e, t, t.dictionary ? 6 : 2, 4);
  return VA(r, t), Z2(r, r.length - 4, n.d()), r;
}
var GA = typeof TextDecoder < "u" && /* @__PURE__ */ new TextDecoder(), $A = 0;
try {
  GA.decode(Q2, { stream: !0 }), $A = 1;
} catch {
}
function XA(e) {
  if (Array.isArray(e)) return e;
}
function KA(e, t) {
  var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (n != null) {
    var r, i, a, s, o = [], u = !0, c = !1;
    try {
      if (a = (n = n.call(e)).next, t !== 0) for (; !(u = (r = a.call(n)).done) && (o.push(r.value), o.length !== t); u = !0) ;
    } catch (f) {
      c = !0, i = f;
    } finally {
      try {
        if (!u && n.return != null && (s = n.return(), Object(s) !== s)) return;
      } finally {
        if (c) throw i;
      }
    }
    return o;
  }
}
function D0(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, r = Array(t); n < t; n++) r[n] = e[n];
  return r;
}
function QA(e, t) {
  if (e) {
    if (typeof e == "string") return D0(e, t);
    var n = {}.toString.call(e).slice(8, -1);
    return n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set" ? Array.from(e) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? D0(e, t) : void 0;
  }
}
function JA() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function M0(e, t) {
  return XA(e) || KA(e, t) || QA(e, t) || JA();
}
function F0(e, t = "utf8") {
  return new TextDecoder(t).decode(e);
}
const ZA = new TextEncoder();
function ew(e) {
  return ZA.encode(e);
}
const tw = 1024 * 8, nw = (() => {
  const e = new Uint8Array(4), t = new Uint32Array(e.buffer);
  return !((t[0] = 1) & e[0]);
})(), nc = {
  int8: globalThis.Int8Array,
  uint8: globalThis.Uint8Array,
  int16: globalThis.Int16Array,
  uint16: globalThis.Uint16Array,
  int32: globalThis.Int32Array,
  uint32: globalThis.Uint32Array,
  uint64: globalThis.BigUint64Array,
  int64: globalThis.BigInt64Array,
  float32: globalThis.Float32Array,
  float64: globalThis.Float64Array
};
class Nf {
  /**
   * Create a new IOBuffer.
   * @param data - The data to construct the IOBuffer with.
   * If data is a number, it will be the new buffer's length<br>
   * If data is `undefined`, the buffer will be initialized with a default length of 8Kb<br>
   * If data is an ArrayBuffer, SharedArrayBuffer, an ArrayBufferView (Typed Array), an IOBuffer instance,
   * or a Node.js Buffer, a view will be created over the underlying ArrayBuffer.
   * @param options - An object for the options.
   * @returns A new IOBuffer instance.
   */
  constructor(t = tw, n = {}) {
    /**
     * Reference to the internal ArrayBuffer object.
     */
    jt(this, "buffer");
    /**
     * Byte length of the internal ArrayBuffer.
     */
    jt(this, "byteLength");
    /**
     * Byte offset of the internal ArrayBuffer.
     */
    jt(this, "byteOffset");
    /**
     * Byte length of the internal ArrayBuffer.
     */
    jt(this, "length");
    /**
     * The current offset of the buffer's pointer.
     */
    jt(this, "offset");
    jt(this, "lastWrittenByte");
    jt(this, "littleEndian");
    jt(this, "_data");
    jt(this, "_mark");
    jt(this, "_marks");
    let r = !1;
    typeof t == "number" ? t = new ArrayBuffer(t) : (r = !0, this.lastWrittenByte = t.byteLength);
    const i = n.offset ? n.offset >>> 0 : 0, a = t.byteLength - i;
    let s = i;
    (ArrayBuffer.isView(t) || t instanceof Nf) && (t.byteLength !== t.buffer.byteLength && (s = t.byteOffset + i), t = t.buffer), r ? this.lastWrittenByte = a : this.lastWrittenByte = 0, this.buffer = t, this.length = a, this.byteLength = a, this.byteOffset = s, this.offset = 0, this.littleEndian = !0, this._data = new DataView(this.buffer, s, a), this._mark = 0, this._marks = [];
  }
  /**
   * Checks if the memory allocated to the buffer is sufficient to store more
   * bytes after the offset.
   * @param byteLength - The needed memory in bytes.
   * @returns `true` if there is sufficient space and `false` otherwise.
   */
  available(t = 1) {
    return this.offset + t <= this.length;
  }
  /**
   * Check if little-endian mode is used for reading and writing multi-byte
   * values.
   * @returns `true` if little-endian mode is used, `false` otherwise.
   */
  isLittleEndian() {
    return this.littleEndian;
  }
  /**
   * Set little-endian mode for reading and writing multi-byte values.
   * @returns This.
   */
  setLittleEndian() {
    return this.littleEndian = !0, this;
  }
  /**
   * Check if big-endian mode is used for reading and writing multi-byte values.
   * @returns `true` if big-endian mode is used, `false` otherwise.
   */
  isBigEndian() {
    return !this.littleEndian;
  }
  /**
   * Switches to big-endian mode for reading and writing multi-byte values.
   * @returns This.
   */
  setBigEndian() {
    return this.littleEndian = !1, this;
  }
  /**
   * Move the pointer n bytes forward.
   * @param n - Number of bytes to skip.
   * @returns This.
   */
  skip(t = 1) {
    return this.offset += t, this;
  }
  /**
   * Move the pointer n bytes backward.
   * @param n - Number of bytes to move back.
   * @returns This.
   */
  back(t = 1) {
    return this.offset -= t, this;
  }
  /**
   * Move the pointer to the given offset.
   * @param offset - The offset to move to.
   * @returns This.
   */
  seek(t) {
    return this.offset = t, this;
  }
  /**
   * Store the current pointer offset.
   * @see {@link IOBuffer#reset}
   * @returns This.
   */
  mark() {
    return this._mark = this.offset, this;
  }
  /**
   * Move the pointer back to the last pointer offset set by mark.
   * @see {@link IOBuffer#mark}
   * @returns This.
   */
  reset() {
    return this.offset = this._mark, this;
  }
  /**
   * Push the current pointer offset to the mark stack.
   * @see {@link IOBuffer#popMark}
   * @returns This.
   */
  pushMark() {
    return this._marks.push(this.offset), this;
  }
  /**
   * Pop the last pointer offset from the mark stack, and set the current
   * pointer offset to the popped value.
   * @see {@link IOBuffer#pushMark}
   * @returns This.
   */
  popMark() {
    const t = this._marks.pop();
    if (t === void 0)
      throw new Error("Mark stack empty");
    return this.seek(t), this;
  }
  /**
   * Move the pointer offset back to 0.
   * @returns This.
   */
  rewind() {
    return this.offset = 0, this;
  }
  /**
   * Make sure the buffer has sufficient memory to write a given byteLength at
   * the current pointer offset.
   * If the buffer's memory is insufficient, this method will create a new
   * buffer (a copy) with a length that is twice (byteLength + current offset).
   * @param byteLength - The needed memory in bytes.
   * @returns This.
   */
  ensureAvailable(t = 1) {
    if (!this.available(t)) {
      const r = (this.offset + t) * 2, i = new Uint8Array(r);
      i.set(new Uint8Array(this.buffer)), this.buffer = i.buffer, this.length = r, this.byteLength = r, this._data = new DataView(this.buffer);
    }
    return this;
  }
  /**
   * Read a byte and return false if the byte's value is 0, or true otherwise.
   * Moves pointer forward by one byte.
   * @returns The read boolean.
   */
  readBoolean() {
    return this.readUint8() !== 0;
  }
  /**
   * Read a signed 8-bit integer and move pointer forward by 1 byte.
   * @returns The read byte.
   */
  readInt8() {
    return this._data.getInt8(this.offset++);
  }
  /**
   * Read an unsigned 8-bit integer and move pointer forward by 1 byte.
   * @returns The read byte.
   */
  readUint8() {
    return this._data.getUint8(this.offset++);
  }
  /**
   * Alias for {@link IOBuffer#readUint8}.
   * @returns The read byte.
   */
  readByte() {
    return this.readUint8();
  }
  /**
   * Read `n` bytes and move pointer forward by `n` bytes.
   * @param n - Number of bytes to read.
   * @returns The read bytes.
   */
  readBytes(t = 1) {
    return this.readArray(t, "uint8");
  }
  /**
   * Creates an array of corresponding to the type `type` and size `size`.
   * For example type `uint8` will create a `Uint8Array`.
   * @param size - size of the resulting array
   * @param type - number type of elements to read
   * @returns The read array.
   */
  readArray(t, n) {
    const r = nc[n].BYTES_PER_ELEMENT * t, i = this.byteOffset + this.offset, a = this.buffer.slice(i, i + r);
    if (this.littleEndian === nw && n !== "uint8" && n !== "int8") {
      const o = new Uint8Array(this.buffer.slice(i, i + r));
      o.reverse();
      const u = new nc[n](o.buffer);
      return this.offset += r, u.reverse(), u;
    }
    const s = new nc[n](a);
    return this.offset += r, s;
  }
  /**
   * Read a 16-bit signed integer and move pointer forward by 2 bytes.
   * @returns The read value.
   */
  readInt16() {
    const t = this._data.getInt16(this.offset, this.littleEndian);
    return this.offset += 2, t;
  }
  /**
   * Read a 16-bit unsigned integer and move pointer forward by 2 bytes.
   * @returns The read value.
   */
  readUint16() {
    const t = this._data.getUint16(this.offset, this.littleEndian);
    return this.offset += 2, t;
  }
  /**
   * Read a 32-bit signed integer and move pointer forward by 4 bytes.
   * @returns The read value.
   */
  readInt32() {
    const t = this._data.getInt32(this.offset, this.littleEndian);
    return this.offset += 4, t;
  }
  /**
   * Read a 32-bit unsigned integer and move pointer forward by 4 bytes.
   * @returns The read value.
   */
  readUint32() {
    const t = this._data.getUint32(this.offset, this.littleEndian);
    return this.offset += 4, t;
  }
  /**
   * Read a 32-bit floating number and move pointer forward by 4 bytes.
   * @returns The read value.
   */
  readFloat32() {
    const t = this._data.getFloat32(this.offset, this.littleEndian);
    return this.offset += 4, t;
  }
  /**
   * Read a 64-bit floating number and move pointer forward by 8 bytes.
   * @returns The read value.
   */
  readFloat64() {
    const t = this._data.getFloat64(this.offset, this.littleEndian);
    return this.offset += 8, t;
  }
  /**
   * Read a 64-bit signed integer number and move pointer forward by 8 bytes.
   * @returns The read value.
   */
  readBigInt64() {
    const t = this._data.getBigInt64(this.offset, this.littleEndian);
    return this.offset += 8, t;
  }
  /**
   * Read a 64-bit unsigned integer number and move pointer forward by 8 bytes.
   * @returns The read value.
   */
  readBigUint64() {
    const t = this._data.getBigUint64(this.offset, this.littleEndian);
    return this.offset += 8, t;
  }
  /**
   * Read a 1-byte ASCII character and move pointer forward by 1 byte.
   * @returns The read character.
   */
  readChar() {
    return String.fromCharCode(this.readInt8());
  }
  /**
   * Read `n` 1-byte ASCII characters and move pointer forward by `n` bytes.
   * @param n - Number of characters to read.
   * @returns The read characters.
   */
  readChars(t = 1) {
    let n = "";
    for (let r = 0; r < t; r++)
      n += this.readChar();
    return n;
  }
  /**
   * Read the next `n` bytes, return a UTF-8 decoded string and move pointer
   * forward by `n` bytes.
   * @param n - Number of bytes to read.
   * @returns The decoded string.
   */
  readUtf8(t = 1) {
    return F0(this.readBytes(t));
  }
  /**
   * Read the next `n` bytes, return a string decoded with `encoding` and move pointer
   * forward by `n` bytes.
   * If no encoding is passed, the function is equivalent to @see {@link IOBuffer#readUtf8}
   * @param n - Number of bytes to read.
   * @param encoding - The encoding to use. Default is 'utf8'.
   * @returns The decoded string.
   */
  decodeText(t = 1, n = "utf8") {
    return F0(this.readBytes(t), n);
  }
  /**
   * Write 0xff if the passed value is truthy, 0x00 otherwise and move pointer
   * forward by 1 byte.
   * @param value - The value to write.
   * @returns This.
   */
  writeBoolean(t) {
    return this.writeUint8(t ? 255 : 0), this;
  }
  /**
   * Write `value` as an 8-bit signed integer and move pointer forward by 1 byte.
   * @param value - The value to write.
   * @returns This.
   */
  writeInt8(t) {
    return this.ensureAvailable(1), this._data.setInt8(this.offset++, t), this._updateLastWrittenByte(), this;
  }
  /**
   * Write `value` as an 8-bit unsigned integer and move pointer forward by 1
   * byte.
   * @param value - The value to write.
   * @returns This.
   */
  writeUint8(t) {
    return this.ensureAvailable(1), this._data.setUint8(this.offset++, t), this._updateLastWrittenByte(), this;
  }
  /**
   * An alias for {@link IOBuffer#writeUint8}.
   * @param value - The value to write.
   * @returns This.
   */
  writeByte(t) {
    return this.writeUint8(t);
  }
  /**
   * Write all elements of `bytes` as uint8 values and move pointer forward by
   * `bytes.length` bytes.
   * @param bytes - The array of bytes to write.
   * @returns This.
   */
  writeBytes(t) {
    this.ensureAvailable(t.length);
    for (let n = 0; n < t.length; n++)
      this._data.setUint8(this.offset++, t[n]);
    return this._updateLastWrittenByte(), this;
  }
  /**
   * Write `value` as a 16-bit signed integer and move pointer forward by 2
   * bytes.
   * @param value - The value to write.
   * @returns This.
   */
  writeInt16(t) {
    return this.ensureAvailable(2), this._data.setInt16(this.offset, t, this.littleEndian), this.offset += 2, this._updateLastWrittenByte(), this;
  }
  /**
   * Write `value` as a 16-bit unsigned integer and move pointer forward by 2
   * bytes.
   * @param value - The value to write.
   * @returns This.
   */
  writeUint16(t) {
    return this.ensureAvailable(2), this._data.setUint16(this.offset, t, this.littleEndian), this.offset += 2, this._updateLastWrittenByte(), this;
  }
  /**
   * Write `value` as a 32-bit signed integer and move pointer forward by 4
   * bytes.
   * @param value - The value to write.
   * @returns This.
   */
  writeInt32(t) {
    return this.ensureAvailable(4), this._data.setInt32(this.offset, t, this.littleEndian), this.offset += 4, this._updateLastWrittenByte(), this;
  }
  /**
   * Write `value` as a 32-bit unsigned integer and move pointer forward by 4
   * bytes.
   * @param value - The value to write.
   * @returns This.
   */
  writeUint32(t) {
    return this.ensureAvailable(4), this._data.setUint32(this.offset, t, this.littleEndian), this.offset += 4, this._updateLastWrittenByte(), this;
  }
  /**
   * Write `value` as a 32-bit floating number and move pointer forward by 4
   * bytes.
   * @param value - The value to write.
   * @returns This.
   */
  writeFloat32(t) {
    return this.ensureAvailable(4), this._data.setFloat32(this.offset, t, this.littleEndian), this.offset += 4, this._updateLastWrittenByte(), this;
  }
  /**
   * Write `value` as a 64-bit floating number and move pointer forward by 8
   * bytes.
   * @param value - The value to write.
   * @returns This.
   */
  writeFloat64(t) {
    return this.ensureAvailable(8), this._data.setFloat64(this.offset, t, this.littleEndian), this.offset += 8, this._updateLastWrittenByte(), this;
  }
  /**
   * Write `value` as a 64-bit signed bigint and move pointer forward by 8
   * bytes.
   * @param value - The value to write.
   * @returns This.
   */
  writeBigInt64(t) {
    return this.ensureAvailable(8), this._data.setBigInt64(this.offset, t, this.littleEndian), this.offset += 8, this._updateLastWrittenByte(), this;
  }
  /**
   * Write `value` as a 64-bit unsigned bigint and move pointer forward by 8
   * bytes.
   * @param value - The value to write.
   * @returns This.
   */
  writeBigUint64(t) {
    return this.ensureAvailable(8), this._data.setBigUint64(this.offset, t, this.littleEndian), this.offset += 8, this._updateLastWrittenByte(), this;
  }
  /**
   * Write the charCode of `str`'s first character as an 8-bit unsigned integer
   * and move pointer forward by 1 byte.
   * @param str - The character to write.
   * @returns This.
   */
  writeChar(t) {
    return this.writeUint8(t.charCodeAt(0));
  }
  /**
   * Write the charCodes of all `str`'s characters as 8-bit unsigned integers
   * and move pointer forward by `str.length` bytes.
   * @param str - The characters to write.
   * @returns This.
   */
  writeChars(t) {
    for (let n = 0; n < t.length; n++)
      this.writeUint8(t.charCodeAt(n));
    return this;
  }
  /**
   * UTF-8 encode and write `str` to the current pointer offset and move pointer
   * forward according to the encoded length.
   * @param str - The string to write.
   * @returns This.
   */
  writeUtf8(t) {
    return this.writeBytes(ew(t));
  }
  /**
   * Export a Uint8Array view of the internal buffer.
   * The view starts at the byte offset and its length
   * is calculated to stop at the last written byte or the original length.
   * @returns A new Uint8Array view.
   */
  toArray() {
    return new Uint8Array(this.buffer, this.byteOffset, this.lastWrittenByte);
  }
  /**
   *  Get the total number of bytes written so far, regardless of the current offset.
   * @returns - Total number of bytes.
   */
  getWrittenByteLength() {
    return this.lastWrittenByte - this.byteOffset;
  }
  /**
   * Update the last written byte offset
   * @private
   */
  _updateLastWrittenByte() {
    this.offset > this.lastWrittenByte && (this.lastWrittenByte = this.offset);
  }
}
function bs(e) {
  let t = e.length;
  for (; --t >= 0; )
    e[t] = 0;
}
const rw = 3, iw = 258, ep = 29, aw = 256, sw = aw + 1 + ep, tp = 30, ow = 512, uw = new Array((sw + 2) * 2);
bs(uw);
const lw = new Array(tp * 2);
bs(lw);
const cw = new Array(ow);
bs(cw);
const fw = new Array(iw - rw + 1);
bs(fw);
const hw = new Array(ep);
bs(hw);
const dw = new Array(tp);
bs(dw);
const pw = (e, t, n, r) => {
  let i = e & 65535 | 0, a = e >>> 16 & 65535 | 0, s = 0;
  for (; n !== 0; ) {
    s = n > 2e3 ? 2e3 : n, n -= s;
    do
      i = i + t[r++] | 0, a = a + i | 0;
    while (--s);
    i %= 65521, a %= 65521;
  }
  return i | a << 16 | 0;
};
var zc = pw;
const mw = () => {
  let e, t = [];
  for (var n = 0; n < 256; n++) {
    e = n;
    for (var r = 0; r < 8; r++)
      e = e & 1 ? 3988292384 ^ e >>> 1 : e >>> 1;
    t[n] = e;
  }
  return t;
}, gw = new Uint32Array(mw()), bw = (e, t, n, r) => {
  const i = gw, a = r + n;
  e ^= -1;
  for (let s = r; s < a; s++)
    e = e >>> 8 ^ i[(e ^ t[s]) & 255];
  return e ^ -1;
};
var Qr = bw, Yc = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
}, np = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
const Ew = (e, t) => Object.prototype.hasOwnProperty.call(e, t);
var yw = function(e) {
  const t = Array.prototype.slice.call(arguments, 1);
  for (; t.length; ) {
    const n = t.shift();
    if (n) {
      if (typeof n != "object")
        throw new TypeError(n + "must be non-object");
      for (const r in n)
        Ew(n, r) && (e[r] = n[r]);
    }
  }
  return e;
}, Tw = (e) => {
  let t = 0;
  for (let r = 0, i = e.length; r < i; r++)
    t += e[r].length;
  const n = new Uint8Array(t);
  for (let r = 0, i = 0, a = e.length; r < a; r++) {
    let s = e[r];
    n.set(s, i), i += s.length;
  }
  return n;
}, rp = {
  assign: yw,
  flattenChunks: Tw
};
let ip = !0;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch {
  ip = !1;
}
const go = new Uint8Array(256);
for (let e = 0; e < 256; e++)
  go[e] = e >= 252 ? 6 : e >= 248 ? 5 : e >= 240 ? 4 : e >= 224 ? 3 : e >= 192 ? 2 : 1;
go[254] = go[254] = 1;
var _w = (e) => {
  if (typeof TextEncoder == "function" && TextEncoder.prototype.encode)
    return new TextEncoder().encode(e);
  let t, n, r, i, a, s = e.length, o = 0;
  for (i = 0; i < s; i++)
    n = e.charCodeAt(i), (n & 64512) === 55296 && i + 1 < s && (r = e.charCodeAt(i + 1), (r & 64512) === 56320 && (n = 65536 + (n - 55296 << 10) + (r - 56320), i++)), o += n < 128 ? 1 : n < 2048 ? 2 : n < 65536 ? 3 : 4;
  for (t = new Uint8Array(o), a = 0, i = 0; a < o; i++)
    n = e.charCodeAt(i), (n & 64512) === 55296 && i + 1 < s && (r = e.charCodeAt(i + 1), (r & 64512) === 56320 && (n = 65536 + (n - 55296 << 10) + (r - 56320), i++)), n < 128 ? t[a++] = n : n < 2048 ? (t[a++] = 192 | n >>> 6, t[a++] = 128 | n & 63) : n < 65536 ? (t[a++] = 224 | n >>> 12, t[a++] = 128 | n >>> 6 & 63, t[a++] = 128 | n & 63) : (t[a++] = 240 | n >>> 18, t[a++] = 128 | n >>> 12 & 63, t[a++] = 128 | n >>> 6 & 63, t[a++] = 128 | n & 63);
  return t;
};
const Aw = (e, t) => {
  if (t < 65534 && e.subarray && ip)
    return String.fromCharCode.apply(null, e.length === t ? e : e.subarray(0, t));
  let n = "";
  for (let r = 0; r < t; r++)
    n += String.fromCharCode(e[r]);
  return n;
};
var ww = (e, t) => {
  const n = t || e.length;
  if (typeof TextDecoder == "function" && TextDecoder.prototype.decode)
    return new TextDecoder().decode(e.subarray(0, t));
  let r, i;
  const a = new Array(n * 2);
  for (i = 0, r = 0; r < n; ) {
    let s = e[r++];
    if (s < 128) {
      a[i++] = s;
      continue;
    }
    let o = go[s];
    if (o > 4) {
      a[i++] = 65533, r += o - 1;
      continue;
    }
    for (s &= o === 2 ? 31 : o === 3 ? 15 : 7; o > 1 && r < n; )
      s = s << 6 | e[r++] & 63, o--;
    if (o > 1) {
      a[i++] = 65533;
      continue;
    }
    s < 65536 ? a[i++] = s : (s -= 65536, a[i++] = 55296 | s >> 10 & 1023, a[i++] = 56320 | s & 1023);
  }
  return Aw(a, i);
}, xw = (e, t) => {
  t = t || e.length, t > e.length && (t = e.length);
  let n = t - 1;
  for (; n >= 0 && (e[n] & 192) === 128; )
    n--;
  return n < 0 || n === 0 ? t : n + go[e[n]] > t ? n : t;
}, Wc = {
  string2buf: _w,
  buf2string: ww,
  utf8border: xw
};
function Nw() {
  this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
}
var vw = Nw;
const hu = 16209, Sw = 16191;
var Lw = function(t, n) {
  let r, i, a, s, o, u, c, f, p, E, d, A, v, C, _, U, B, V, ie, K, fe, Z, z, D;
  const N = t.state;
  r = t.next_in, z = t.input, i = r + (t.avail_in - 5), a = t.next_out, D = t.output, s = a - (n - t.avail_out), o = a + (t.avail_out - 257), u = N.dmax, c = N.wsize, f = N.whave, p = N.wnext, E = N.window, d = N.hold, A = N.bits, v = N.lencode, C = N.distcode, _ = (1 << N.lenbits) - 1, U = (1 << N.distbits) - 1;
  e:
    do {
      A < 15 && (d += z[r++] << A, A += 8, d += z[r++] << A, A += 8), B = v[d & _];
      t:
        for (; ; ) {
          if (V = B >>> 24, d >>>= V, A -= V, V = B >>> 16 & 255, V === 0)
            D[a++] = B & 65535;
          else if (V & 16) {
            ie = B & 65535, V &= 15, V && (A < V && (d += z[r++] << A, A += 8), ie += d & (1 << V) - 1, d >>>= V, A -= V), A < 15 && (d += z[r++] << A, A += 8, d += z[r++] << A, A += 8), B = C[d & U];
            n:
              for (; ; ) {
                if (V = B >>> 24, d >>>= V, A -= V, V = B >>> 16 & 255, V & 16) {
                  if (K = B & 65535, V &= 15, A < V && (d += z[r++] << A, A += 8, A < V && (d += z[r++] << A, A += 8)), K += d & (1 << V) - 1, K > u) {
                    t.msg = "invalid distance too far back", N.mode = hu;
                    break e;
                  }
                  if (d >>>= V, A -= V, V = a - s, K > V) {
                    if (V = K - V, V > f && N.sane) {
                      t.msg = "invalid distance too far back", N.mode = hu;
                      break e;
                    }
                    if (fe = 0, Z = E, p === 0) {
                      if (fe += c - V, V < ie) {
                        ie -= V;
                        do
                          D[a++] = E[fe++];
                        while (--V);
                        fe = a - K, Z = D;
                      }
                    } else if (p < V) {
                      if (fe += c + p - V, V -= p, V < ie) {
                        ie -= V;
                        do
                          D[a++] = E[fe++];
                        while (--V);
                        if (fe = 0, p < ie) {
                          V = p, ie -= V;
                          do
                            D[a++] = E[fe++];
                          while (--V);
                          fe = a - K, Z = D;
                        }
                      }
                    } else if (fe += p - V, V < ie) {
                      ie -= V;
                      do
                        D[a++] = E[fe++];
                      while (--V);
                      fe = a - K, Z = D;
                    }
                    for (; ie > 2; )
                      D[a++] = Z[fe++], D[a++] = Z[fe++], D[a++] = Z[fe++], ie -= 3;
                    ie && (D[a++] = Z[fe++], ie > 1 && (D[a++] = Z[fe++]));
                  } else {
                    fe = a - K;
                    do
                      D[a++] = D[fe++], D[a++] = D[fe++], D[a++] = D[fe++], ie -= 3;
                    while (ie > 2);
                    ie && (D[a++] = D[fe++], ie > 1 && (D[a++] = D[fe++]));
                  }
                } else if ((V & 64) === 0) {
                  B = C[(B & 65535) + (d & (1 << V) - 1)];
                  continue n;
                } else {
                  t.msg = "invalid distance code", N.mode = hu;
                  break e;
                }
                break;
              }
          } else if ((V & 64) === 0) {
            B = v[(B & 65535) + (d & (1 << V) - 1)];
            continue t;
          } else if (V & 32) {
            N.mode = Sw;
            break e;
          } else {
            t.msg = "invalid literal/length code", N.mode = hu;
            break e;
          }
          break;
        }
    } while (r < i && a < o);
  ie = A >> 3, r -= ie, A -= ie << 3, d &= (1 << A) - 1, t.next_in = r, t.next_out = a, t.avail_in = r < i ? 5 + (i - r) : 5 - (r - i), t.avail_out = a < o ? 257 + (o - a) : 257 - (a - o), N.hold = d, N.bits = A;
};
const Ka = 15, B0 = 852, U0 = 592, H0 = 0, rc = 1, j0 = 2, kw = new Uint16Array([
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]), Cw = new Uint8Array([
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]), Iw = new Uint16Array([
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]), Pw = new Uint8Array([
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]), Ow = (e, t, n, r, i, a, s, o) => {
  const u = o.bits;
  let c = 0, f = 0, p = 0, E = 0, d = 0, A = 0, v = 0, C = 0, _ = 0, U = 0, B, V, ie, K, fe, Z = null, z;
  const D = new Uint16Array(Ka + 1), N = new Uint16Array(Ka + 1);
  let I = null, $, Y, J;
  for (c = 0; c <= Ka; c++)
    D[c] = 0;
  for (f = 0; f < r; f++)
    D[t[n + f]]++;
  for (d = u, E = Ka; E >= 1 && D[E] === 0; E--)
    ;
  if (d > E && (d = E), E === 0)
    return i[a++] = 1 << 24 | 64 << 16 | 0, i[a++] = 1 << 24 | 64 << 16 | 0, o.bits = 1, 0;
  for (p = 1; p < E && D[p] === 0; p++)
    ;
  for (d < p && (d = p), C = 1, c = 1; c <= Ka; c++)
    if (C <<= 1, C -= D[c], C < 0)
      return -1;
  if (C > 0 && (e === H0 || E !== 1))
    return -1;
  for (N[1] = 0, c = 1; c < Ka; c++)
    N[c + 1] = N[c] + D[c];
  for (f = 0; f < r; f++)
    t[n + f] !== 0 && (s[N[t[n + f]]++] = f);
  if (e === H0 ? (Z = I = s, z = 20) : e === rc ? (Z = kw, I = Cw, z = 257) : (Z = Iw, I = Pw, z = 0), U = 0, f = 0, c = p, fe = a, A = d, v = 0, ie = -1, _ = 1 << d, K = _ - 1, e === rc && _ > B0 || e === j0 && _ > U0)
    return 1;
  for (; ; ) {
    $ = c - v, s[f] + 1 < z ? (Y = 0, J = s[f]) : s[f] >= z ? (Y = I[s[f] - z], J = Z[s[f] - z]) : (Y = 96, J = 0), B = 1 << c - v, V = 1 << A, p = V;
    do
      V -= B, i[fe + (U >> v) + V] = $ << 24 | Y << 16 | J | 0;
    while (V !== 0);
    for (B = 1 << c - 1; U & B; )
      B >>= 1;
    if (B !== 0 ? (U &= B - 1, U += B) : U = 0, f++, --D[c] === 0) {
      if (c === E)
        break;
      c = t[n + s[f]];
    }
    if (c > d && (U & K) !== ie) {
      for (v === 0 && (v = d), fe += p, A = c - v, C = 1 << A; A + v < E && (C -= D[A + v], !(C <= 0)); )
        A++, C <<= 1;
      if (_ += 1 << A, e === rc && _ > B0 || e === j0 && _ > U0)
        return 1;
      ie = U & K, i[ie] = d << 24 | A << 16 | fe - a | 0;
    }
  }
  return U !== 0 && (i[fe + U] = c - v << 24 | 64 << 16 | 0), o.bits = d, 0;
};
var co = Ow;
const Rw = 0, ap = 1, sp = 2, {
  Z_FINISH: q0,
  Z_BLOCK: Dw,
  Z_TREES: du,
  Z_OK: La,
  Z_STREAM_END: Mw,
  Z_NEED_DICT: Fw,
  Z_STREAM_ERROR: Sr,
  Z_DATA_ERROR: op,
  Z_MEM_ERROR: up,
  Z_BUF_ERROR: Bw,
  Z_DEFLATED: z0
} = np, tl = 16180, Y0 = 16181, W0 = 16182, V0 = 16183, G0 = 16184, $0 = 16185, X0 = 16186, K0 = 16187, Q0 = 16188, J0 = 16189, Uu = 16190, xi = 16191, ic = 16192, Z0 = 16193, ac = 16194, ed = 16195, td = 16196, nd = 16197, rd = 16198, pu = 16199, mu = 16200, id = 16201, ad = 16202, sd = 16203, od = 16204, ud = 16205, sc = 16206, ld = 16207, cd = 16208, Zt = 16209, lp = 16210, cp = 16211, Uw = 852, Hw = 592, jw = 15, qw = jw, fd = (e) => (e >>> 24 & 255) + (e >>> 8 & 65280) + ((e & 65280) << 8) + ((e & 255) << 24);
function zw() {
  this.strm = null, this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
}
const Ia = (e) => {
  if (!e)
    return 1;
  const t = e.state;
  return !t || t.strm !== e || t.mode < tl || t.mode > cp ? 1 : 0;
}, fp = (e) => {
  if (Ia(e))
    return Sr;
  const t = e.state;
  return e.total_in = e.total_out = t.total = 0, e.msg = "", t.wrap && (e.adler = t.wrap & 1), t.mode = tl, t.last = 0, t.havedict = 0, t.flags = -1, t.dmax = 32768, t.head = null, t.hold = 0, t.bits = 0, t.lencode = t.lendyn = new Int32Array(Uw), t.distcode = t.distdyn = new Int32Array(Hw), t.sane = 1, t.back = -1, La;
}, hp = (e) => {
  if (Ia(e))
    return Sr;
  const t = e.state;
  return t.wsize = 0, t.whave = 0, t.wnext = 0, fp(e);
}, dp = (e, t) => {
  let n;
  if (Ia(e))
    return Sr;
  const r = e.state;
  return t < 0 ? (n = 0, t = -t) : (n = (t >> 4) + 5, t < 48 && (t &= 15)), t && (t < 8 || t > 15) ? Sr : (r.window !== null && r.wbits !== t && (r.window = null), r.wrap = n, r.wbits = t, hp(e));
}, pp = (e, t) => {
  if (!e)
    return Sr;
  const n = new zw();
  e.state = n, n.strm = e, n.window = null, n.mode = tl;
  const r = dp(e, t);
  return r !== La && (e.state = null), r;
}, Yw = (e) => pp(e, qw);
let hd = !0, oc, uc;
const Ww = (e) => {
  if (hd) {
    oc = new Int32Array(512), uc = new Int32Array(32);
    let t = 0;
    for (; t < 144; )
      e.lens[t++] = 8;
    for (; t < 256; )
      e.lens[t++] = 9;
    for (; t < 280; )
      e.lens[t++] = 7;
    for (; t < 288; )
      e.lens[t++] = 8;
    for (co(ap, e.lens, 0, 288, oc, 0, e.work, { bits: 9 }), t = 0; t < 32; )
      e.lens[t++] = 5;
    co(sp, e.lens, 0, 32, uc, 0, e.work, { bits: 5 }), hd = !1;
  }
  e.lencode = oc, e.lenbits = 9, e.distcode = uc, e.distbits = 5;
}, mp = (e, t, n, r) => {
  let i;
  const a = e.state;
  return a.window === null && (a.wsize = 1 << a.wbits, a.wnext = 0, a.whave = 0, a.window = new Uint8Array(a.wsize)), r >= a.wsize ? (a.window.set(t.subarray(n - a.wsize, n), 0), a.wnext = 0, a.whave = a.wsize) : (i = a.wsize - a.wnext, i > r && (i = r), a.window.set(t.subarray(n - r, n - r + i), a.wnext), r -= i, r ? (a.window.set(t.subarray(n - r, n), 0), a.wnext = r, a.whave = a.wsize) : (a.wnext += i, a.wnext === a.wsize && (a.wnext = 0), a.whave < a.wsize && (a.whave += i))), 0;
}, Vw = (e, t) => {
  let n, r, i, a, s, o, u, c, f, p, E, d, A, v, C = 0, _, U, B, V, ie, K, fe, Z;
  const z = new Uint8Array(4);
  let D, N;
  const I = (
    /* permutation of code lengths */
    new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  );
  if (Ia(e) || !e.output || !e.input && e.avail_in !== 0)
    return Sr;
  n = e.state, n.mode === xi && (n.mode = ic), s = e.next_out, i = e.output, u = e.avail_out, a = e.next_in, r = e.input, o = e.avail_in, c = n.hold, f = n.bits, p = o, E = u, Z = La;
  e:
    for (; ; )
      switch (n.mode) {
        case tl:
          if (n.wrap === 0) {
            n.mode = ic;
            break;
          }
          for (; f < 16; ) {
            if (o === 0)
              break e;
            o--, c += r[a++] << f, f += 8;
          }
          if (n.wrap & 2 && c === 35615) {
            n.wbits === 0 && (n.wbits = 15), n.check = 0, z[0] = c & 255, z[1] = c >>> 8 & 255, n.check = Qr(n.check, z, 2, 0), c = 0, f = 0, n.mode = Y0;
            break;
          }
          if (n.head && (n.head.done = !1), !(n.wrap & 1) || /* check if zlib header allowed */
          (((c & 255) << 8) + (c >> 8)) % 31) {
            e.msg = "incorrect header check", n.mode = Zt;
            break;
          }
          if ((c & 15) !== z0) {
            e.msg = "unknown compression method", n.mode = Zt;
            break;
          }
          if (c >>>= 4, f -= 4, fe = (c & 15) + 8, n.wbits === 0 && (n.wbits = fe), fe > 15 || fe > n.wbits) {
            e.msg = "invalid window size", n.mode = Zt;
            break;
          }
          n.dmax = 1 << n.wbits, n.flags = 0, e.adler = n.check = 1, n.mode = c & 512 ? J0 : xi, c = 0, f = 0;
          break;
        case Y0:
          for (; f < 16; ) {
            if (o === 0)
              break e;
            o--, c += r[a++] << f, f += 8;
          }
          if (n.flags = c, (n.flags & 255) !== z0) {
            e.msg = "unknown compression method", n.mode = Zt;
            break;
          }
          if (n.flags & 57344) {
            e.msg = "unknown header flags set", n.mode = Zt;
            break;
          }
          n.head && (n.head.text = c >> 8 & 1), n.flags & 512 && n.wrap & 4 && (z[0] = c & 255, z[1] = c >>> 8 & 255, n.check = Qr(n.check, z, 2, 0)), c = 0, f = 0, n.mode = W0;
        /* falls through */
        case W0:
          for (; f < 32; ) {
            if (o === 0)
              break e;
            o--, c += r[a++] << f, f += 8;
          }
          n.head && (n.head.time = c), n.flags & 512 && n.wrap & 4 && (z[0] = c & 255, z[1] = c >>> 8 & 255, z[2] = c >>> 16 & 255, z[3] = c >>> 24 & 255, n.check = Qr(n.check, z, 4, 0)), c = 0, f = 0, n.mode = V0;
        /* falls through */
        case V0:
          for (; f < 16; ) {
            if (o === 0)
              break e;
            o--, c += r[a++] << f, f += 8;
          }
          n.head && (n.head.xflags = c & 255, n.head.os = c >> 8), n.flags & 512 && n.wrap & 4 && (z[0] = c & 255, z[1] = c >>> 8 & 255, n.check = Qr(n.check, z, 2, 0)), c = 0, f = 0, n.mode = G0;
        /* falls through */
        case G0:
          if (n.flags & 1024) {
            for (; f < 16; ) {
              if (o === 0)
                break e;
              o--, c += r[a++] << f, f += 8;
            }
            n.length = c, n.head && (n.head.extra_len = c), n.flags & 512 && n.wrap & 4 && (z[0] = c & 255, z[1] = c >>> 8 & 255, n.check = Qr(n.check, z, 2, 0)), c = 0, f = 0;
          } else n.head && (n.head.extra = null);
          n.mode = $0;
        /* falls through */
        case $0:
          if (n.flags & 1024 && (d = n.length, d > o && (d = o), d && (n.head && (fe = n.head.extra_len - n.length, n.head.extra || (n.head.extra = new Uint8Array(n.head.extra_len)), n.head.extra.set(
            r.subarray(
              a,
              // extra field is limited to 65536 bytes
              // - no need for additional size check
              a + d
            ),
            /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
            fe
          )), n.flags & 512 && n.wrap & 4 && (n.check = Qr(n.check, r, d, a)), o -= d, a += d, n.length -= d), n.length))
            break e;
          n.length = 0, n.mode = X0;
        /* falls through */
        case X0:
          if (n.flags & 2048) {
            if (o === 0)
              break e;
            d = 0;
            do
              fe = r[a + d++], n.head && fe && n.length < 65536 && (n.head.name += String.fromCharCode(fe));
            while (fe && d < o);
            if (n.flags & 512 && n.wrap & 4 && (n.check = Qr(n.check, r, d, a)), o -= d, a += d, fe)
              break e;
          } else n.head && (n.head.name = null);
          n.length = 0, n.mode = K0;
        /* falls through */
        case K0:
          if (n.flags & 4096) {
            if (o === 0)
              break e;
            d = 0;
            do
              fe = r[a + d++], n.head && fe && n.length < 65536 && (n.head.comment += String.fromCharCode(fe));
            while (fe && d < o);
            if (n.flags & 512 && n.wrap & 4 && (n.check = Qr(n.check, r, d, a)), o -= d, a += d, fe)
              break e;
          } else n.head && (n.head.comment = null);
          n.mode = Q0;
        /* falls through */
        case Q0:
          if (n.flags & 512) {
            for (; f < 16; ) {
              if (o === 0)
                break e;
              o--, c += r[a++] << f, f += 8;
            }
            if (n.wrap & 4 && c !== (n.check & 65535)) {
              e.msg = "header crc mismatch", n.mode = Zt;
              break;
            }
            c = 0, f = 0;
          }
          n.head && (n.head.hcrc = n.flags >> 9 & 1, n.head.done = !0), e.adler = n.check = 0, n.mode = xi;
          break;
        case J0:
          for (; f < 32; ) {
            if (o === 0)
              break e;
            o--, c += r[a++] << f, f += 8;
          }
          e.adler = n.check = fd(c), c = 0, f = 0, n.mode = Uu;
        /* falls through */
        case Uu:
          if (n.havedict === 0)
            return e.next_out = s, e.avail_out = u, e.next_in = a, e.avail_in = o, n.hold = c, n.bits = f, Fw;
          e.adler = n.check = 1, n.mode = xi;
        /* falls through */
        case xi:
          if (t === Dw || t === du)
            break e;
        /* falls through */
        case ic:
          if (n.last) {
            c >>>= f & 7, f -= f & 7, n.mode = sc;
            break;
          }
          for (; f < 3; ) {
            if (o === 0)
              break e;
            o--, c += r[a++] << f, f += 8;
          }
          switch (n.last = c & 1, c >>>= 1, f -= 1, c & 3) {
            case 0:
              n.mode = Z0;
              break;
            case 1:
              if (Ww(n), n.mode = pu, t === du) {
                c >>>= 2, f -= 2;
                break e;
              }
              break;
            case 2:
              n.mode = td;
              break;
            case 3:
              e.msg = "invalid block type", n.mode = Zt;
          }
          c >>>= 2, f -= 2;
          break;
        case Z0:
          for (c >>>= f & 7, f -= f & 7; f < 32; ) {
            if (o === 0)
              break e;
            o--, c += r[a++] << f, f += 8;
          }
          if ((c & 65535) !== (c >>> 16 ^ 65535)) {
            e.msg = "invalid stored block lengths", n.mode = Zt;
            break;
          }
          if (n.length = c & 65535, c = 0, f = 0, n.mode = ac, t === du)
            break e;
        /* falls through */
        case ac:
          n.mode = ed;
        /* falls through */
        case ed:
          if (d = n.length, d) {
            if (d > o && (d = o), d > u && (d = u), d === 0)
              break e;
            i.set(r.subarray(a, a + d), s), o -= d, a += d, u -= d, s += d, n.length -= d;
            break;
          }
          n.mode = xi;
          break;
        case td:
          for (; f < 14; ) {
            if (o === 0)
              break e;
            o--, c += r[a++] << f, f += 8;
          }
          if (n.nlen = (c & 31) + 257, c >>>= 5, f -= 5, n.ndist = (c & 31) + 1, c >>>= 5, f -= 5, n.ncode = (c & 15) + 4, c >>>= 4, f -= 4, n.nlen > 286 || n.ndist > 30) {
            e.msg = "too many length or distance symbols", n.mode = Zt;
            break;
          }
          n.have = 0, n.mode = nd;
        /* falls through */
        case nd:
          for (; n.have < n.ncode; ) {
            for (; f < 3; ) {
              if (o === 0)
                break e;
              o--, c += r[a++] << f, f += 8;
            }
            n.lens[I[n.have++]] = c & 7, c >>>= 3, f -= 3;
          }
          for (; n.have < 19; )
            n.lens[I[n.have++]] = 0;
          if (n.lencode = n.lendyn, n.lenbits = 7, D = { bits: n.lenbits }, Z = co(Rw, n.lens, 0, 19, n.lencode, 0, n.work, D), n.lenbits = D.bits, Z) {
            e.msg = "invalid code lengths set", n.mode = Zt;
            break;
          }
          n.have = 0, n.mode = rd;
        /* falls through */
        case rd:
          for (; n.have < n.nlen + n.ndist; ) {
            for (; C = n.lencode[c & (1 << n.lenbits) - 1], _ = C >>> 24, U = C >>> 16 & 255, B = C & 65535, !(_ <= f); ) {
              if (o === 0)
                break e;
              o--, c += r[a++] << f, f += 8;
            }
            if (B < 16)
              c >>>= _, f -= _, n.lens[n.have++] = B;
            else {
              if (B === 16) {
                for (N = _ + 2; f < N; ) {
                  if (o === 0)
                    break e;
                  o--, c += r[a++] << f, f += 8;
                }
                if (c >>>= _, f -= _, n.have === 0) {
                  e.msg = "invalid bit length repeat", n.mode = Zt;
                  break;
                }
                fe = n.lens[n.have - 1], d = 3 + (c & 3), c >>>= 2, f -= 2;
              } else if (B === 17) {
                for (N = _ + 3; f < N; ) {
                  if (o === 0)
                    break e;
                  o--, c += r[a++] << f, f += 8;
                }
                c >>>= _, f -= _, fe = 0, d = 3 + (c & 7), c >>>= 3, f -= 3;
              } else {
                for (N = _ + 7; f < N; ) {
                  if (o === 0)
                    break e;
                  o--, c += r[a++] << f, f += 8;
                }
                c >>>= _, f -= _, fe = 0, d = 11 + (c & 127), c >>>= 7, f -= 7;
              }
              if (n.have + d > n.nlen + n.ndist) {
                e.msg = "invalid bit length repeat", n.mode = Zt;
                break;
              }
              for (; d--; )
                n.lens[n.have++] = fe;
            }
          }
          if (n.mode === Zt)
            break;
          if (n.lens[256] === 0) {
            e.msg = "invalid code -- missing end-of-block", n.mode = Zt;
            break;
          }
          if (n.lenbits = 9, D = { bits: n.lenbits }, Z = co(ap, n.lens, 0, n.nlen, n.lencode, 0, n.work, D), n.lenbits = D.bits, Z) {
            e.msg = "invalid literal/lengths set", n.mode = Zt;
            break;
          }
          if (n.distbits = 6, n.distcode = n.distdyn, D = { bits: n.distbits }, Z = co(sp, n.lens, n.nlen, n.ndist, n.distcode, 0, n.work, D), n.distbits = D.bits, Z) {
            e.msg = "invalid distances set", n.mode = Zt;
            break;
          }
          if (n.mode = pu, t === du)
            break e;
        /* falls through */
        case pu:
          n.mode = mu;
        /* falls through */
        case mu:
          if (o >= 6 && u >= 258) {
            e.next_out = s, e.avail_out = u, e.next_in = a, e.avail_in = o, n.hold = c, n.bits = f, Lw(e, E), s = e.next_out, i = e.output, u = e.avail_out, a = e.next_in, r = e.input, o = e.avail_in, c = n.hold, f = n.bits, n.mode === xi && (n.back = -1);
            break;
          }
          for (n.back = 0; C = n.lencode[c & (1 << n.lenbits) - 1], _ = C >>> 24, U = C >>> 16 & 255, B = C & 65535, !(_ <= f); ) {
            if (o === 0)
              break e;
            o--, c += r[a++] << f, f += 8;
          }
          if (U && (U & 240) === 0) {
            for (V = _, ie = U, K = B; C = n.lencode[K + ((c & (1 << V + ie) - 1) >> V)], _ = C >>> 24, U = C >>> 16 & 255, B = C & 65535, !(V + _ <= f); ) {
              if (o === 0)
                break e;
              o--, c += r[a++] << f, f += 8;
            }
            c >>>= V, f -= V, n.back += V;
          }
          if (c >>>= _, f -= _, n.back += _, n.length = B, U === 0) {
            n.mode = ud;
            break;
          }
          if (U & 32) {
            n.back = -1, n.mode = xi;
            break;
          }
          if (U & 64) {
            e.msg = "invalid literal/length code", n.mode = Zt;
            break;
          }
          n.extra = U & 15, n.mode = id;
        /* falls through */
        case id:
          if (n.extra) {
            for (N = n.extra; f < N; ) {
              if (o === 0)
                break e;
              o--, c += r[a++] << f, f += 8;
            }
            n.length += c & (1 << n.extra) - 1, c >>>= n.extra, f -= n.extra, n.back += n.extra;
          }
          n.was = n.length, n.mode = ad;
        /* falls through */
        case ad:
          for (; C = n.distcode[c & (1 << n.distbits) - 1], _ = C >>> 24, U = C >>> 16 & 255, B = C & 65535, !(_ <= f); ) {
            if (o === 0)
              break e;
            o--, c += r[a++] << f, f += 8;
          }
          if ((U & 240) === 0) {
            for (V = _, ie = U, K = B; C = n.distcode[K + ((c & (1 << V + ie) - 1) >> V)], _ = C >>> 24, U = C >>> 16 & 255, B = C & 65535, !(V + _ <= f); ) {
              if (o === 0)
                break e;
              o--, c += r[a++] << f, f += 8;
            }
            c >>>= V, f -= V, n.back += V;
          }
          if (c >>>= _, f -= _, n.back += _, U & 64) {
            e.msg = "invalid distance code", n.mode = Zt;
            break;
          }
          n.offset = B, n.extra = U & 15, n.mode = sd;
        /* falls through */
        case sd:
          if (n.extra) {
            for (N = n.extra; f < N; ) {
              if (o === 0)
                break e;
              o--, c += r[a++] << f, f += 8;
            }
            n.offset += c & (1 << n.extra) - 1, c >>>= n.extra, f -= n.extra, n.back += n.extra;
          }
          if (n.offset > n.dmax) {
            e.msg = "invalid distance too far back", n.mode = Zt;
            break;
          }
          n.mode = od;
        /* falls through */
        case od:
          if (u === 0)
            break e;
          if (d = E - u, n.offset > d) {
            if (d = n.offset - d, d > n.whave && n.sane) {
              e.msg = "invalid distance too far back", n.mode = Zt;
              break;
            }
            d > n.wnext ? (d -= n.wnext, A = n.wsize - d) : A = n.wnext - d, d > n.length && (d = n.length), v = n.window;
          } else
            v = i, A = s - n.offset, d = n.length;
          d > u && (d = u), u -= d, n.length -= d;
          do
            i[s++] = v[A++];
          while (--d);
          n.length === 0 && (n.mode = mu);
          break;
        case ud:
          if (u === 0)
            break e;
          i[s++] = n.length, u--, n.mode = mu;
          break;
        case sc:
          if (n.wrap) {
            for (; f < 32; ) {
              if (o === 0)
                break e;
              o--, c |= r[a++] << f, f += 8;
            }
            if (E -= u, e.total_out += E, n.total += E, n.wrap & 4 && E && (e.adler = n.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
            n.flags ? Qr(n.check, i, E, s - E) : zc(n.check, i, E, s - E)), E = u, n.wrap & 4 && (n.flags ? c : fd(c)) !== n.check) {
              e.msg = "incorrect data check", n.mode = Zt;
              break;
            }
            c = 0, f = 0;
          }
          n.mode = ld;
        /* falls through */
        case ld:
          if (n.wrap && n.flags) {
            for (; f < 32; ) {
              if (o === 0)
                break e;
              o--, c += r[a++] << f, f += 8;
            }
            if (n.wrap & 4 && c !== (n.total & 4294967295)) {
              e.msg = "incorrect length check", n.mode = Zt;
              break;
            }
            c = 0, f = 0;
          }
          n.mode = cd;
        /* falls through */
        case cd:
          Z = Mw;
          break e;
        case Zt:
          Z = op;
          break e;
        case lp:
          return up;
        case cp:
        /* falls through */
        default:
          return Sr;
      }
  return e.next_out = s, e.avail_out = u, e.next_in = a, e.avail_in = o, n.hold = c, n.bits = f, (n.wsize || E !== e.avail_out && n.mode < Zt && (n.mode < sc || t !== q0)) && mp(e, e.output, e.next_out, E - e.avail_out), p -= e.avail_in, E -= e.avail_out, e.total_in += p, e.total_out += E, n.total += E, n.wrap & 4 && E && (e.adler = n.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
  n.flags ? Qr(n.check, i, E, e.next_out - E) : zc(n.check, i, E, e.next_out - E)), e.data_type = n.bits + (n.last ? 64 : 0) + (n.mode === xi ? 128 : 0) + (n.mode === pu || n.mode === ac ? 256 : 0), (p === 0 && E === 0 || t === q0) && Z === La && (Z = Bw), Z;
}, Gw = (e) => {
  if (Ia(e))
    return Sr;
  let t = e.state;
  return t.window && (t.window = null), e.state = null, La;
}, $w = (e, t) => {
  if (Ia(e))
    return Sr;
  const n = e.state;
  return (n.wrap & 2) === 0 ? Sr : (n.head = t, t.done = !1, La);
}, Xw = (e, t) => {
  const n = t.length;
  let r, i, a;
  return Ia(e) || (r = e.state, r.wrap !== 0 && r.mode !== Uu) ? Sr : r.mode === Uu && (i = 1, i = zc(i, t, n, 0), i !== r.check) ? op : (a = mp(e, t, n, n), a ? (r.mode = lp, up) : (r.havedict = 1, La));
};
var Kw = hp, Qw = dp, Jw = fp, Zw = Yw, ex = pp, tx = Vw, nx = Gw, rx = $w, ix = Xw, ax = "pako inflate (from Nodeca project)", Ni = {
  inflateReset: Kw,
  inflateReset2: Qw,
  inflateResetKeep: Jw,
  inflateInit: Zw,
  inflateInit2: ex,
  inflate: tx,
  inflateEnd: nx,
  inflateGetHeader: rx,
  inflateSetDictionary: ix,
  inflateInfo: ax
};
function sx() {
  this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
}
var ox = sx;
const gp = Object.prototype.toString, {
  Z_NO_FLUSH: ux,
  Z_FINISH: lx,
  Z_OK: bo,
  Z_STREAM_END: lc,
  Z_NEED_DICT: cc,
  Z_STREAM_ERROR: cx,
  Z_DATA_ERROR: dd,
  Z_MEM_ERROR: fx
} = np;
function xo(e) {
  this.options = rp.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, e || {});
  const t = this.options;
  t.raw && t.windowBits >= 0 && t.windowBits < 16 && (t.windowBits = -t.windowBits, t.windowBits === 0 && (t.windowBits = -15)), t.windowBits >= 0 && t.windowBits < 16 && !(e && e.windowBits) && (t.windowBits += 32), t.windowBits > 15 && t.windowBits < 48 && (t.windowBits & 15) === 0 && (t.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new vw(), this.strm.avail_out = 0;
  let n = Ni.inflateInit2(
    this.strm,
    t.windowBits
  );
  if (n !== bo)
    throw new Error(Yc[n]);
  if (this.header = new ox(), Ni.inflateGetHeader(this.strm, this.header), t.dictionary && (typeof t.dictionary == "string" ? t.dictionary = Wc.string2buf(t.dictionary) : gp.call(t.dictionary) === "[object ArrayBuffer]" && (t.dictionary = new Uint8Array(t.dictionary)), t.raw && (n = Ni.inflateSetDictionary(this.strm, t.dictionary), n !== bo)))
    throw new Error(Yc[n]);
}
xo.prototype.push = function(e, t) {
  const n = this.strm, r = this.options.chunkSize, i = this.options.dictionary;
  let a, s, o;
  if (this.ended) return !1;
  for (t === ~~t ? s = t : s = t === !0 ? lx : ux, gp.call(e) === "[object ArrayBuffer]" ? n.input = new Uint8Array(e) : n.input = e, n.next_in = 0, n.avail_in = n.input.length; ; ) {
    for (n.avail_out === 0 && (n.output = new Uint8Array(r), n.next_out = 0, n.avail_out = r), a = Ni.inflate(n, s), a === cc && i && (a = Ni.inflateSetDictionary(n, i), a === bo ? a = Ni.inflate(n, s) : a === dd && (a = cc)); n.avail_in > 0 && a === lc && n.state.wrap > 0 && e[n.next_in] !== 0; )
      Ni.inflateReset(n), a = Ni.inflate(n, s);
    switch (a) {
      case cx:
      case dd:
      case cc:
      case fx:
        return this.onEnd(a), this.ended = !0, !1;
    }
    if (o = n.avail_out, n.next_out && (n.avail_out === 0 || a === lc))
      if (this.options.to === "string") {
        let u = Wc.utf8border(n.output, n.next_out), c = n.next_out - u, f = Wc.buf2string(n.output, u);
        n.next_out = c, n.avail_out = r - c, c && n.output.set(n.output.subarray(u, u + c), 0), this.onData(f);
      } else
        this.onData(n.output.length === n.next_out ? n.output : n.output.subarray(0, n.next_out));
    if (!(a === bo && o === 0)) {
      if (a === lc)
        return a = Ni.inflateEnd(this.strm), this.onEnd(a), this.ended = !0, !0;
      if (n.avail_in === 0) break;
    }
  }
  return !0;
};
xo.prototype.onData = function(e) {
  this.chunks.push(e);
};
xo.prototype.onEnd = function(e) {
  e === bo && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = rp.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg;
};
function hx(e, t) {
  const n = new xo(t);
  if (n.push(e), n.err) throw n.msg || Yc[n.err];
  return n.result;
}
var dx = xo, px = hx, mx = {
  Inflate: dx,
  inflate: px
};
const { Inflate: gx, inflate: bx } = mx;
var pd = gx, Ex = bx;
const bp = [];
for (let e = 0; e < 256; e++) {
  let t = e;
  for (let n = 0; n < 8; n++)
    t & 1 ? t = 3988292384 ^ t >>> 1 : t = t >>> 1;
  bp[e] = t;
}
const md = 4294967295;
function yx(e, t, n) {
  let r = e;
  for (let i = 0; i < n; i++)
    r = bp[(r ^ t[i]) & 255] ^ r >>> 8;
  return r;
}
function Tx(e, t) {
  return (yx(md, e, t) ^ md) >>> 0;
}
function gd(e, t, n) {
  const r = e.readUint32(), i = Tx(new Uint8Array(e.buffer, e.byteOffset + e.offset - t - 4, t), t);
  if (i !== r)
    throw new Error(`CRC mismatch for chunk ${n}. Expected ${r}, found ${i}`);
}
function Ep(e, t, n) {
  for (let r = 0; r < n; r++)
    t[r] = e[r];
}
function yp(e, t, n, r) {
  let i = 0;
  for (; i < r; i++)
    t[i] = e[i];
  for (; i < n; i++)
    t[i] = e[i] + t[i - r] & 255;
}
function Tp(e, t, n, r) {
  let i = 0;
  if (n.length === 0)
    for (; i < r; i++)
      t[i] = e[i];
  else
    for (; i < r; i++)
      t[i] = e[i] + n[i] & 255;
}
function _p(e, t, n, r, i) {
  let a = 0;
  if (n.length === 0) {
    for (; a < i; a++)
      t[a] = e[a];
    for (; a < r; a++)
      t[a] = e[a] + (t[a - i] >> 1) & 255;
  } else {
    for (; a < i; a++)
      t[a] = e[a] + (n[a] >> 1) & 255;
    for (; a < r; a++)
      t[a] = e[a] + (t[a - i] + n[a] >> 1) & 255;
  }
}
function Ap(e, t, n, r, i) {
  let a = 0;
  if (n.length === 0) {
    for (; a < i; a++)
      t[a] = e[a];
    for (; a < r; a++)
      t[a] = e[a] + t[a - i] & 255;
  } else {
    for (; a < i; a++)
      t[a] = e[a] + n[a] & 255;
    for (; a < r; a++)
      t[a] = e[a] + _x(t[a - i], n[a], n[a - i]) & 255;
  }
}
function _x(e, t, n) {
  const r = e + t - n, i = Math.abs(r - e), a = Math.abs(r - t), s = Math.abs(r - n);
  return i <= a && i <= s ? e : a <= s ? t : n;
}
function Ax(e, t, n, r, i, a) {
  switch (e) {
    case 0:
      Ep(t, n, i);
      break;
    case 1:
      yp(t, n, i, a);
      break;
    case 2:
      Tp(t, n, r, i);
      break;
    case 3:
      _p(t, n, r, i, a);
      break;
    case 4:
      Ap(t, n, r, i, a);
      break;
    default:
      throw new Error(`Unsupported filter: ${e}`);
  }
}
const wx = new Uint16Array([255]), xx = new Uint8Array(wx.buffer), Nx = xx[0] === 255;
function vx(e) {
  const { data: t, width: n, height: r, channels: i, depth: a } = e, s = [
    { x: 0, y: 0, xStep: 8, yStep: 8 },
    // Pass 1
    { x: 4, y: 0, xStep: 8, yStep: 8 },
    // Pass 2
    { x: 0, y: 4, xStep: 4, yStep: 8 },
    // Pass 3
    { x: 2, y: 0, xStep: 4, yStep: 4 },
    // Pass 4
    { x: 0, y: 2, xStep: 2, yStep: 4 },
    // Pass 5
    { x: 1, y: 0, xStep: 2, yStep: 2 },
    // Pass 6
    { x: 0, y: 1, xStep: 1, yStep: 2 }
    // Pass 7
  ], o = Math.ceil(a / 8) * i, u = new Uint8Array(r * n * o);
  let c = 0;
  for (let f = 0; f < 7; f++) {
    const p = s[f], E = Math.ceil((n - p.x) / p.xStep), d = Math.ceil((r - p.y) / p.yStep);
    if (E <= 0 || d <= 0)
      continue;
    const A = E * o, v = new Uint8Array(A);
    for (let C = 0; C < d; C++) {
      const _ = t[c++], U = t.subarray(c, c + A);
      c += A;
      const B = new Uint8Array(A);
      Ax(_, U, B, v, A, o), v.set(B);
      for (let V = 0; V < E; V++) {
        const ie = p.x + V * p.xStep, K = p.y + C * p.yStep;
        if (!(ie >= n || K >= r))
          for (let fe = 0; fe < o; fe++)
            u[(K * n + ie) * o + fe] = B[V * o + fe];
      }
    }
  }
  if (a === 16) {
    const f = new Uint16Array(u.buffer);
    if (Nx)
      for (let p = 0; p < f.length; p++)
        f[p] = Sx(f[p]);
    return f;
  } else
    return u;
}
function Sx(e) {
  return (e & 255) << 8 | e >> 8 & 255;
}
const Lx = new Uint16Array([255]), kx = new Uint8Array(Lx.buffer), Cx = kx[0] === 255, Ix = new Uint8Array(0);
function bd(e) {
  const { data: t, width: n, height: r, channels: i, depth: a } = e, s = Math.ceil(a / 8) * i, o = Math.ceil(a / 8 * i * n), u = new Uint8Array(r * o);
  let c = Ix, f = 0, p, E;
  for (let d = 0; d < r; d++) {
    switch (p = t.subarray(f + 1, f + 1 + o), E = u.subarray(d * o, (d + 1) * o), t[f]) {
      case 0:
        Ep(p, E, o);
        break;
      case 1:
        yp(p, E, o, s);
        break;
      case 2:
        Tp(p, E, c, o);
        break;
      case 3:
        _p(p, E, c, o, s);
        break;
      case 4:
        Ap(p, E, c, o, s);
        break;
      default:
        throw new Error(`Unsupported filter: ${t[f]}`);
    }
    c = E, f += o + 1;
  }
  if (a === 16) {
    const d = new Uint16Array(u.buffer);
    if (Cx)
      for (let A = 0; A < d.length; A++)
        d[A] = Px(d[A]);
    return d;
  } else
    return u;
}
function Px(e) {
  return (e & 255) << 8 | e >> 8 & 255;
}
const xu = Uint8Array.of(137, 80, 78, 71, 13, 10, 26, 10);
function Ed(e) {
  if (!Ox(e.readBytes(xu.length)))
    throw new Error("wrong PNG signature");
}
function Ox(e) {
  if (e.length < xu.length)
    return !1;
  for (let t = 0; t < xu.length; t++)
    if (e[t] !== xu[t])
      return !1;
  return !0;
}
const Rx = "tEXt", Dx = 0, wp = new TextDecoder("latin1");
function Mx(e) {
  if (Bx(e), e.length === 0 || e.length > 79)
    throw new Error("keyword length must be between 1 and 79");
}
const Fx = /^[\u0000-\u00FF]*$/;
function Bx(e) {
  if (!Fx.test(e))
    throw new Error("invalid latin1 text");
}
function Ux(e, t, n) {
  const r = xp(t);
  e[r] = Hx(t, n - r.length - 1);
}
function xp(e) {
  for (e.mark(); e.readByte() !== Dx; )
    ;
  const t = e.offset;
  e.reset();
  const n = wp.decode(e.readBytes(t - e.offset - 1));
  return e.skip(1), Mx(n), n;
}
function Hx(e, t) {
  return wp.decode(e.readBytes(t));
}
const hr = {
  UNKNOWN: -1,
  GREYSCALE: 0,
  TRUECOLOUR: 2,
  INDEXED_COLOUR: 3,
  GREYSCALE_ALPHA: 4,
  TRUECOLOUR_ALPHA: 6
}, fc = {
  UNKNOWN: -1,
  DEFLATE: 0
}, yd = {
  UNKNOWN: -1,
  ADAPTIVE: 0
}, hc = {
  UNKNOWN: -1,
  NO_INTERLACE: 0,
  ADAM7: 1
}, gu = {
  NONE: 0,
  BACKGROUND: 1,
  PREVIOUS: 2
}, dc = {
  SOURCE: 0,
  OVER: 1
};
class jx extends Nf {
  constructor(n, r = {}) {
    super(n);
    jt(this, "_checkCrc");
    jt(this, "_inflator");
    jt(this, "_png");
    jt(this, "_apng");
    jt(this, "_end");
    jt(this, "_hasPalette");
    jt(this, "_palette");
    jt(this, "_hasTransparency");
    jt(this, "_transparency");
    jt(this, "_compressionMethod");
    jt(this, "_filterMethod");
    jt(this, "_interlaceMethod");
    jt(this, "_colorType");
    jt(this, "_isAnimated");
    jt(this, "_numberOfFrames");
    jt(this, "_numberOfPlays");
    jt(this, "_frames");
    jt(this, "_writingDataChunks");
    const { checkCrc: i = !1 } = r;
    this._checkCrc = i, this._inflator = new pd(), this._png = {
      width: -1,
      height: -1,
      channels: -1,
      data: new Uint8Array(0),
      depth: 1,
      text: {}
    }, this._apng = {
      width: -1,
      height: -1,
      channels: -1,
      depth: 1,
      numberOfFrames: 1,
      numberOfPlays: 0,
      text: {},
      frames: []
    }, this._end = !1, this._hasPalette = !1, this._palette = [], this._hasTransparency = !1, this._transparency = new Uint16Array(0), this._compressionMethod = fc.UNKNOWN, this._filterMethod = yd.UNKNOWN, this._interlaceMethod = hc.UNKNOWN, this._colorType = hr.UNKNOWN, this._isAnimated = !1, this._numberOfFrames = 1, this._numberOfPlays = 0, this._frames = [], this._writingDataChunks = !1, this.setBigEndian();
  }
  decode() {
    for (Ed(this); !this._end; ) {
      const n = this.readUint32(), r = this.readChars(4);
      this.decodeChunk(n, r);
    }
    return this.decodeImage(), this._png;
  }
  decodeApng() {
    for (Ed(this); !this._end; ) {
      const n = this.readUint32(), r = this.readChars(4);
      this.decodeApngChunk(n, r);
    }
    return this.decodeApngImage(), this._apng;
  }
  // https://www.w3.org/TR/PNG/#5Chunk-layout
  decodeChunk(n, r) {
    const i = this.offset;
    switch (r) {
      // 11.2 Critical chunks
      case "IHDR":
        this.decodeIHDR();
        break;
      case "PLTE":
        this.decodePLTE(n);
        break;
      case "IDAT":
        this.decodeIDAT(n);
        break;
      case "IEND":
        this._end = !0;
        break;
      // 11.3 Ancillary chunks
      case "tRNS":
        this.decodetRNS(n);
        break;
      case "iCCP":
        this.decodeiCCP(n);
        break;
      case Rx:
        Ux(this._png.text, this, n);
        break;
      case "pHYs":
        this.decodepHYs();
        break;
      default:
        this.skip(n);
        break;
    }
    if (this.offset - i !== n)
      throw new Error(`Length mismatch while decoding chunk ${r}`);
    this._checkCrc ? gd(this, n + 4, r) : this.skip(4);
  }
  decodeApngChunk(n, r) {
    const i = this.offset;
    switch (r !== "fdAT" && r !== "IDAT" && this._writingDataChunks && this.pushDataToFrame(), r) {
      case "acTL":
        this.decodeACTL();
        break;
      case "fcTL":
        this.decodeFCTL();
        break;
      case "fdAT":
        this.decodeFDAT(n);
        break;
      default:
        this.decodeChunk(n, r), this.offset = i + n;
        break;
    }
    if (this.offset - i !== n)
      throw new Error(`Length mismatch while decoding chunk ${r}`);
    this._checkCrc ? gd(this, n + 4, r) : this.skip(4);
  }
  // https://www.w3.org/TR/PNG/#11IHDR
  decodeIHDR() {
    const n = this._png;
    n.width = this.readUint32(), n.height = this.readUint32(), n.depth = qx(this.readUint8());
    const r = this.readUint8();
    this._colorType = r;
    let i;
    switch (r) {
      case hr.GREYSCALE:
        i = 1;
        break;
      case hr.TRUECOLOUR:
        i = 3;
        break;
      case hr.INDEXED_COLOUR:
        i = 1;
        break;
      case hr.GREYSCALE_ALPHA:
        i = 2;
        break;
      case hr.TRUECOLOUR_ALPHA:
        i = 4;
        break;
      // Kept for exhaustiveness.
      // eslint-disable-next-line unicorn/no-useless-switch-case
      case hr.UNKNOWN:
      default:
        throw new Error(`Unknown color type: ${r}`);
    }
    if (this._png.channels = i, this._compressionMethod = this.readUint8(), this._compressionMethod !== fc.DEFLATE)
      throw new Error(`Unsupported compression method: ${this._compressionMethod}`);
    this._filterMethod = this.readUint8(), this._interlaceMethod = this.readUint8();
  }
  decodeACTL() {
    this._numberOfFrames = this.readUint32(), this._numberOfPlays = this.readUint32(), this._isAnimated = !0;
  }
  decodeFCTL() {
    const n = {
      sequenceNumber: this.readUint32(),
      width: this.readUint32(),
      height: this.readUint32(),
      xOffset: this.readUint32(),
      yOffset: this.readUint32(),
      delayNumber: this.readUint16(),
      delayDenominator: this.readUint16(),
      disposeOp: this.readUint8(),
      blendOp: this.readUint8(),
      data: new Uint8Array(0)
    };
    this._frames.push(n);
  }
  // https://www.w3.org/TR/PNG/#11PLTE
  decodePLTE(n) {
    if (n % 3 !== 0)
      throw new RangeError(`PLTE field length must be a multiple of 3. Got ${n}`);
    const r = n / 3;
    this._hasPalette = !0;
    const i = [];
    this._palette = i;
    for (let a = 0; a < r; a++)
      i.push([this.readUint8(), this.readUint8(), this.readUint8()]);
  }
  // https://www.w3.org/TR/PNG/#11IDAT
  decodeIDAT(n) {
    this._writingDataChunks = !0;
    const r = n, i = this.offset + this.byteOffset;
    if (this._inflator.push(new Uint8Array(this.buffer, i, r)), this._inflator.err)
      throw new Error(`Error while decompressing the data: ${this._inflator.err}`);
    this.skip(n);
  }
  decodeFDAT(n) {
    this._writingDataChunks = !0;
    let r = n, i = this.offset + this.byteOffset;
    if (i += 4, r -= 4, this._inflator.push(new Uint8Array(this.buffer, i, r)), this._inflator.err)
      throw new Error(`Error while decompressing the data: ${this._inflator.err}`);
    this.skip(n);
  }
  // https://www.w3.org/TR/PNG/#11tRNS
  decodetRNS(n) {
    switch (this._colorType) {
      case hr.GREYSCALE:
      case hr.TRUECOLOUR: {
        if (n % 2 !== 0)
          throw new RangeError(`tRNS chunk length must be a multiple of 2. Got ${n}`);
        if (n / 2 > this._png.width * this._png.height)
          throw new Error(`tRNS chunk contains more alpha values than there are pixels (${n / 2} vs ${this._png.width * this._png.height})`);
        this._hasTransparency = !0, this._transparency = new Uint16Array(n / 2);
        for (let r = 0; r < n / 2; r++)
          this._transparency[r] = this.readUint16();
        break;
      }
      case hr.INDEXED_COLOUR: {
        if (n > this._palette.length)
          throw new Error(`tRNS chunk contains more alpha values than there are palette colors (${n} vs ${this._palette.length})`);
        let r = 0;
        for (; r < n; r++) {
          const i = this.readByte();
          this._palette[r].push(i);
        }
        for (; r < this._palette.length; r++)
          this._palette[r].push(255);
        break;
      }
      // Kept for exhaustiveness.
      /* eslint-disable unicorn/no-useless-switch-case */
      case hr.UNKNOWN:
      case hr.GREYSCALE_ALPHA:
      case hr.TRUECOLOUR_ALPHA:
      default:
        throw new Error(`tRNS chunk is not supported for color type ${this._colorType}`);
    }
  }
  // https://www.w3.org/TR/PNG/#11iCCP
  decodeiCCP(n) {
    const r = xp(this), i = this.readUint8();
    if (i !== fc.DEFLATE)
      throw new Error(`Unsupported iCCP compression method: ${i}`);
    const a = this.readBytes(n - r.length - 2);
    this._png.iccEmbeddedProfile = {
      name: r,
      profile: Ex(a)
    };
  }
  // https://www.w3.org/TR/PNG/#11pHYs
  decodepHYs() {
    const n = this.readUint32(), r = this.readUint32(), i = this.readByte();
    this._png.resolution = { x: n, y: r, unit: i };
  }
  decodeApngImage() {
    this._apng.width = this._png.width, this._apng.height = this._png.height, this._apng.channels = this._png.channels, this._apng.depth = this._png.depth, this._apng.numberOfFrames = this._numberOfFrames, this._apng.numberOfPlays = this._numberOfPlays, this._apng.text = this._png.text, this._apng.resolution = this._png.resolution;
    for (let n = 0; n < this._numberOfFrames; n++) {
      const r = {
        sequenceNumber: this._frames[n].sequenceNumber,
        delayNumber: this._frames[n].delayNumber,
        delayDenominator: this._frames[n].delayDenominator,
        data: this._apng.depth === 8 ? new Uint8Array(this._apng.width * this._apng.height * this._apng.channels) : new Uint16Array(this._apng.width * this._apng.height * this._apng.channels)
      }, i = this._frames.at(n);
      if (i) {
        if (i.data = bd({
          data: i.data,
          width: i.width,
          height: i.height,
          channels: this._apng.channels,
          depth: this._apng.depth
        }), this._hasPalette && (this._apng.palette = this._palette), this._hasTransparency && (this._apng.transparency = this._transparency), n === 0 || i.xOffset === 0 && i.yOffset === 0 && i.width === this._png.width && i.height === this._png.height)
          r.data = i.data;
        else {
          const a = this._apng.frames.at(n - 1);
          this.disposeFrame(i, a, r), this.addFrameDataToCanvas(r, i);
        }
        this._apng.frames.push(r);
      }
    }
    return this._apng;
  }
  disposeFrame(n, r, i) {
    switch (n.disposeOp) {
      case gu.NONE:
        break;
      case gu.BACKGROUND:
        for (let a = 0; a < this._png.height; a++)
          for (let s = 0; s < this._png.width; s++) {
            const o = (a * n.width + s) * this._png.channels;
            for (let u = 0; u < this._png.channels; u++)
              i.data[o + u] = 0;
          }
        break;
      case gu.PREVIOUS:
        i.data.set(r.data);
        break;
      default:
        throw new Error("Unknown disposeOp");
    }
  }
  addFrameDataToCanvas(n, r) {
    const i = 1 << this._png.depth, a = (s, o) => {
      const u = ((s + r.yOffset) * this._png.width + r.xOffset + o) * this._png.channels, c = (s * r.width + o) * this._png.channels;
      return { index: u, frameIndex: c };
    };
    switch (r.blendOp) {
      case dc.SOURCE:
        for (let s = 0; s < r.height; s++)
          for (let o = 0; o < r.width; o++) {
            const { index: u, frameIndex: c } = a(s, o);
            for (let f = 0; f < this._png.channels; f++)
              n.data[u + f] = r.data[c + f];
          }
        break;
      // https://www.w3.org/TR/png-3/#13Alpha-channel-processing
      case dc.OVER:
        for (let s = 0; s < r.height; s++)
          for (let o = 0; o < r.width; o++) {
            const { index: u, frameIndex: c } = a(s, o);
            for (let f = 0; f < this._png.channels; f++) {
              const p = r.data[c + this._png.channels - 1] / i, E = f % (this._png.channels - 1) === 0 ? 1 : r.data[c + f], d = Math.floor(p * E + (1 - p) * n.data[u + f]);
              n.data[u + f] += d;
            }
          }
        break;
      default:
        throw new Error("Unknown blendOp");
    }
  }
  decodeImage() {
    var r;
    if (this._inflator.err)
      throw new Error(`Error while decompressing the data: ${this._inflator.err}`);
    const n = this._isAnimated ? ((r = this._frames) == null ? void 0 : r.at(0)).data : this._inflator.result;
    if (this._filterMethod !== yd.ADAPTIVE)
      throw new Error(`Filter method ${this._filterMethod} not supported`);
    if (this._interlaceMethod === hc.NO_INTERLACE)
      this._png.data = bd({
        data: n,
        width: this._png.width,
        height: this._png.height,
        channels: this._png.channels,
        depth: this._png.depth
      });
    else if (this._interlaceMethod === hc.ADAM7)
      this._png.data = vx({
        data: n,
        width: this._png.width,
        height: this._png.height,
        channels: this._png.channels,
        depth: this._png.depth
      });
    else
      throw new Error(`Interlace method ${this._interlaceMethod} not supported`);
    this._hasPalette && (this._png.palette = this._palette), this._hasTransparency && (this._png.transparency = this._transparency);
  }
  pushDataToFrame() {
    const n = this._inflator.result, r = this._frames.at(-1);
    r ? r.data = n : this._frames.push({
      sequenceNumber: 0,
      width: this._png.width,
      height: this._png.height,
      xOffset: 0,
      yOffset: 0,
      delayNumber: 0,
      delayDenominator: 0,
      disposeOp: gu.NONE,
      blendOp: dc.SOURCE,
      data: n
    }), this._inflator = new pd(), this._writingDataChunks = !1;
  }
}
function qx(e) {
  if (e !== 1 && e !== 2 && e !== 4 && e !== 8 && e !== 16)
    throw new Error(`invalid bit depth: ${e}`);
  return e;
}
var Td;
(function(e) {
  e[e.UNKNOWN = 0] = "UNKNOWN", e[e.METRE = 1] = "METRE";
})(Td || (Td = {}));
function zx(e, t) {
  return new jx(e, t).decode();
}
/** @license
 *
 * jsPDF - PDF Document creation from JavaScript
 * Version 4.0.0 Built on 2025-12-18T10:27:09.425Z
 *                      CommitID 00000000
 *
 * Copyright (c) 2010-2025 James Hall <james@parall.ax>, https://github.com/MrRio/jsPDF
 *               2015-2025 yWorks GmbH, http://www.yworks.com
 *               2015-2025 Lukas HollÃ¤nder <lukas.hollaender@yworks.com>, https://github.com/HackbrettXXX
 *               2016-2018 Aras Abbasi <aras.abbasi@gmail.com>
 *               2010 Aaron Spike, https://github.com/acspike
 *               2012 Willow Systems Corporation, https://github.com/willowsystems
 *               2012 Pablo Hess, https://github.com/pablohess
 *               2012 Florian Jenett, https://github.com/fjenett
 *               2013 Warren Weckesser, https://github.com/warrenweckesser
 *               2013 Youssef Beddad, https://github.com/lifof
 *               2013 Lee Driscoll, https://github.com/lsdriscoll
 *               2013 Stefan Slonevskiy, https://github.com/stefslon
 *               2013 Jeremy Morel, https://github.com/jmorel
 *               2013 Christoph Hartmann, https://github.com/chris-rock
 *               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria
 *               2014 James Makes, https://github.com/dollaruw
 *               2014 Diego Casorran, https://github.com/diegocr
 *               2014 Steven Spungin, https://github.com/Flamenco
 *               2014 Kenneth Glassey, https://github.com/Gavvers
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Contributor(s):
 *    siefkenj, ahwolf, rickygu, Midnith, saintclair, eaparango,
 *    kim3er, mfo, alnorth, Flamenco
 */
var ct = /* @__PURE__ */ (function() {
  return typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : this;
})();
function pc() {
  ct.console && typeof ct.console.log == "function" && ct.console.log.apply(ct.console, arguments);
}
var Wt = { log: pc, warn: function(e) {
  ct.console && (typeof ct.console.warn == "function" ? ct.console.warn.apply(ct.console, arguments) : pc.call(null, arguments));
}, error: function(e) {
  ct.console && (typeof ct.console.error == "function" ? ct.console.error.apply(ct.console, arguments) : pc(e));
} };
function mc(e, t, n) {
  var r = new XMLHttpRequest();
  r.open("GET", e), r.responseType = "blob", r.onload = function() {
    _a(r.response, t, n);
  }, r.onerror = function() {
    Wt.error("could not download file");
  }, r.send();
}
function _d(e) {
  var t = new XMLHttpRequest();
  t.open("HEAD", e, !1);
  try {
    t.send();
  } catch {
  }
  return t.status >= 200 && t.status <= 299;
}
function bu(e) {
  try {
    e.dispatchEvent(new MouseEvent("click"));
  } catch {
    var t = document.createEvent("MouseEvents");
    t.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), e.dispatchEvent(t);
  }
}
var _a = ct.saveAs || ((typeof window > "u" ? "undefined" : qt(window)) !== "object" || window !== ct ? function() {
} : typeof HTMLAnchorElement < "u" && "download" in HTMLAnchorElement.prototype ? function(e, t, n) {
  var r = ct.URL || ct.webkitURL, i = document.createElement("a");
  t = t || e.name || "download", i.download = t, i.rel = "noopener", typeof e == "string" ? (i.href = e, i.origin !== location.origin ? _d(i.href) ? mc(e, t, n) : bu(i, i.target = "_blank") : bu(i)) : (i.href = r.createObjectURL(e), setTimeout(function() {
    r.revokeObjectURL(i.href);
  }, 4e4), setTimeout(function() {
    bu(i);
  }, 0));
} : "msSaveOrOpenBlob" in navigator ? function(e, t, n) {
  if (t = t || e.name || "download", typeof e == "string") if (_d(e)) mc(e, t, n);
  else {
    var r = document.createElement("a");
    r.href = e, r.target = "_blank", setTimeout(function() {
      bu(r);
    });
  }
  else navigator.msSaveOrOpenBlob((function(i, a) {
    return a === void 0 ? a = { autoBom: !1 } : qt(a) !== "object" && (Wt.warn("Deprecated: Expected third argument to be a object"), a = { autoBom: !a }), a.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(i.type) ? new Blob(["\uFEFF", i], { type: i.type }) : i;
  })(e, n), t);
} : function(e, t, n, r) {
  if ((r = r || open("", "_blank")) && (r.document.title = r.document.body.innerText = "downloading..."), typeof e == "string") return mc(e, t, n);
  var i = e.type === "application/octet-stream", a = /constructor/i.test(ct.HTMLElement) || ct.safari, s = /CriOS\/[\d]+/.test(navigator.userAgent);
  if ((s || i && a) && (typeof FileReader > "u" ? "undefined" : qt(FileReader)) === "object") {
    var o = new FileReader();
    o.onloadend = function() {
      var f = o.result;
      f = s ? f : f.replace(/^data:[^;]*;/, "data:attachment/file;"), r ? r.location.href = f : location = f, r = null;
    }, o.readAsDataURL(e);
  } else {
    var u = ct.URL || ct.webkitURL, c = u.createObjectURL(e);
    r ? r.location = c : location.href = c, r = null, setTimeout(function() {
      u.revokeObjectURL(c);
    }, 4e4);
  }
});
/**
 * A class to parse color values
 * @author Stoyan Stefanov <sstoo@gmail.com>
 * {@link   http://www.phpied.com/rgb-color-parser-in-javascript/}
 * @license Use it if you like it
 */
function Np(e) {
  var t;
  e = e || "", this.ok = !1, e.charAt(0) == "#" && (e = e.substr(1, 6)), e = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "00ffff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000000", blanchedalmond: "ffebcd", blue: "0000ff", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "00ffff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dodgerblue: "1e90ff", feldspar: "d19275", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "ff00ff", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgrey: "d3d3d3", lightgreen: "90ee90", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslateblue: "8470ff", lightslategray: "778899", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "00ff00", limegreen: "32cd32", linen: "faf0e6", magenta: "ff00ff", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370d8", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "d87093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", red: "ff0000", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", violetred: "d02090", wheat: "f5deb3", white: "ffffff", whitesmoke: "f5f5f5", yellow: "ffff00", yellowgreen: "9acd32" }[e = (e = e.replace(/ /g, "")).toLowerCase()] || e;
  for (var n = [{ re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/, example: ["rgb(123, 234, 45)", "rgb(255,234,245)"], process: function(o) {
    return [parseInt(o[1]), parseInt(o[2]), parseInt(o[3])];
  } }, { re: /^(\w{2})(\w{2})(\w{2})$/, example: ["#00ff00", "336699"], process: function(o) {
    return [parseInt(o[1], 16), parseInt(o[2], 16), parseInt(o[3], 16)];
  } }, { re: /^(\w{1})(\w{1})(\w{1})$/, example: ["#fb0", "f0f"], process: function(o) {
    return [parseInt(o[1] + o[1], 16), parseInt(o[2] + o[2], 16), parseInt(o[3] + o[3], 16)];
  } }], r = 0; r < n.length; r++) {
    var i = n[r].re, a = n[r].process, s = i.exec(e);
    s && (t = a(s), this.r = t[0], this.g = t[1], this.b = t[2], this.ok = !0);
  }
  this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r, this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g, this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b, this.toRGB = function() {
    return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
  }, this.toHex = function() {
    var o = this.r.toString(16), u = this.g.toString(16), c = this.b.toString(16);
    return o.length == 1 && (o = "0" + o), u.length == 1 && (u = "0" + u), c.length == 1 && (c = "0" + c), "#" + o + u + c;
  };
}
var Nu = ct.atob.bind(ct), Ad = ct.btoa.bind(ct);
/**
 * @license
 * Joseph Myers does not specify a particular license for his work.
 *
 * Author: Joseph Myers
 * Accessed from: http://www.myersdaily.org/joseph/javascript/md5.js
 *
 * Modified by: Owen Leong
 */
function gc(e, t) {
  var n = e[0], r = e[1], i = e[2], a = e[3];
  n = Bn(n, r, i, a, t[0], 7, -680876936), a = Bn(a, n, r, i, t[1], 12, -389564586), i = Bn(i, a, n, r, t[2], 17, 606105819), r = Bn(r, i, a, n, t[3], 22, -1044525330), n = Bn(n, r, i, a, t[4], 7, -176418897), a = Bn(a, n, r, i, t[5], 12, 1200080426), i = Bn(i, a, n, r, t[6], 17, -1473231341), r = Bn(r, i, a, n, t[7], 22, -45705983), n = Bn(n, r, i, a, t[8], 7, 1770035416), a = Bn(a, n, r, i, t[9], 12, -1958414417), i = Bn(i, a, n, r, t[10], 17, -42063), r = Bn(r, i, a, n, t[11], 22, -1990404162), n = Bn(n, r, i, a, t[12], 7, 1804603682), a = Bn(a, n, r, i, t[13], 12, -40341101), i = Bn(i, a, n, r, t[14], 17, -1502002290), n = Un(n, r = Bn(r, i, a, n, t[15], 22, 1236535329), i, a, t[1], 5, -165796510), a = Un(a, n, r, i, t[6], 9, -1069501632), i = Un(i, a, n, r, t[11], 14, 643717713), r = Un(r, i, a, n, t[0], 20, -373897302), n = Un(n, r, i, a, t[5], 5, -701558691), a = Un(a, n, r, i, t[10], 9, 38016083), i = Un(i, a, n, r, t[15], 14, -660478335), r = Un(r, i, a, n, t[4], 20, -405537848), n = Un(n, r, i, a, t[9], 5, 568446438), a = Un(a, n, r, i, t[14], 9, -1019803690), i = Un(i, a, n, r, t[3], 14, -187363961), r = Un(r, i, a, n, t[8], 20, 1163531501), n = Un(n, r, i, a, t[13], 5, -1444681467), a = Un(a, n, r, i, t[2], 9, -51403784), i = Un(i, a, n, r, t[7], 14, 1735328473), n = Hn(n, r = Un(r, i, a, n, t[12], 20, -1926607734), i, a, t[5], 4, -378558), a = Hn(a, n, r, i, t[8], 11, -2022574463), i = Hn(i, a, n, r, t[11], 16, 1839030562), r = Hn(r, i, a, n, t[14], 23, -35309556), n = Hn(n, r, i, a, t[1], 4, -1530992060), a = Hn(a, n, r, i, t[4], 11, 1272893353), i = Hn(i, a, n, r, t[7], 16, -155497632), r = Hn(r, i, a, n, t[10], 23, -1094730640), n = Hn(n, r, i, a, t[13], 4, 681279174), a = Hn(a, n, r, i, t[0], 11, -358537222), i = Hn(i, a, n, r, t[3], 16, -722521979), r = Hn(r, i, a, n, t[6], 23, 76029189), n = Hn(n, r, i, a, t[9], 4, -640364487), a = Hn(a, n, r, i, t[12], 11, -421815835), i = Hn(i, a, n, r, t[15], 16, 530742520), n = jn(n, r = Hn(r, i, a, n, t[2], 23, -995338651), i, a, t[0], 6, -198630844), a = jn(a, n, r, i, t[7], 10, 1126891415), i = jn(i, a, n, r, t[14], 15, -1416354905), r = jn(r, i, a, n, t[5], 21, -57434055), n = jn(n, r, i, a, t[12], 6, 1700485571), a = jn(a, n, r, i, t[3], 10, -1894986606), i = jn(i, a, n, r, t[10], 15, -1051523), r = jn(r, i, a, n, t[1], 21, -2054922799), n = jn(n, r, i, a, t[8], 6, 1873313359), a = jn(a, n, r, i, t[15], 10, -30611744), i = jn(i, a, n, r, t[6], 15, -1560198380), r = jn(r, i, a, n, t[13], 21, 1309151649), n = jn(n, r, i, a, t[4], 6, -145523070), a = jn(a, n, r, i, t[11], 10, -1120210379), i = jn(i, a, n, r, t[2], 15, 718787259), r = jn(r, i, a, n, t[9], 21, -343485551), e[0] = Qi(n, e[0]), e[1] = Qi(r, e[1]), e[2] = Qi(i, e[2]), e[3] = Qi(a, e[3]);
}
function nl(e, t, n, r, i, a) {
  return t = Qi(Qi(t, e), Qi(r, a)), Qi(t << i | t >>> 32 - i, n);
}
function Bn(e, t, n, r, i, a, s) {
  return nl(t & n | ~t & r, e, t, i, a, s);
}
function Un(e, t, n, r, i, a, s) {
  return nl(t & r | n & ~r, e, t, i, a, s);
}
function Hn(e, t, n, r, i, a, s) {
  return nl(t ^ n ^ r, e, t, i, a, s);
}
function jn(e, t, n, r, i, a, s) {
  return nl(n ^ (t | ~r), e, t, i, a, s);
}
function vp(e) {
  var t, n = e.length, r = [1732584193, -271733879, -1732584194, 271733878];
  for (t = 64; t <= e.length; t += 64) gc(r, Yx(e.substring(t - 64, t)));
  e = e.substring(t - 64);
  var i = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  for (t = 0; t < e.length; t++) i[t >> 2] |= e.charCodeAt(t) << (t % 4 << 3);
  if (i[t >> 2] |= 128 << (t % 4 << 3), t > 55) for (gc(r, i), t = 0; t < 16; t++) i[t] = 0;
  return i[14] = 8 * n, gc(r, i), r;
}
function Yx(e) {
  var t, n = [];
  for (t = 0; t < 64; t += 4) n[t >> 2] = e.charCodeAt(t) + (e.charCodeAt(t + 1) << 8) + (e.charCodeAt(t + 2) << 16) + (e.charCodeAt(t + 3) << 24);
  return n;
}
var wd = "0123456789abcdef".split("");
function Wx(e) {
  for (var t = "", n = 0; n < 4; n++) t += wd[e >> 8 * n + 4 & 15] + wd[e >> 8 * n & 15];
  return t;
}
function Vx(e) {
  return String.fromCharCode(255 & e, (65280 & e) >> 8, (16711680 & e) >> 16, (4278190080 & e) >> 24);
}
function Vc(e) {
  return vp(e).map(Vx).join("");
}
var Gx = (function(e) {
  for (var t = 0; t < e.length; t++) e[t] = Wx(e[t]);
  return e.join("");
})(vp("hello")) != "5d41402abc4b2a76b9719d911017c592";
function Qi(e, t) {
  if (Gx) {
    var n = (65535 & e) + (65535 & t);
    return (e >> 16) + (t >> 16) + (n >> 16) << 16 | 65535 & n;
  }
  return e + t & 4294967295;
}
/**
 * @license
 * FPDF is released under a permissive license: there is no usage restriction.
 * You may embed it freely in your application (commercial or not), with or
 * without modifications.
 *
 * Reference: http://www.fpdf.org/en/script/script37.php
 */
function Gc(e, t) {
  var n, r, i, a;
  if (e !== n) {
    for (var s = (i = e, a = 1 + (256 / e.length | 0), new Array(a + 1).join(i)), o = [], u = 0; u < 256; u++) o[u] = u;
    var c = 0;
    for (u = 0; u < 256; u++) {
      var f = o[u];
      c = (c + f + s.charCodeAt(u)) % 256, o[u] = o[c], o[c] = f;
    }
    n = e, r = o;
  } else o = r;
  var p = t.length, E = 0, d = 0, A = "";
  for (u = 0; u < p; u++) d = (d + (f = o[E = (E + 1) % 256])) % 256, o[E] = o[d], o[d] = f, s = o[(o[E] + o[d]) % 256], A += String.fromCharCode(t.charCodeAt(u) ^ s);
  return A;
}
/**
 * @license
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 * Author: Owen Leong (@owenl131)
 * Date: 15 Oct 2020
 * References:
 * https://www.cs.cmu.edu/~dst/Adobe/Gallery/anon21jul01-pdf-encryption.txt
 * https://github.com/foliojs/pdfkit/blob/master/lib/security.js
 * http://www.fpdf.org/en/script/script37.php
 */
var xd = { print: 4, modify: 8, copy: 16, "annot-forms": 32 };
function es(e, t, n, r) {
  this.v = 1, this.r = 2;
  var i = 192;
  e.forEach(function(o) {
    if (xd.perm !== void 0) throw new Error("Invalid permission: " + o);
    i += xd[o];
  }), this.padding = "(Â¿N^NuÂŠAd\0NVÃ¿Ãº\b..\0Â¶Ãh>Â€/\fÂ©Ã¾dSiz";
  var a = (t + this.padding).substr(0, 32), s = (n + this.padding).substr(0, 32);
  this.O = this.processOwnerPassword(a, s), this.P = -(1 + (255 ^ i)), this.encryptionKey = Vc(a + this.O + this.lsbFirstWord(this.P) + this.hexToBytes(r)).substr(0, 5), this.U = Gc(this.encryptionKey, this.padding);
}
function ts(e) {
  if (/[^\u0000-\u00ff]/.test(e)) throw new Error("Invalid PDF Name Object: " + e + ", Only accept ASCII characters.");
  for (var t = "", n = e.length, r = 0; r < n; r++) {
    var i = e.charCodeAt(r);
    t += i < 33 || i === 35 || i === 37 || i === 40 || i === 41 || i === 47 || i === 60 || i === 62 || i === 91 || i === 93 || i === 123 || i === 125 || i > 126 ? "#" + ("0" + i.toString(16)).slice(-2) : e[r];
  }
  return t;
}
function Nd(e) {
  if (qt(e) !== "object") throw new Error("Invalid Context passed to initialize PubSub (jsPDF-module)");
  var t = {};
  this.subscribe = function(n, r, i) {
    if (i = i || !1, typeof n != "string" || typeof r != "function" || typeof i != "boolean") throw new Error("Invalid arguments passed to PubSub.subscribe (jsPDF-module)");
    t.hasOwnProperty(n) || (t[n] = {});
    var a = Math.random().toString(35);
    return t[n][a] = [r, !!i], a;
  }, this.unsubscribe = function(n) {
    for (var r in t) if (t[r][n]) return delete t[r][n], Object.keys(t[r]).length === 0 && delete t[r], !0;
    return !1;
  }, this.publish = function(n) {
    if (t.hasOwnProperty(n)) {
      var r = Array.prototype.slice.call(arguments, 1), i = [];
      for (var a in t[n]) {
        var s = t[n][a];
        try {
          s[0].apply(e, r);
        } catch (o) {
          ct.console && Wt.error("jsPDF PubSub Error", o.message, o);
        }
        s[1] && i.push(a);
      }
      i.length && i.forEach(this.unsubscribe);
    }
  }, this.getTopics = function() {
    return t;
  };
}
function Hu(e) {
  if (!(this instanceof Hu)) return new Hu(e);
  var t = "opacity,stroke-opacity".split(",");
  for (var n in e) e.hasOwnProperty(n) && t.indexOf(n) >= 0 && (this[n] = e[n]);
  this.id = "", this.objectNumber = -1;
}
function Sp(e, t) {
  this.gState = e, this.matrix = t, this.id = "", this.objectNumber = -1;
}
function Aa(e, t, n, r, i) {
  if (!(this instanceof Aa)) return new Aa(e, t, n, r, i);
  this.type = e === "axial" ? 2 : 3, this.coords = t, this.colors = n, Sp.call(this, r, i);
}
function rs(e, t, n, r, i) {
  if (!(this instanceof rs)) return new rs(e, t, n, r, i);
  this.boundingBox = e, this.xStep = t, this.yStep = n, this.stream = "", this.cloneIndex = 0, Sp.call(this, r, i);
}
function et(e) {
  var t, n = typeof arguments[0] == "string" ? arguments[0] : "p", r = arguments[1], i = arguments[2], a = arguments[3], s = [], o = 1, u = 16, c = "S", f = null;
  qt(e = e || {}) === "object" && (n = e.orientation, r = e.unit || r, i = e.format || i, a = e.compress || e.compressPdf || a, (f = e.encryption || null) !== null && (f.userPassword = f.userPassword || "", f.ownerPassword = f.ownerPassword || "", f.userPermissions = f.userPermissions || []), o = typeof e.userUnit == "number" ? Math.abs(e.userUnit) : 1, e.precision !== void 0 && (t = e.precision), e.floatPrecision !== void 0 && (u = e.floatPrecision), c = e.defaultPathOperation || "S"), s = e.filters || (a === !0 ? ["FlateEncode"] : s), r = r || "mm", n = ("" + (n || "P")).toLowerCase();
  var p = e.putOnlyUsedFonts || !1, E = {}, d = { internal: {}, __private__: {} };
  d.__private__.PubSub = Nd;
  var A = "1.3", v = d.__private__.getPdfVersion = function() {
    return A;
  };
  d.__private__.setPdfVersion = function(g) {
    A = g;
  };
  var C = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
  d.__private__.getPageFormats = function() {
    return C;
  };
  var _ = d.__private__.getPageFormat = function(g) {
    return C[g];
  };
  i = i || "a4";
  var U = "compat", B = "advanced", V = U;
  function ie() {
    this.saveGraphicsState(), F(new ut(qe, 0, 0, -qe, 0, ca() * qe).toString() + " cm"), this.setFontSize(this.getFontSize() / qe), c = "n", V = B;
  }
  function K() {
    this.restoreGraphicsState(), c = "S", V = U;
  }
  var fe = d.__private__.combineFontStyleAndFontWeight = function(g, w) {
    if (g == "bold" && w == "normal" || g == "bold" && w == 400 || g == "normal" && w == "italic" || g == "bold" && w == "italic") throw new Error("Invalid Combination of fontweight and fontstyle");
    return w && (g = w == 400 || w === "normal" ? g === "italic" ? "italic" : "normal" : w != 700 && w !== "bold" || g !== "normal" ? (w == 700 ? "bold" : w) + "" + g : "bold"), g;
  };
  d.advancedAPI = function(g) {
    var w = V === U;
    return w && ie.call(this), typeof g != "function" || (g(this), w && K.call(this)), this;
  }, d.compatAPI = function(g) {
    var w = V === B;
    return w && K.call(this), typeof g != "function" || (g(this), w && ie.call(this)), this;
  }, d.isAdvancedAPI = function() {
    return V === B;
  };
  var Z, z = function(g) {
    if (V !== B) throw new Error(g + " is only available in 'advanced' API mode. You need to call advancedAPI() first.");
  }, D = d.roundToPrecision = d.__private__.roundToPrecision = function(g, w) {
    var q = t || w;
    if (isNaN(g) || isNaN(q)) throw new Error("Invalid argument passed to jsPDF.roundToPrecision");
    return g.toFixed(q).replace(/0+$/, "");
  };
  Z = d.hpf = d.__private__.hpf = typeof u == "number" ? function(g) {
    if (isNaN(g)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return D(g, u);
  } : u === "smart" ? function(g) {
    if (isNaN(g)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return D(g, g > -1 && g < 1 ? 16 : 5);
  } : function(g) {
    if (isNaN(g)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return D(g, 16);
  };
  var N = d.f2 = d.__private__.f2 = function(g) {
    if (isNaN(g)) throw new Error("Invalid argument passed to jsPDF.f2");
    return D(g, 2);
  }, I = d.__private__.f3 = function(g) {
    if (isNaN(g)) throw new Error("Invalid argument passed to jsPDF.f3");
    return D(g, 3);
  }, $ = d.scale = d.__private__.scale = function(g) {
    if (isNaN(g)) throw new Error("Invalid argument passed to jsPDF.scale");
    return V === U ? g * qe : V === B ? g : void 0;
  }, Y = function(g) {
    return $((function(w) {
      return V === U ? ca() - w : V === B ? w : void 0;
    })(g));
  };
  d.__private__.setPrecision = d.setPrecision = function(g) {
    typeof parseInt(g, 10) == "number" && (t = parseInt(g, 10));
  };
  var J, ue = "00000000000000000000000000000000", me = d.__private__.getFileId = function() {
    return ue;
  }, se = d.__private__.setFileId = function(g) {
    return ue = g !== void 0 && /^[a-fA-F0-9]{32}$/.test(g) ? g.toUpperCase() : ue.split("").map(function() {
      return "ABCDEF0123456789".charAt(Math.floor(16 * Math.random()));
    }).join(""), f !== null && (yn = new es(f.userPermissions, f.userPassword, f.ownerPassword, ue)), ue;
  };
  d.setFileId = function(g) {
    return se(g), this;
  }, d.getFileId = function() {
    return me();
  };
  var Ee = d.__private__.convertDateToPDFDate = function(g) {
    var w = g.getTimezoneOffset(), q = w < 0 ? "+" : "-", Q = Math.floor(Math.abs(w / 60)), ae = Math.abs(w % 60), we = [q, G(Q), "'", G(ae), "'"].join("");
    return ["D:", g.getFullYear(), G(g.getMonth() + 1), G(g.getDate()), G(g.getHours()), G(g.getMinutes()), G(g.getSeconds()), we].join("");
  }, M = d.__private__.convertPDFDateToDate = function(g) {
    var w = parseInt(g.substr(2, 4), 10), q = parseInt(g.substr(6, 2), 10) - 1, Q = parseInt(g.substr(8, 2), 10), ae = parseInt(g.substr(10, 2), 10), we = parseInt(g.substr(12, 2), 10), Se = parseInt(g.substr(14, 2), 10);
    return new Date(w, q, Q, ae, we, Se, 0);
  }, xe = d.__private__.setCreationDate = function(g) {
    var w;
    if (g === void 0 && (g = /* @__PURE__ */ new Date()), g instanceof Date) w = Ee(g);
    else {
      if (!/^D:(20[0-2][0-9]|203[0-7]|19[7-9][0-9])(0[0-9]|1[0-2])([0-2][0-9]|3[0-1])(0[0-9]|1[0-9]|2[0-3])(0[0-9]|[1-5][0-9])(0[0-9]|[1-5][0-9])(\+0[0-9]|\+1[0-4]|-0[0-9]|-1[0-1])'(0[0-9]|[1-5][0-9])'?$/.test(g)) throw new Error("Invalid argument passed to jsPDF.setCreationDate");
      w = g;
    }
    return J = w;
  }, L = d.__private__.getCreationDate = function(g) {
    var w = J;
    return g === "jsDate" && (w = M(J)), w;
  };
  d.setCreationDate = function(g) {
    return xe(g), this;
  }, d.getCreationDate = function(g) {
    return L(g);
  };
  var T, G = d.__private__.padd2 = function(g) {
    return ("0" + parseInt(g)).slice(-2);
  }, ee = d.__private__.padd2Hex = function(g) {
    return ("00" + (g = g.toString())).substr(g.length);
  }, te = 0, le = [], ge = [], be = 0, Ae = [], Ie = [], je = !1, He = ge;
  d.__private__.setCustomOutputDestination = function(g) {
    je = !0, He = g;
  };
  var tt = function(g) {
    je || (He = g);
  };
  d.__private__.resetCustomOutputDestination = function() {
    je = !1, He = ge;
  };
  var F = d.__private__.out = function(g) {
    return g = g.toString(), be += g.length + 1, He.push(g), He;
  }, Ue = d.__private__.write = function(g) {
    return F(arguments.length === 1 ? g.toString() : Array.prototype.join.call(arguments, " "));
  }, gt = d.__private__.getArrayBuffer = function(g) {
    for (var w = g.length, q = new ArrayBuffer(w), Q = new Uint8Array(q); w--; ) Q[w] = g.charCodeAt(w);
    return q;
  }, at = [["Helvetica", "helvetica", "normal", "WinAnsiEncoding"], ["Helvetica-Bold", "helvetica", "bold", "WinAnsiEncoding"], ["Helvetica-Oblique", "helvetica", "italic", "WinAnsiEncoding"], ["Helvetica-BoldOblique", "helvetica", "bolditalic", "WinAnsiEncoding"], ["Courier", "courier", "normal", "WinAnsiEncoding"], ["Courier-Bold", "courier", "bold", "WinAnsiEncoding"], ["Courier-Oblique", "courier", "italic", "WinAnsiEncoding"], ["Courier-BoldOblique", "courier", "bolditalic", "WinAnsiEncoding"], ["Times-Roman", "times", "normal", "WinAnsiEncoding"], ["Times-Bold", "times", "bold", "WinAnsiEncoding"], ["Times-Italic", "times", "italic", "WinAnsiEncoding"], ["Times-BoldItalic", "times", "bolditalic", "WinAnsiEncoding"], ["ZapfDingbats", "zapfdingbats", "normal", null], ["Symbol", "symbol", "normal", null]];
  d.__private__.getStandardFonts = function() {
    return at;
  };
  var ke = e.fontSize || 16;
  d.__private__.setFontSize = d.setFontSize = function(g) {
    return ke = V === B ? g / qe : g, this;
  };
  var rt, Ye = d.__private__.getFontSize = d.getFontSize = function() {
    return V === U ? ke : ke * qe;
  }, it = e.R2L || !1;
  d.__private__.setR2L = d.setR2L = function(g) {
    return it = g, this;
  }, d.__private__.getR2L = d.getR2L = function() {
    return it;
  };
  var nt, Dt = d.__private__.setZoomMode = function(g) {
    if (/^(?:\d+\.\d*|\d*\.\d+|\d+)%$/.test(g)) rt = g;
    else if (isNaN(g)) {
      if ([void 0, null, "fullwidth", "fullheight", "fullpage", "original"].indexOf(g) === -1) throw new Error('zoom must be Integer (e.g. 2), a percentage Value (e.g. 300%) or fullwidth, fullheight, fullpage, original. "' + g + '" is not recognized.');
      rt = g;
    } else rt = parseInt(g, 10);
  };
  d.__private__.getZoomMode = function() {
    return rt;
  };
  var xt, he = d.__private__.setPageMode = function(g) {
    if ([void 0, null, "UseNone", "UseOutlines", "UseThumbs", "FullScreen"].indexOf(g) == -1) throw new Error('Page mode must be one of UseNone, UseOutlines, UseThumbs, or FullScreen. "' + g + '" is not recognized.');
    nt = g;
  };
  d.__private__.getPageMode = function() {
    return nt;
  };
  var ve = d.__private__.setLayoutMode = function(g) {
    if ([void 0, null, "continuous", "single", "twoleft", "tworight", "two"].indexOf(g) == -1) throw new Error('Layout mode must be one of continuous, single, twoleft, tworight. "' + g + '" is not recognized.');
    xt = g;
  };
  d.__private__.getLayoutMode = function() {
    return xt;
  }, d.__private__.setDisplayMode = d.setDisplayMode = function(g, w, q) {
    return Dt(g), ve(w), he(q), this;
  };
  var Fe = { title: "", subject: "", author: "", keywords: "", creator: "" };
  d.__private__.getDocumentProperty = function(g) {
    if (Object.keys(Fe).indexOf(g) === -1) throw new Error("Invalid argument passed to jsPDF.getDocumentProperty");
    return Fe[g];
  }, d.__private__.getDocumentProperties = function() {
    return Fe;
  }, d.__private__.setDocumentProperties = d.setProperties = d.setDocumentProperties = function(g) {
    for (var w in Fe) Fe.hasOwnProperty(w) && g[w] && (Fe[w] = g[w]);
    return this;
  }, d.__private__.setDocumentProperty = function(g, w) {
    if (Object.keys(Fe).indexOf(g) === -1) throw new Error("Invalid arguments passed to jsPDF.setDocumentProperty");
    return Fe[g] = w;
  };
  var Re, qe, ze, Bt, bt, ht = {}, dt = {}, Nt = [], Qe = {}, kt = {}, lt = {}, Et = {}, Jt = null, vt = 0, ot = [], Mt = new Nd(d), na = e.hotfixes || [], Mn = {}, ai = {}, qr = [], ut = function g(w, q, Q, ae, we, Se) {
    if (!(this instanceof g)) return new g(w, q, Q, ae, we, Se);
    isNaN(w) && (w = 1), isNaN(q) && (q = 0), isNaN(Q) && (Q = 0), isNaN(ae) && (ae = 1), isNaN(we) && (we = 0), isNaN(Se) && (Se = 0), this._matrix = [w, q, Q, ae, we, Se];
  };
  Object.defineProperty(ut.prototype, "sx", { get: function() {
    return this._matrix[0];
  }, set: function(g) {
    this._matrix[0] = g;
  } }), Object.defineProperty(ut.prototype, "shy", { get: function() {
    return this._matrix[1];
  }, set: function(g) {
    this._matrix[1] = g;
  } }), Object.defineProperty(ut.prototype, "shx", { get: function() {
    return this._matrix[2];
  }, set: function(g) {
    this._matrix[2] = g;
  } }), Object.defineProperty(ut.prototype, "sy", { get: function() {
    return this._matrix[3];
  }, set: function(g) {
    this._matrix[3] = g;
  } }), Object.defineProperty(ut.prototype, "tx", { get: function() {
    return this._matrix[4];
  }, set: function(g) {
    this._matrix[4] = g;
  } }), Object.defineProperty(ut.prototype, "ty", { get: function() {
    return this._matrix[5];
  }, set: function(g) {
    this._matrix[5] = g;
  } }), Object.defineProperty(ut.prototype, "a", { get: function() {
    return this._matrix[0];
  }, set: function(g) {
    this._matrix[0] = g;
  } }), Object.defineProperty(ut.prototype, "b", { get: function() {
    return this._matrix[1];
  }, set: function(g) {
    this._matrix[1] = g;
  } }), Object.defineProperty(ut.prototype, "c", { get: function() {
    return this._matrix[2];
  }, set: function(g) {
    this._matrix[2] = g;
  } }), Object.defineProperty(ut.prototype, "d", { get: function() {
    return this._matrix[3];
  }, set: function(g) {
    this._matrix[3] = g;
  } }), Object.defineProperty(ut.prototype, "e", { get: function() {
    return this._matrix[4];
  }, set: function(g) {
    this._matrix[4] = g;
  } }), Object.defineProperty(ut.prototype, "f", { get: function() {
    return this._matrix[5];
  }, set: function(g) {
    this._matrix[5] = g;
  } }), Object.defineProperty(ut.prototype, "rotation", { get: function() {
    return Math.atan2(this.shx, this.sx);
  } }), Object.defineProperty(ut.prototype, "scaleX", { get: function() {
    return this.decompose().scale.sx;
  } }), Object.defineProperty(ut.prototype, "scaleY", { get: function() {
    return this.decompose().scale.sy;
  } }), Object.defineProperty(ut.prototype, "isIdentity", { get: function() {
    return this.sx === 1 && this.shy === 0 && this.shx === 0 && this.sy === 1 && this.tx === 0 && this.ty === 0;
  } }), ut.prototype.join = function(g) {
    return [this.sx, this.shy, this.shx, this.sy, this.tx, this.ty].map(Z).join(g);
  }, ut.prototype.multiply = function(g) {
    var w = g.sx * this.sx + g.shy * this.shx, q = g.sx * this.shy + g.shy * this.sy, Q = g.shx * this.sx + g.sy * this.shx, ae = g.shx * this.shy + g.sy * this.sy, we = g.tx * this.sx + g.ty * this.shx + this.tx, Se = g.tx * this.shy + g.ty * this.sy + this.ty;
    return new ut(w, q, Q, ae, we, Se);
  }, ut.prototype.decompose = function() {
    var g = this.sx, w = this.shy, q = this.shx, Q = this.sy, ae = this.tx, we = this.ty, Se = Math.sqrt(g * g + w * w), Ge = (g /= Se) * q + (w /= Se) * Q;
    q -= g * Ge, Q -= w * Ge;
    var Je = Math.sqrt(q * q + Q * Q);
    return Ge /= Je, g * (Q /= Je) < w * (q /= Je) && (g = -g, w = -w, Ge = -Ge, Se = -Se), { scale: new ut(Se, 0, 0, Je, 0, 0), translate: new ut(1, 0, 0, 1, ae, we), rotate: new ut(g, w, -w, g, 0, 0), skew: new ut(1, 0, Ge, 1, 0, 0) };
  }, ut.prototype.toString = function(g) {
    return this.join(" ");
  }, ut.prototype.inversed = function() {
    var g = this.sx, w = this.shy, q = this.shx, Q = this.sy, ae = this.tx, we = this.ty, Se = 1 / (g * Q - w * q), Ge = Q * Se, Je = -w * Se, ft = -q * Se, Tt = g * Se;
    return new ut(Ge, Je, ft, Tt, -Ge * ae - ft * we, -Je * ae - Tt * we);
  }, ut.prototype.applyToPoint = function(g) {
    var w = g.x * this.sx + g.y * this.shx + this.tx, q = g.x * this.shy + g.y * this.sy + this.ty;
    return new hi(w, q);
  }, ut.prototype.applyToRectangle = function(g) {
    var w = this.applyToPoint(g), q = this.applyToPoint(new hi(g.x + g.w, g.y + g.h));
    return new vs(w.x, w.y, q.x - w.x, q.y - w.y);
  }, ut.prototype.clone = function() {
    var g = this.sx, w = this.shy, q = this.shx, Q = this.sy, ae = this.tx, we = this.ty;
    return new ut(g, w, q, Q, ae, we);
  }, d.Matrix = ut;
  var si = d.matrixMult = function(g, w) {
    return w.multiply(g);
  }, oi = new ut(1, 0, 0, 1, 0, 0);
  d.unitMatrix = d.identityMatrix = oi;
  var gr = function(g, w) {
    if (!kt[g]) {
      var q = (w instanceof Aa ? "Sh" : "P") + (Object.keys(Qe).length + 1).toString(10);
      w.id = q, kt[g] = q, Qe[q] = w, Mt.publish("addPattern", w);
    }
  };
  d.ShadingPattern = Aa, d.TilingPattern = rs, d.addShadingPattern = function(g, w) {
    return z("addShadingPattern()"), gr(g, w), this;
  }, d.beginTilingPattern = function(g) {
    z("beginTilingPattern()"), Ss(g.boundingBox[0], g.boundingBox[1], g.boundingBox[2] - g.boundingBox[0], g.boundingBox[3] - g.boundingBox[1], g.matrix);
  }, d.endTilingPattern = function(g, w) {
    z("endTilingPattern()"), w.stream = Ie[T].join(`
`), gr(g, w), Mt.publish("endTilingPattern", w), qr.pop().restore();
  };
  var br, nn = d.__private__.newObject = function() {
    var g = vn();
    return Cn(g, !0), g;
  }, vn = d.__private__.newObjectDeferred = function() {
    return te++, le[te] = function() {
      return be;
    }, te;
  }, Cn = function(g, w) {
    return w = typeof w == "boolean" && w, le[g] = be, w && F(g + " 0 obj"), g;
  }, ra = d.__private__.newAdditionalObject = function() {
    var g = { objId: vn(), content: "" };
    return Ae.push(g), g;
  }, Li = vn(), Lr = vn(), zr = d.__private__.decodeColorString = function(g) {
    var w = g.split(" ");
    if (w.length !== 2 || w[1] !== "g" && w[1] !== "G") w.length !== 5 || w[4] !== "k" && w[4] !== "K" || (w = [(1 - w[0]) * (1 - w[3]), (1 - w[1]) * (1 - w[3]), (1 - w[2]) * (1 - w[3]), "r"]);
    else {
      var q = parseFloat(w[0]);
      w = [q, q, q, "r"];
    }
    for (var Q = "#", ae = 0; ae < 3; ae++) Q += ("0" + Math.floor(255 * parseFloat(w[ae])).toString(16)).slice(-2);
    return Q;
  }, kr = d.__private__.encodeColorString = function(g) {
    var w;
    typeof g == "string" && (g = { ch1: g });
    var q = g.ch1, Q = g.ch2, ae = g.ch3, we = g.ch4, Se = g.pdfColorType === "draw" ? ["G", "RG", "K"] : ["g", "rg", "k"];
    if (typeof q == "string" && q.charAt(0) !== "#") {
      var Ge = new Np(q);
      if (Ge.ok) q = Ge.toHex();
      else if (!/^\d*\.?\d*$/.test(q)) throw new Error('Invalid color "' + q + '" passed to jsPDF.encodeColorString.');
    }
    if (typeof q == "string" && /^#[0-9A-Fa-f]{3}$/.test(q) && (q = "#" + q[1] + q[1] + q[2] + q[2] + q[3] + q[3]), typeof q == "string" && /^#[0-9A-Fa-f]{6}$/.test(q)) {
      var Je = parseInt(q.substr(1), 16);
      q = Je >> 16 & 255, Q = Je >> 8 & 255, ae = 255 & Je;
    }
    if (Q === void 0 || we === void 0 && q === Q && Q === ae) w = typeof q == "string" ? q + " " + Se[0] : g.precision === 2 ? N(q / 255) + " " + Se[0] : I(q / 255) + " " + Se[0];
    else if (we === void 0 || qt(we) === "object") {
      if (we && !isNaN(we.a) && we.a === 0) return ["1.", "1.", "1.", Se[1]].join(" ");
      w = typeof q == "string" ? [q, Q, ae, Se[1]].join(" ") : g.precision === 2 ? [N(q / 255), N(Q / 255), N(ae / 255), Se[1]].join(" ") : [I(q / 255), I(Q / 255), I(ae / 255), Se[1]].join(" ");
    } else w = typeof q == "string" ? [q, Q, ae, we, Se[2]].join(" ") : g.precision === 2 ? [N(q), N(Q), N(ae), N(we), Se[2]].join(" ") : [I(q), I(Q), I(ae), I(we), Se[2]].join(" ");
    return w;
  }, Cr = d.__private__.getFilters = function() {
    return s;
  }, Er = d.__private__.putStream = function(g) {
    var w = (g = g || {}).data || "", q = g.filters || Cr(), Q = g.alreadyAppliedFilters || [], ae = g.addLength1 || !1, we = w.length, Se = g.objectId, Ge = function(Tn) {
      return Tn;
    };
    if (f !== null && Se === void 0) throw new Error("ObjectId must be passed to putStream for file encryption");
    f !== null && (Ge = yn.encryptor(Se, 0));
    var Je = {};
    q === !0 && (q = ["FlateEncode"]);
    var ft = g.additionalKeyValues || [], Tt = (Je = et.API.processDataByFilters !== void 0 ? et.API.processDataByFilters(w, q) : { data: w, reverseChain: [] }).reverseChain + (Array.isArray(Q) ? Q.join(" ") : Q.toString());
    if (Je.data.length !== 0 && (ft.push({ key: "Length", value: Je.data.length }), ae === !0 && ft.push({ key: "Length1", value: we })), Tt.length != 0) if (Tt.split("/").length - 1 == 1) ft.push({ key: "Filter", value: Tt });
    else {
      ft.push({ key: "Filter", value: "[" + Tt + "]" });
      for (var Ot = 0; Ot < ft.length; Ot += 1) if (ft[Ot].key === "DecodeParms") {
        for (var tn = [], gn = 0; gn < Je.reverseChain.split("/").length - 1; gn += 1) tn.push("null");
        tn.push(ft[Ot].value), ft[Ot].value = "[" + tn.join(" ") + "]";
      }
    }
    F("<<");
    for (var Gt = 0; Gt < ft.length; Gt++) F("/" + ft[Gt].key + " " + ft[Gt].value);
    F(">>"), Je.data.length !== 0 && (F("stream"), F(Ge(Je.data)), F("endstream"));
  }, ia = d.__private__.putPage = function(g) {
    var w = g.number, q = g.data, Q = g.objId, ae = g.contentsObjId;
    Cn(Q, !0), F("<</Type /Page"), F("/Parent " + g.rootDictionaryObjId + " 0 R"), F("/Resources " + g.resourceDictionaryObjId + " 0 R"), F("/MediaBox [" + parseFloat(Z(g.mediaBox.bottomLeftX)) + " " + parseFloat(Z(g.mediaBox.bottomLeftY)) + " " + Z(g.mediaBox.topRightX) + " " + Z(g.mediaBox.topRightY) + "]"), g.cropBox !== null && F("/CropBox [" + Z(g.cropBox.bottomLeftX) + " " + Z(g.cropBox.bottomLeftY) + " " + Z(g.cropBox.topRightX) + " " + Z(g.cropBox.topRightY) + "]"), g.bleedBox !== null && F("/BleedBox [" + Z(g.bleedBox.bottomLeftX) + " " + Z(g.bleedBox.bottomLeftY) + " " + Z(g.bleedBox.topRightX) + " " + Z(g.bleedBox.topRightY) + "]"), g.trimBox !== null && F("/TrimBox [" + Z(g.trimBox.bottomLeftX) + " " + Z(g.trimBox.bottomLeftY) + " " + Z(g.trimBox.topRightX) + " " + Z(g.trimBox.topRightY) + "]"), g.artBox !== null && F("/ArtBox [" + Z(g.artBox.bottomLeftX) + " " + Z(g.artBox.bottomLeftY) + " " + Z(g.artBox.topRightX) + " " + Z(g.artBox.topRightY) + "]"), typeof g.userUnit == "number" && g.userUnit !== 1 && F("/UserUnit " + g.userUnit), Mt.publish("putPage", { objId: Q, pageContext: ot[w], pageNumber: w, page: q }), F("/Contents " + ae + " 0 R"), F(">>"), F("endobj");
    var we = q.join(`
`);
    return V === B && (we += `
Q`), Cn(ae, !0), Er({ data: we, filters: Cr(), objectId: ae }), F("endobj"), Q;
  }, Yr = d.__private__.putPages = function() {
    var g, w, q = [];
    for (g = 1; g <= vt; g++) ot[g].objId = vn(), ot[g].contentsObjId = vn();
    for (g = 1; g <= vt; g++) q.push(ia({ number: g, data: Ie[g], objId: ot[g].objId, contentsObjId: ot[g].contentsObjId, mediaBox: ot[g].mediaBox, cropBox: ot[g].cropBox, bleedBox: ot[g].bleedBox, trimBox: ot[g].trimBox, artBox: ot[g].artBox, userUnit: ot[g].userUnit, rootDictionaryObjId: Li, resourceDictionaryObjId: Lr }));
    Cn(Li, !0), F("<</Type /Pages");
    var Q = "/Kids [";
    for (w = 0; w < vt; w++) Q += q[w] + " 0 R ";
    F(Q + "]"), F("/Count " + vt), F(">>"), F("endobj"), Mt.publish("postPutPages");
  }, aa = function(g) {
    Mt.publish("putFont", { font: g, out: F, newObject: nn, putStream: Er }), g.isAlreadyPutted !== !0 && (g.objectNumber = nn(), F("<<"), F("/Type /Font"), F("/BaseFont /" + ts(g.postScriptName)), F("/Subtype /Type1"), typeof g.encoding == "string" && F("/Encoding /" + g.encoding), F("/FirstChar 32"), F("/LastChar 255"), F(">>"), F("endobj"));
  }, Oa = function(g) {
    g.objectNumber = nn();
    var w = [];
    w.push({ key: "Type", value: "/XObject" }), w.push({ key: "Subtype", value: "/Form" }), w.push({ key: "BBox", value: "[" + [Z(g.x), Z(g.y), Z(g.x + g.width), Z(g.y + g.height)].join(" ") + "]" }), w.push({ key: "Matrix", value: "[" + g.matrix.toString() + "]" });
    var q = g.pages[1].join(`
`);
    Er({ data: q, additionalKeyValues: w, objectId: g.objectNumber }), F("endobj");
  }, Ra = function(g, w) {
    w || (w = 21);
    var q = nn(), Q = (function(Se, Ge) {
      var Je, ft = [], Tt = 1 / (Ge - 1);
      for (Je = 0; Je < 1; Je += Tt) ft.push(Je);
      if (ft.push(1), Se[0].offset != 0) {
        var Ot = { offset: 0, color: Se[0].color };
        Se.unshift(Ot);
      }
      if (Se[Se.length - 1].offset != 1) {
        var tn = { offset: 1, color: Se[Se.length - 1].color };
        Se.push(tn);
      }
      for (var gn = "", Gt = 0, Tn = 0; Tn < ft.length; Tn++) {
        for (Je = ft[Tn]; Je > Se[Gt + 1].offset; ) Gt++;
        var bn = Se[Gt].offset, In = (Je - bn) / (Se[Gt + 1].offset - bn), mi = Se[Gt].color, Pr = Se[Gt + 1].color;
        gn += ee(Math.round((1 - In) * mi[0] + In * Pr[0]).toString(16)) + ee(Math.round((1 - In) * mi[1] + In * Pr[1]).toString(16)) + ee(Math.round((1 - In) * mi[2] + In * Pr[2]).toString(16));
      }
      return gn.trim();
    })(g.colors, w), ae = [];
    ae.push({ key: "FunctionType", value: "0" }), ae.push({ key: "Domain", value: "[0.0 1.0]" }), ae.push({ key: "Size", value: "[" + w + "]" }), ae.push({ key: "BitsPerSample", value: "8" }), ae.push({ key: "Range", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), ae.push({ key: "Decode", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), Er({ data: Q, additionalKeyValues: ae, alreadyAppliedFilters: ["/ASCIIHexDecode"], objectId: q }), F("endobj"), g.objectNumber = nn(), F("<< /ShadingType " + g.type), F("/ColorSpace /DeviceRGB");
    var we = "/Coords [" + Z(parseFloat(g.coords[0])) + " " + Z(parseFloat(g.coords[1])) + " ";
    g.type === 2 ? we += Z(parseFloat(g.coords[2])) + " " + Z(parseFloat(g.coords[3])) : we += Z(parseFloat(g.coords[2])) + " " + Z(parseFloat(g.coords[3])) + " " + Z(parseFloat(g.coords[4])) + " " + Z(parseFloat(g.coords[5])), F(we += "]"), g.matrix && F("/Matrix [" + g.matrix.toString() + "]"), F("/Function " + q + " 0 R"), F("/Extend [true true]"), F(">>"), F("endobj");
  }, Da = function(g, w) {
    var q = vn(), Q = nn();
    w.push({ resourcesOid: q, objectOid: Q }), g.objectNumber = Q;
    var ae = [];
    ae.push({ key: "Type", value: "/Pattern" }), ae.push({ key: "PatternType", value: "1" }), ae.push({ key: "PaintType", value: "1" }), ae.push({ key: "TilingType", value: "1" }), ae.push({ key: "BBox", value: "[" + g.boundingBox.map(Z).join(" ") + "]" }), ae.push({ key: "XStep", value: Z(g.xStep) }), ae.push({ key: "YStep", value: Z(g.yStep) }), ae.push({ key: "Resources", value: q + " 0 R" }), g.matrix && ae.push({ key: "Matrix", value: "[" + g.matrix.toString() + "]" }), Er({ data: g.stream, additionalKeyValues: ae, objectId: g.objectNumber }), F("endobj");
  }, rl = function(g) {
    for (var w in g.objectNumber = nn(), F("<<"), g) switch (w) {
      case "opacity":
        F("/ca " + N(g[w]));
        break;
      case "stroke-opacity":
        F("/CA " + N(g[w]));
    }
    F(">>"), F("endobj");
  }, Es = function(g) {
    Cn(g.resourcesOid, !0), F("<<"), F("/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]"), (function() {
      for (var w in F("/Font <<"), ht) ht.hasOwnProperty(w) && (p === !1 || p === !0 && E.hasOwnProperty(w)) && F("/" + w + " " + ht[w].objectNumber + " 0 R");
      F(">>");
    })(), (function() {
      if (Object.keys(Qe).length > 0) {
        for (var w in F("/Shading <<"), Qe) Qe.hasOwnProperty(w) && Qe[w] instanceof Aa && Qe[w].objectNumber >= 0 && F("/" + w + " " + Qe[w].objectNumber + " 0 R");
        Mt.publish("putShadingPatternDict"), F(">>");
      }
    })(), (function(w) {
      if (Object.keys(Qe).length > 0) {
        for (var q in F("/Pattern <<"), Qe) Qe.hasOwnProperty(q) && Qe[q] instanceof d.TilingPattern && Qe[q].objectNumber >= 0 && Qe[q].objectNumber < w && F("/" + q + " " + Qe[q].objectNumber + " 0 R");
        Mt.publish("putTilingPatternDict"), F(">>");
      }
    })(g.objectOid), (function() {
      if (Object.keys(lt).length > 0) {
        var w;
        for (w in F("/ExtGState <<"), lt) lt.hasOwnProperty(w) && lt[w].objectNumber >= 0 && F("/" + w + " " + lt[w].objectNumber + " 0 R");
        Mt.publish("putGStateDict"), F(">>");
      }
    })(), (function() {
      for (var w in F("/XObject <<"), Mn) Mn.hasOwnProperty(w) && Mn[w].objectNumber >= 0 && F("/" + w + " " + Mn[w].objectNumber + " 0 R");
      Mt.publish("putXobjectDict"), F(">>");
    })(), F(">>"), F("endobj");
  }, No = function(g) {
    dt[g.fontName] = dt[g.fontName] || {}, dt[g.fontName][g.fontStyle] = g.id;
  }, vo = function(g, w, q, Q, ae) {
    var we = { id: "F" + (Object.keys(ht).length + 1).toString(10), postScriptName: g, fontName: w, fontStyle: q, encoding: Q, isStandardFont: ae || !1, metadata: {} };
    return Mt.publish("addFont", { font: we, instance: this }), ht[we.id] = we, No(we), we.id;
  }, yr = d.__private__.pdfEscape = d.pdfEscape = function(g, w) {
    return (function(q, Q) {
      var ae, we, Se, Ge, Je, ft, Tt, Ot, tn;
      if (Se = (Q = Q || {}).sourceEncoding || "Unicode", Je = Q.outputEncoding, (Q.autoencode || Je) && ht[Re].metadata && ht[Re].metadata[Se] && ht[Re].metadata[Se].encoding && (Ge = ht[Re].metadata[Se].encoding, !Je && ht[Re].encoding && (Je = ht[Re].encoding), !Je && Ge.codePages && (Je = Ge.codePages[0]), typeof Je == "string" && (Je = Ge[Je]), Je)) {
        for (Tt = !1, ft = [], ae = 0, we = q.length; ae < we; ae++) (Ot = Je[q.charCodeAt(ae)]) ? ft.push(String.fromCharCode(Ot)) : ft.push(q[ae]), ft[ae].charCodeAt(0) >> 8 && (Tt = !0);
        q = ft.join("");
      }
      for (ae = q.length; Tt === void 0 && ae !== 0; ) q.charCodeAt(ae - 1) >> 8 && (Tt = !0), ae--;
      if (!Tt) return q;
      for (ft = Q.noBOM ? [] : [254, 255], ae = 0, we = q.length; ae < we; ae++) {
        if ((tn = (Ot = q.charCodeAt(ae)) >> 8) >> 8) throw new Error("Character at position " + ae + " of string '" + q + "' exceeds 16bits. Cannot be encoded into UCS-2 BE");
        ft.push(tn), ft.push(Ot - (tn << 8));
      }
      return String.fromCharCode.apply(void 0, ft);
    })(g, w).replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
  }, ys = d.__private__.beginPage = function(g) {
    Ie[++vt] = [], ot[vt] = { objId: 0, contentsObjId: 0, userUnit: Number(o), artBox: null, bleedBox: null, cropBox: null, trimBox: null, mediaBox: { bottomLeftX: 0, bottomLeftY: 0, topRightX: Number(g[0]), topRightY: Number(g[1]) } }, Lo(vt), tt(Ie[T]);
  }, So = function(g, w) {
    var q, Q, ae;
    switch (n = w || n, typeof g == "string" && (q = _(g.toLowerCase()), Array.isArray(q) && (Q = q[0], ae = q[1])), Array.isArray(g) && (Q = g[0] * qe, ae = g[1] * qe), isNaN(Q) && (Q = i[0], ae = i[1]), (Q > 14400 || ae > 14400) && (Wt.warn("A page in a PDF can not be wider or taller than 14400 userUnit. jsPDF limits the width/height to 14400"), Q = Math.min(14400, Q), ae = Math.min(14400, ae)), i = [Q, ae], n.substr(0, 1)) {
      case "l":
        ae > Q && (i = [ae, Q]);
        break;
      case "p":
        Q > ae && (i = [ae, Q]);
    }
    ys(i), pt(As), F(Ua), xs !== 0 && F(xs + " J"), Ns !== 0 && F(Ns + " j"), Mt.publish("addPage", { pageNumber: vt });
  }, Ts = function(g) {
    g > 0 && g <= vt && (Ie.splice(g, 1), ot.splice(g, 1), vt--, T > vt && (T = vt), this.setPage(T));
  }, Lo = function(g) {
    g > 0 && g <= vt && (T = g);
  }, ko = d.__private__.getNumberOfPages = d.getNumberOfPages = function() {
    return Ie.length - 1;
  }, Co = function(g, w, q) {
    var Q, ae = void 0;
    return q = q || {}, g = g !== void 0 ? g : ht[Re].fontName, w = w !== void 0 ? w : ht[Re].fontStyle, Q = g.toLowerCase(), dt[Q] !== void 0 && dt[Q][w] !== void 0 ? ae = dt[Q][w] : dt[g] !== void 0 && dt[g][w] !== void 0 ? ae = dt[g][w] : q.disableWarning === !1 && Wt.warn("Unable to look up font label for font '" + g + "', '" + w + "'. Refer to getFontList() for available fonts."), ae || q.noFallback || (ae = dt.times[w]) == null && (ae = dt.times.normal), ae;
  }, Wr = d.__private__.putInfo = function() {
    var g = nn(), w = function(Q) {
      return Q;
    };
    for (var q in f !== null && (w = yn.encryptor(g, 0)), F("<<"), F("/Producer (" + yr(w("jsPDF " + et.version)) + ")"), Fe) Fe.hasOwnProperty(q) && Fe[q] && F("/" + q.substr(0, 1).toUpperCase() + q.substr(1) + " (" + yr(w(Fe[q])) + ")");
    F("/CreationDate (" + yr(w(J)) + ")"), F(">>"), F("endobj");
  }, Ma = d.__private__.putCatalog = function(g) {
    var w = (g = g || {}).rootDictionaryObjId || Li;
    switch (nn(), F("<<"), F("/Type /Catalog"), F("/Pages " + w + " 0 R"), rt || (rt = "fullwidth"), rt) {
      case "fullwidth":
        F("/OpenAction [3 0 R /FitH null]");
        break;
      case "fullheight":
        F("/OpenAction [3 0 R /FitV null]");
        break;
      case "fullpage":
        F("/OpenAction [3 0 R /Fit]");
        break;
      case "original":
        F("/OpenAction [3 0 R /XYZ null null 1]");
        break;
      default:
        var q = "" + rt;
        q.substr(q.length - 1) === "%" && (rt = parseInt(rt) / 100), typeof rt == "number" && F("/OpenAction [3 0 R /XYZ null null " + N(rt) + "]");
    }
    switch (xt || (xt = "continuous"), xt) {
      case "continuous":
        F("/PageLayout /OneColumn");
        break;
      case "single":
        F("/PageLayout /SinglePage");
        break;
      case "two":
      case "twoleft":
        F("/PageLayout /TwoColumnLeft");
        break;
      case "tworight":
        F("/PageLayout /TwoColumnRight");
    }
    nt && F("/PageMode /" + nt), Mt.publish("putCatalog"), F(">>"), F("endobj");
  }, il = d.__private__.putTrailer = function() {
    F("trailer"), F("<<"), F("/Size " + (te + 1)), F("/Root " + te + " 0 R"), F("/Info " + (te - 1) + " 0 R"), f !== null && F("/Encrypt " + yn.oid + " 0 R"), F("/ID [ <" + ue + "> <" + ue + "> ]"), F(">>");
  }, mn = d.__private__.putHeader = function() {
    F("%PDF-" + A), F("%ÂºÃŸÂ¬Ã ");
  }, Io = d.__private__.putXRef = function() {
    var g = "0000000000";
    F("xref"), F("0 " + (te + 1)), F("0000000000 65535 f ");
    for (var w = 1; w <= te; w++) typeof le[w] == "function" ? F((g + le[w]()).slice(-10) + " 00000 n ") : le[w] !== void 0 ? F((g + le[w]).slice(-10) + " 00000 n ") : F("0000000000 00000 n ");
  }, Vr = d.__private__.buildDocument = function() {
    var g;
    te = 0, be = 0, ge = [], le = [], Ae = [], Li = vn(), Lr = vn(), tt(ge), Mt.publish("buildDocument"), mn(), Yr(), (function() {
      Mt.publish("putAdditionalObjects");
      for (var q = 0; q < Ae.length; q++) {
        var Q = Ae[q];
        Cn(Q.objId, !0), F(Q.content), F("endobj");
      }
      Mt.publish("postPutAdditionalObjects");
    })(), g = [], (function() {
      for (var q in ht) ht.hasOwnProperty(q) && (p === !1 || p === !0 && E.hasOwnProperty(q)) && aa(ht[q]);
    })(), (function() {
      var q;
      for (q in lt) lt.hasOwnProperty(q) && rl(lt[q]);
    })(), (function() {
      for (var q in Mn) Mn.hasOwnProperty(q) && Oa(Mn[q]);
    })(), (function(q) {
      var Q;
      for (Q in Qe) Qe.hasOwnProperty(Q) && (Qe[Q] instanceof Aa ? Ra(Qe[Q]) : Qe[Q] instanceof rs && Da(Qe[Q], q));
    })(g), Mt.publish("putResources"), g.forEach(Es), Es({ resourcesOid: Lr, objectOid: Number.MAX_SAFE_INTEGER }), Mt.publish("postPutResources"), f !== null && (yn.oid = nn(), F("<<"), F("/Filter /Standard"), F("/V " + yn.v), F("/R " + yn.r), F("/U <" + yn.toHexString(yn.U) + ">"), F("/O <" + yn.toHexString(yn.O) + ">"), F("/P " + yn.P), F(">>"), F("endobj")), Wr(), Ma();
    var w = be;
    return Io(), il(), F("startxref"), F("" + w), F("%%EOF"), tt(Ie[T]), ge.join(`
`);
  }, Fa = d.__private__.getBlob = function(g) {
    return new Blob([gt(g)], { type: "application/pdf" });
  }, Po = d.output = d.__private__.output = (br = function(g, w) {
    switch (typeof (w = w || {}) == "string" ? w = { filename: w } : w.filename = w.filename || "generated.pdf", g) {
      case void 0:
        return Vr();
      case "save":
        d.save(w.filename);
        break;
      case "arraybuffer":
        return gt(Vr());
      case "blob":
        return Fa(Vr());
      case "bloburi":
      case "bloburl":
        if (ct.URL !== void 0 && typeof ct.URL.createObjectURL == "function") return ct.URL && ct.URL.createObjectURL(Fa(Vr())) || void 0;
        Wt.warn("bloburl is not supported by your system, because URL.createObjectURL is not supported by your browser.");
        break;
      case "datauristring":
      case "dataurlstring":
        var q = "", Q = Vr();
        try {
          q = Ad(Q);
        } catch {
          q = Ad(unescape(encodeURIComponent(Q)));
        }
        return "data:application/pdf;filename=" + w.filename + ";base64," + q;
      case "pdfobjectnewwindow":
        if (Object.prototype.toString.call(ct) === "[object Window]") {
          var ae = "https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.1.1/pdfobject.min.js", we = ' integrity="sha512-4ze/a9/4jqu+tX9dfOqJYSvyYd5M6qum/3HpCLr+/Jqf0whc37VUbkpNGHR7/8pSnCFw47T1fmIpwBV7UySh3g==" crossorigin="anonymous"';
          w.pdfObjectUrl && (ae = w.pdfObjectUrl, we = "");
          var Se = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><script src="' + ae + '"' + we + '><\/script><script >PDFObject.embed("' + this.output("dataurlstring") + '", ' + JSON.stringify(w) + ");<\/script></body></html>", Ge = ct.open();
          return Ge !== null && Ge.document.write(Se), Ge;
        }
        throw new Error("The option pdfobjectnewwindow just works in a browser-environment.");
      case "pdfjsnewwindow":
        if (Object.prototype.toString.call(ct) === "[object Window]") {
          var Je = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe id="pdfViewer" src="' + (w.pdfJsUrl || "examples/PDF.js/web/viewer.html") + "?file=&downloadName=" + w.filename + '" width="500px" height="400px" /></body></html>', ft = ct.open();
          if (ft !== null) {
            ft.document.write(Je);
            var Tt = this;
            ft.document.documentElement.querySelector("#pdfViewer").onload = function() {
              ft.document.title = w.filename, ft.document.documentElement.querySelector("#pdfViewer").contentWindow.PDFViewerApplication.open(Tt.output("bloburl"));
            };
          }
          return ft;
        }
        throw new Error("The option pdfjsnewwindow just works in a browser-environment.");
      case "dataurlnewwindow":
        if (Object.prototype.toString.call(ct) !== "[object Window]") throw new Error("The option dataurlnewwindow just works in a browser-environment.");
        var Ot = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe src="' + this.output("datauristring", w) + '"></iframe></body></html>', tn = ct.open();
        if (tn !== null && (tn.document.write(Ot), tn.document.title = w.filename), tn || typeof safari > "u") return tn;
        break;
      case "datauri":
      case "dataurl":
        return ct.document.location.href = this.output("datauristring", w);
      default:
        return null;
    }
  }, br.foo = function() {
    try {
      return br.apply(this, arguments);
    } catch (q) {
      var g = q.stack || "";
      ~g.indexOf(" at ") && (g = g.split(" at ")[1]);
      var w = "Error in function " + g.split(`
`)[0].split("<")[0] + ": " + q.message;
      if (!ct.console) throw new Error(w);
      ct.console.error(w, q), ct.alert && alert(w);
    }
  }, br.foo.bar = br, br.foo), Tr = function(g) {
    return Array.isArray(na) === !0 && na.indexOf(g) > -1;
  };
  switch (r) {
    case "pt":
      qe = 1;
      break;
    case "mm":
      qe = 72 / 25.4;
      break;
    case "cm":
      qe = 72 / 2.54;
      break;
    case "in":
      qe = 72;
      break;
    case "px":
      qe = Tr("px_scaling") == 1 ? 0.75 : 96 / 72;
      break;
    case "pc":
    case "em":
      qe = 12;
      break;
    case "ex":
      qe = 6;
      break;
    default:
      if (typeof r != "number") throw new Error("Invalid unit: " + r);
      qe = r;
  }
  var yn = null;
  xe(), se();
  var ui = d.__private__.getPageInfo = d.getPageInfo = function(g) {
    if (isNaN(g) || g % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfo");
    return { objId: ot[g].objId, pageNumber: g, pageContext: ot[g] };
  }, Oo = d.__private__.getPageInfoByObjId = function(g) {
    if (isNaN(g) || g % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfoByObjId");
    for (var w in ot) if (ot[w].objId === g) break;
    return ui(w);
  }, al = d.__private__.getCurrentPageInfo = d.getCurrentPageInfo = function() {
    return { objId: ot[T].objId, pageNumber: T, pageContext: ot[T] };
  };
  d.addPage = function() {
    return So.apply(this, arguments), this;
  }, d.setPage = function() {
    return Lo.apply(this, arguments), tt.call(this, Ie[T]), this;
  }, d.insertPage = function(g) {
    return this.addPage(), this.movePage(T, g), this;
  }, d.movePage = function(g, w) {
    var q, Q;
    if (g > w) {
      q = Ie[g], Q = ot[g];
      for (var ae = g; ae > w; ae--) Ie[ae] = Ie[ae - 1], ot[ae] = ot[ae - 1];
      Ie[w] = q, ot[w] = Q, this.setPage(w);
    } else if (g < w) {
      q = Ie[g], Q = ot[g];
      for (var we = g; we < w; we++) Ie[we] = Ie[we + 1], ot[we] = ot[we + 1];
      Ie[w] = q, ot[w] = Q, this.setPage(w);
    }
    return this;
  }, d.deletePage = function() {
    return Ts.apply(this, arguments), this;
  }, d.__private__.text = d.text = function(g, w, q, Q, ae) {
    var we, Se, Ge, Je, ft, Tt, Ot, tn, gn, Gt = (Q = Q || {}).scope || this;
    if (typeof g == "number" && typeof w == "number" && (typeof q == "string" || Array.isArray(q))) {
      var Tn = q;
      q = w, w = g, g = Tn;
    }
    if (arguments[3] instanceof ut == 0 ? (Ge = arguments[4], Je = arguments[5], qt(Ot = arguments[3]) === "object" && Ot !== null || (typeof Ge == "string" && (Je = Ge, Ge = null), typeof Ot == "string" && (Je = Ot, Ot = null), typeof Ot == "number" && (Ge = Ot, Ot = null), Q = { flags: Ot, angle: Ge, align: Je })) : (z("The transform parameter of text() with a Matrix value"), gn = ae), isNaN(w) || isNaN(q) || g == null) throw new Error("Invalid arguments passed to jsPDF.text");
    if (g.length === 0) return Gt;
    var bn, In = "", mi = typeof Q.lineHeightFactor == "number" ? Q.lineHeightFactor : oa, Pr = Gt.internal.scaleFactor;
    function gi(Ft) {
      return Ft = Ft.split("	").join(Array(Q.TabLen || 9).join(" ")), yr(Ft, Ot);
    }
    function ks(Ft) {
      for (var zt, un = Ft.concat(), _n = [], yi = un.length; yi--; ) typeof (zt = un.shift()) == "string" ? _n.push(zt) : Array.isArray(Ft) && (zt.length === 1 || zt[1] === void 0 && zt[2] === void 0) ? _n.push(zt[0]) : _n.push([zt[0], zt[1], zt[2]]);
      return _n;
    }
    function ja(Ft, zt) {
      var un;
      if (typeof Ft == "string") un = zt(Ft)[0];
      else if (Array.isArray(Ft)) {
        for (var _n, yi, Us = Ft.concat(), Ya = [], Yo = Us.length; Yo--; ) typeof (_n = Us.shift()) == "string" ? Ya.push(zt(_n)[0]) : Array.isArray(_n) && typeof _n[0] == "string" && (yi = zt(_n[0], _n[1], _n[2]), Ya.push([yi[0], yi[1], yi[2]]));
        un = Ya;
      }
      return un;
    }
    var ki = !1, fa = !0;
    if (typeof g == "string") ki = !0;
    else if (Array.isArray(g)) {
      var ha = g.concat();
      Se = [];
      for (var Ci, Pn = ha.length; Pn--; ) (typeof (Ci = ha.shift()) != "string" || Array.isArray(Ci) && typeof Ci[0] != "string") && (fa = !1);
      ki = fa;
    }
    if (ki === !1) throw new Error('Type of text must be string or Array. "' + g + '" is not recognized.');
    typeof g == "string" && (g = g.match(/[\r?\n]/) ? g.split(/\r\n|\r|\n/g) : [g]);
    var da = ke / Gt.internal.scaleFactor, pa = da * (mi - 1);
    switch (Q.baseline) {
      case "bottom":
        q -= pa;
        break;
      case "top":
        q += da - pa;
        break;
      case "hanging":
        q += da - 2 * pa;
        break;
      case "middle":
        q += da / 2 - pa;
    }
    if ((Tt = Q.maxWidth || 0) > 0 && (typeof g == "string" ? g = Gt.splitTextToSize(g, Tt) : Object.prototype.toString.call(g) === "[object Array]" && (g = g.reduce(function(Ft, zt) {
      return Ft.concat(Gt.splitTextToSize(zt, Tt));
    }, []))), we = { text: g, x: w, y: q, options: Q, mutex: { pdfEscape: yr, activeFontKey: Re, fonts: ht, activeFontSize: ke } }, Mt.publish("preProcessText", we), g = we.text, Ge = (Q = we.options).angle, gn instanceof ut == 0 && Ge && typeof Ge == "number") {
      Ge *= Math.PI / 180, Q.rotationDirection === 0 && (Ge = -Ge), V === B && (Ge = -Ge);
      var Cs = Math.cos(Ge), Is = Math.sin(Ge);
      gn = new ut(Cs, Is, -Is, Cs, 0, 0);
    } else Ge && Ge instanceof ut && (gn = Ge);
    V !== B || gn || (gn = oi), (ft = Q.charSpace || fi) !== void 0 && (In += Z($(ft)) + ` Tc
`, this.setCharSpace(this.getCharSpace() || 0)), (tn = Q.horizontalScale) !== void 0 && (In += Z(100 * tn) + ` Tz
`), Q.lang;
    var Wn = -1, bi = Q.renderingMode !== void 0 ? Q.renderingMode : Q.stroke, qa = Gt.internal.getCurrentPageInfo().pageContext;
    switch (bi) {
      case 0:
      case !1:
      case "fill":
        Wn = 0;
        break;
      case 1:
      case !0:
      case "stroke":
        Wn = 1;
        break;
      case 2:
      case "fillThenStroke":
        Wn = 2;
        break;
      case 3:
      case "invisible":
        Wn = 3;
        break;
      case 4:
      case "fillAndAddForClipping":
        Wn = 4;
        break;
      case 5:
      case "strokeAndAddPathForClipping":
        Wn = 5;
        break;
      case 6:
      case "fillThenStrokeAndAddToPathForClipping":
        Wn = 6;
        break;
      case 7:
      case "addToPathForClipping":
        Wn = 7;
    }
    var qo = qa.usedRenderingMode !== void 0 ? qa.usedRenderingMode : -1;
    Wn !== -1 ? In += Wn + ` Tr
` : qo !== -1 && (In += `0 Tr
`), Wn !== -1 && (qa.usedRenderingMode = Wn), Je = Q.align || "left";
    var _r, ma = ke * mi, Ps = Gt.internal.pageSize.getWidth(), Os = ht[Re];
    ft = Q.charSpace || fi, Tt = Q.maxWidth || 0, Ot = Object.assign({ autoencode: !0, noBOM: !0 }, Q.flags);
    var Ii = [], ga = function(Ft) {
      return Gt.getStringUnitWidth(Ft, { font: Os, charSpace: ft, fontSize: ke, doKerning: !1 }) * ke / Pr;
    };
    if (Object.prototype.toString.call(g) === "[object Array]") {
      var rr;
      Se = ks(g), Je !== "left" && (_r = Se.map(ga));
      var ir, Pi = 0;
      if (Je === "right") {
        w -= _r[0], g = [], Pn = Se.length;
        for (var Ei = 0; Ei < Pn; Ei++) Ei === 0 ? (ir = li(w), rr = ci(q)) : (ir = $(Pi - _r[Ei]), rr = -ma), g.push([Se[Ei], ir, rr]), Pi = _r[Ei];
      } else if (Je === "center") {
        w -= _r[0] / 2, g = [], Pn = Se.length;
        for (var Oi = 0; Oi < Pn; Oi++) Oi === 0 ? (ir = li(w), rr = ci(q)) : (ir = $((Pi - _r[Oi]) / 2), rr = -ma), g.push([Se[Oi], ir, rr]), Pi = _r[Oi];
      } else if (Je === "left") {
        g = [], Pn = Se.length;
        for (var Rs = 0; Rs < Pn; Rs++) g.push(Se[Rs]);
      } else if (Je === "justify" && Os.encoding === "Identity-H") {
        g = [], Pn = Se.length, Tt = Tt !== 0 ? Tt : Ps;
        for (var za = 0, on = 0; on < Pn; on++) if (rr = on === 0 ? ci(q) : -ma, ir = on === 0 ? li(w) : za, on < Pn - 1) {
          var zo = $((Tt - _r[on]) / (Se[on].split(" ").length - 1)), $r = Se[on].split(" ");
          g.push([$r[0] + " ", ir, rr]), za = 0;
          for (var Xr = 1; Xr < $r.length; Xr++) {
            var Ds = (ga($r[Xr - 1] + " " + $r[Xr]) - ga($r[Xr])) * Pr + zo;
            Xr == $r.length - 1 ? g.push([$r[Xr], Ds, 0]) : g.push([$r[Xr] + " ", Ds, 0]), za -= Ds;
          }
        } else g.push([Se[on], ir, rr]);
        g.push(["", za, 0]);
      } else {
        if (Je !== "justify") throw new Error('Unrecognized alignment option, use "left", "center", "right" or "justify".');
        for (g = [], Pn = Se.length, Tt = Tt !== 0 ? Tt : Ps, on = 0; on < Pn; on++) {
          rr = on === 0 ? ci(q) : -ma, ir = on === 0 ? li(w) : 0;
          var Ms = Se[on].split(" ").length - 1, Fs = Ms > 0 ? (Tt - _r[on]) / Ms : 0;
          on < Pn - 1 ? Ii.push(Z($(Fs))) : Ii.push(0), g.push([Se[on], ir, rr]);
        }
      }
    }
    (typeof Q.R2L == "boolean" ? Q.R2L : it) === !0 && (g = ja(g, function(Ft, zt, un) {
      return [Ft.split("").reverse().join(""), zt, un];
    })), we = { text: g, x: w, y: q, options: Q, mutex: { pdfEscape: yr, activeFontKey: Re, fonts: ht, activeFontSize: ke } }, Mt.publish("postProcessText", we), g = we.text, bn = we.mutex.isHex || !1;
    var Bs = ht[Re].encoding;
    Bs !== "WinAnsiEncoding" && Bs !== "StandardEncoding" || (g = ja(g, function(Ft, zt, un) {
      return [gi(Ft), zt, un];
    })), Se = ks(g), g = [];
    for (var Ri, Di, Mi, ba = Array.isArray(Se[0]) ? 1 : 0, Fi = "", Ea = function(Ft, zt, un) {
      var _n = "";
      return un instanceof ut ? (un = typeof Q.angle == "number" ? si(un, new ut(1, 0, 0, 1, Ft, zt)) : si(new ut(1, 0, 0, 1, Ft, zt), un), V === B && (un = si(new ut(1, 0, 0, -1, 0, 0), un)), _n = un.join(" ") + ` Tm
`) : _n = Z(Ft) + " " + Z(zt) + ` Td
`, _n;
    }, Ar = 0; Ar < Se.length; Ar++) {
      switch (Fi = "", ba) {
        case 1:
          Mi = (bn ? "<" : "(") + Se[Ar][0] + (bn ? ">" : ")"), Ri = parseFloat(Se[Ar][1]), Di = parseFloat(Se[Ar][2]);
          break;
        case 0:
          Mi = (bn ? "<" : "(") + Se[Ar] + (bn ? ">" : ")"), Ri = li(w), Di = ci(q);
      }
      Ii !== void 0 && Ii[Ar] !== void 0 && (Fi = Ii[Ar] + ` Tw
`), Ar === 0 ? g.push(Fi + Ea(Ri, Di, gn) + Mi) : ba === 0 ? g.push(Fi + Mi) : ba === 1 && g.push(Fi + Ea(Ri, Di, gn) + Mi);
    }
    g = ba === 0 ? g.join(` Tj
T* `) : g.join(` Tj
`), g += ` Tj
`;
    var Kr = `BT
/`;
    return Kr += Re + " " + ke + ` Tf
`, Kr += Z(ke * mi) + ` TL
`, Kr += ua + `
`, Kr += In, Kr += g, F(Kr += "ET"), E[Re] = !0, Gt;
  };
  var sl = d.__private__.clip = d.clip = function(g) {
    return F(g === "evenodd" ? "W*" : "W"), this;
  };
  d.clipEvenOdd = function() {
    return sl("evenodd");
  }, d.__private__.discardPath = d.discardPath = function() {
    return F("n"), this;
  };
  var Gr = d.__private__.isValidStyle = function(g) {
    var w = !1;
    return [void 0, null, "S", "D", "F", "DF", "FD", "f", "f*", "B", "B*", "n"].indexOf(g) !== -1 && (w = !0), w;
  };
  d.__private__.setDefaultPathOperation = d.setDefaultPathOperation = function(g) {
    return Gr(g) && (c = g), this;
  };
  var Ro = d.__private__.getStyle = d.getStyle = function(g) {
    var w = c;
    switch (g) {
      case "D":
      case "S":
        w = "S";
        break;
      case "F":
        w = "f";
        break;
      case "FD":
      case "DF":
        w = "B";
        break;
      case "f":
      case "f*":
      case "B":
      case "B*":
        w = g;
    }
    return w;
  }, Do = d.close = function() {
    return F("h"), this;
  };
  d.stroke = function() {
    return F("S"), this;
  }, d.fill = function(g) {
    return Ba("f", g), this;
  }, d.fillEvenOdd = function(g) {
    return Ba("f*", g), this;
  }, d.fillStroke = function(g) {
    return Ba("B", g), this;
  }, d.fillStrokeEvenOdd = function(g) {
    return Ba("B*", g), this;
  };
  var Ba = function(g, w) {
    qt(w) === "object" ? ul(w, g) : F(g);
  }, sa = function(g) {
    g === null || V === B && g === void 0 || (g = Ro(g), F(g));
  };
  function ol(g, w, q, Q, ae) {
    var we = new rs(w || this.boundingBox, q || this.xStep, Q || this.yStep, this.gState, ae || this.matrix);
    we.stream = this.stream;
    var Se = g + "$$" + this.cloneIndex++ + "$$";
    return gr(Se, we), we;
  }
  var ul = function(g, w) {
    var q = kt[g.key], Q = Qe[q];
    if (Q instanceof Aa) F("q"), F(ll(w)), Q.gState && d.setGState(Q.gState), F(g.matrix.toString() + " cm"), F("/" + q + " sh"), F("Q");
    else if (Q instanceof rs) {
      var ae = new ut(1, 0, 0, -1, 0, ca());
      g.matrix && (ae = ae.multiply(g.matrix || oi), q = ol.call(Q, g.key, g.boundingBox, g.xStep, g.yStep, ae).id), F("q"), F("/Pattern cs"), F("/" + q + " scn"), Q.gState && d.setGState(Q.gState), F(w), F("Q");
    }
  }, ll = function(g) {
    switch (g) {
      case "f":
      case "F":
      case "n":
        return "W n";
      case "f*":
        return "W* n";
      case "B":
      case "S":
        return "W S";
      case "B*":
        return "W* S";
    }
  }, _s = d.moveTo = function(g, w) {
    return F(Z($(g)) + " " + Z(Y(w)) + " m"), this;
  }, Mo = d.lineTo = function(g, w) {
    return F(Z($(g)) + " " + Z(Y(w)) + " l"), this;
  }, Ir = d.curveTo = function(g, w, q, Q, ae, we) {
    return F([Z($(g)), Z(Y(w)), Z($(q)), Z(Y(Q)), Z($(ae)), Z(Y(we)), "c"].join(" ")), this;
  };
  d.__private__.line = d.line = function(g, w, q, Q, ae) {
    if (isNaN(g) || isNaN(w) || isNaN(q) || isNaN(Q) || !Gr(ae)) throw new Error("Invalid arguments passed to jsPDF.line");
    return V === U ? this.lines([[q - g, Q - w]], g, w, [1, 1], ae || "S") : this.lines([[q - g, Q - w]], g, w, [1, 1]).stroke();
  }, d.__private__.lines = d.lines = function(g, w, q, Q, ae, we) {
    var Se, Ge, Je, ft, Tt, Ot, tn, gn, Gt, Tn, bn, In;
    if (typeof g == "number" && (In = q, q = w, w = g, g = In), Q = Q || [1, 1], we = we || !1, isNaN(w) || isNaN(q) || !Array.isArray(g) || !Array.isArray(Q) || !Gr(ae) || typeof we != "boolean") throw new Error("Invalid arguments passed to jsPDF.lines");
    for (_s(w, q), Se = Q[0], Ge = Q[1], ft = g.length, Tn = w, bn = q, Je = 0; Je < ft; Je++) (Tt = g[Je]).length === 2 ? (Tn = Tt[0] * Se + Tn, bn = Tt[1] * Ge + bn, Mo(Tn, bn)) : (Ot = Tt[0] * Se + Tn, tn = Tt[1] * Ge + bn, gn = Tt[2] * Se + Tn, Gt = Tt[3] * Ge + bn, Tn = Tt[4] * Se + Tn, bn = Tt[5] * Ge + bn, Ir(Ot, tn, gn, Gt, Tn, bn));
    return we && Do(), sa(ae), this;
  }, d.path = function(g) {
    for (var w = 0; w < g.length; w++) {
      var q = g[w], Q = q.c;
      switch (q.op) {
        case "m":
          _s(Q[0], Q[1]);
          break;
        case "l":
          Mo(Q[0], Q[1]);
          break;
        case "c":
          Ir.apply(this, Q);
          break;
        case "h":
          Do();
      }
    }
    return this;
  }, d.__private__.rect = d.rect = function(g, w, q, Q, ae) {
    if (isNaN(g) || isNaN(w) || isNaN(q) || isNaN(Q) || !Gr(ae)) throw new Error("Invalid arguments passed to jsPDF.rect");
    return V === U && (Q = -Q), F([Z($(g)), Z(Y(w)), Z($(q)), Z($(Q)), "re"].join(" ")), sa(ae), this;
  }, d.__private__.triangle = d.triangle = function(g, w, q, Q, ae, we, Se) {
    if (isNaN(g) || isNaN(w) || isNaN(q) || isNaN(Q) || isNaN(ae) || isNaN(we) || !Gr(Se)) throw new Error("Invalid arguments passed to jsPDF.triangle");
    return this.lines([[q - g, Q - w], [ae - q, we - Q], [g - ae, w - we]], g, w, [1, 1], Se, !0), this;
  }, d.__private__.roundedRect = d.roundedRect = function(g, w, q, Q, ae, we, Se) {
    if (isNaN(g) || isNaN(w) || isNaN(q) || isNaN(Q) || isNaN(ae) || isNaN(we) || !Gr(Se)) throw new Error("Invalid arguments passed to jsPDF.roundedRect");
    var Ge = 4 / 3 * (Math.SQRT2 - 1);
    return ae = Math.min(ae, 0.5 * q), we = Math.min(we, 0.5 * Q), this.lines([[q - 2 * ae, 0], [ae * Ge, 0, ae, we - we * Ge, ae, we], [0, Q - 2 * we], [0, we * Ge, -ae * Ge, we, -ae, we], [2 * ae - q, 0], [-ae * Ge, 0, -ae, -we * Ge, -ae, -we], [0, 2 * we - Q], [0, -we * Ge, ae * Ge, -we, ae, -we]], g + ae, w, [1, 1], Se, !0), this;
  }, d.__private__.ellipse = d.ellipse = function(g, w, q, Q, ae) {
    if (isNaN(g) || isNaN(w) || isNaN(q) || isNaN(Q) || !Gr(ae)) throw new Error("Invalid arguments passed to jsPDF.ellipse");
    var we = 4 / 3 * (Math.SQRT2 - 1) * q, Se = 4 / 3 * (Math.SQRT2 - 1) * Q;
    return _s(g + q, w), Ir(g + q, w - Se, g + we, w - Q, g, w - Q), Ir(g - we, w - Q, g - q, w - Se, g - q, w), Ir(g - q, w + Se, g - we, w + Q, g, w + Q), Ir(g + we, w + Q, g + q, w + Se, g + q, w), sa(ae), this;
  }, d.__private__.circle = d.circle = function(g, w, q, Q) {
    if (isNaN(g) || isNaN(w) || isNaN(q) || !Gr(Q)) throw new Error("Invalid arguments passed to jsPDF.circle");
    return this.ellipse(g, w, q, q, Q);
  }, d.setFont = function(g, w, q) {
    return q && (w = fe(w, q)), Re = Co(g, w, { disableWarning: !1 }), this;
  };
  var cl = d.__private__.getFont = d.getFont = function() {
    return ht[Co.apply(d, arguments)];
  };
  d.__private__.getFontList = d.getFontList = function() {
    var g, w, q = {};
    for (g in dt) if (dt.hasOwnProperty(g)) for (w in q[g] = [], dt[g]) dt[g].hasOwnProperty(w) && q[g].push(w);
    return q;
  }, d.addFont = function(g, w, q, Q, ae) {
    var we = ["StandardEncoding", "MacRomanEncoding", "Identity-H", "WinAnsiEncoding"];
    return arguments[3] && we.indexOf(arguments[3]) !== -1 ? ae = arguments[3] : arguments[3] && we.indexOf(arguments[3]) == -1 && (q = fe(q, Q)), vo.call(this, g, w, q, ae = ae || "Identity-H");
  };
  var oa, As = e.lineWidth || 0.200025, fl = d.__private__.getLineWidth = d.getLineWidth = function() {
    return As;
  }, pt = d.__private__.setLineWidth = d.setLineWidth = function(g) {
    return As = g, F(Z($(g)) + " w"), this;
  };
  d.__private__.setLineDash = et.API.setLineDash = et.API.setLineDashPattern = function(g, w) {
    if (g = g || [], w = w || 0, isNaN(w) || !Array.isArray(g)) throw new Error("Invalid arguments passed to jsPDF.setLineDash");
    return g = g.map(function(q) {
      return Z($(q));
    }).join(" "), w = Z($(w)), F("[" + g + "] " + w + " d"), this;
  };
  var hl = d.__private__.getLineHeight = d.getLineHeight = function() {
    return ke * oa;
  };
  d.__private__.getLineHeight = d.getLineHeight = function() {
    return ke * oa;
  };
  var dl = d.__private__.setLineHeightFactor = d.setLineHeightFactor = function(g) {
    return typeof (g = g || 1.15) == "number" && (oa = g), this;
  }, pl = d.__private__.getLineHeightFactor = d.getLineHeightFactor = function() {
    return oa;
  };
  dl(e.lineHeight);
  var li = d.__private__.getHorizontalCoordinate = function(g) {
    return $(g);
  }, ci = d.__private__.getVerticalCoordinate = function(g) {
    return V === B ? g : ot[T].mediaBox.topRightY - ot[T].mediaBox.bottomLeftY - $(g);
  }, ml = d.__private__.getHorizontalCoordinateString = d.getHorizontalCoordinateString = function(g) {
    return Z(li(g));
  }, gl = d.__private__.getVerticalCoordinateString = d.getVerticalCoordinateString = function(g) {
    return Z(ci(g));
  }, Ua = e.strokeColor || "0 G";
  d.__private__.getStrokeColor = d.getDrawColor = function() {
    return zr(Ua);
  }, d.__private__.setStrokeColor = d.setDrawColor = function(g, w, q, Q) {
    return Ua = kr({ ch1: g, ch2: w, ch3: q, ch4: Q, pdfColorType: "draw", precision: 2 }), F(Ua), this;
  };
  var ws = e.fillColor || "0 g";
  d.__private__.getFillColor = d.getFillColor = function() {
    return zr(ws);
  }, d.__private__.setFillColor = d.setFillColor = function(g, w, q, Q) {
    return ws = kr({ ch1: g, ch2: w, ch3: q, ch4: Q, pdfColorType: "fill", precision: 2 }), F(ws), this;
  };
  var ua = e.textColor || "0 g", bl = d.__private__.getTextColor = d.getTextColor = function() {
    return zr(ua);
  };
  d.__private__.setTextColor = d.setTextColor = function(g, w, q, Q) {
    return ua = kr({ ch1: g, ch2: w, ch3: q, ch4: Q, pdfColorType: "text", precision: 3 }), this;
  };
  var fi = e.charSpace, El = d.__private__.getCharSpace = d.getCharSpace = function() {
    return parseFloat(fi || 0);
  };
  d.__private__.setCharSpace = d.setCharSpace = function(g) {
    if (isNaN(g)) throw new Error("Invalid argument passed to jsPDF.setCharSpace");
    return fi = g, this;
  };
  var xs = 0;
  d.CapJoinStyles = { 0: 0, butt: 0, but: 0, miter: 0, 1: 1, round: 1, rounded: 1, circle: 1, 2: 2, projecting: 2, project: 2, square: 2, bevel: 2 }, d.__private__.setLineCap = d.setLineCap = function(g) {
    var w = d.CapJoinStyles[g];
    if (w === void 0) throw new Error("Line cap style of '" + g + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return xs = w, F(w + " J"), this;
  };
  var Ns = 0;
  d.__private__.setLineJoin = d.setLineJoin = function(g) {
    var w = d.CapJoinStyles[g];
    if (w === void 0) throw new Error("Line join style of '" + g + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return Ns = w, F(w + " j"), this;
  }, d.__private__.setLineMiterLimit = d.__private__.setMiterLimit = d.setLineMiterLimit = d.setMiterLimit = function(g) {
    if (g = g || 0, isNaN(g)) throw new Error("Invalid argument passed to jsPDF.setLineMiterLimit");
    return F(Z($(g)) + " M"), this;
  }, d.GState = Hu, d.setGState = function(g) {
    (g = typeof g == "string" ? lt[Et[g]] : Fo(null, g)).equals(Jt) || (F("/" + g.id + " gs"), Jt = g);
  };
  var Fo = function(g, w) {
    if (!g || !Et[g]) {
      var q = !1;
      for (var Q in lt) if (lt.hasOwnProperty(Q) && lt[Q].equals(w)) {
        q = !0;
        break;
      }
      if (q) w = lt[Q];
      else {
        var ae = "GS" + (Object.keys(lt).length + 1).toString(10);
        lt[ae] = w, w.id = ae;
      }
      return g && (Et[g] = w.id), Mt.publish("addGState", w), w;
    }
  };
  d.addGState = function(g, w) {
    return Fo(g, w), this;
  }, d.saveGraphicsState = function() {
    return F("q"), Nt.push({ key: Re, size: ke, color: ua }), this;
  }, d.restoreGraphicsState = function() {
    F("Q");
    var g = Nt.pop();
    return Re = g.key, ke = g.size, ua = g.color, Jt = null, this;
  }, d.setCurrentTransformationMatrix = function(g) {
    return F(g.toString() + " cm"), this;
  }, d.comment = function(g) {
    return F("#" + g), this;
  };
  var hi = function(g, w) {
    var q = g || 0;
    Object.defineProperty(this, "x", { enumerable: !0, get: function() {
      return q;
    }, set: function(we) {
      isNaN(we) || (q = parseFloat(we));
    } });
    var Q = w || 0;
    Object.defineProperty(this, "y", { enumerable: !0, get: function() {
      return Q;
    }, set: function(we) {
      isNaN(we) || (Q = parseFloat(we));
    } });
    var ae = "pt";
    return Object.defineProperty(this, "type", { enumerable: !0, get: function() {
      return ae;
    }, set: function(we) {
      ae = we.toString();
    } }), this;
  }, vs = function(g, w, q, Q) {
    hi.call(this, g, w), this.type = "rect";
    var ae = q || 0;
    Object.defineProperty(this, "w", { enumerable: !0, get: function() {
      return ae;
    }, set: function(Se) {
      isNaN(Se) || (ae = parseFloat(Se));
    } });
    var we = Q || 0;
    return Object.defineProperty(this, "h", { enumerable: !0, get: function() {
      return we;
    }, set: function(Se) {
      isNaN(Se) || (we = parseFloat(Se));
    } }), this;
  }, Ha = function() {
    this.page = vt, this.currentPage = T, this.pages = Ie.slice(0), this.pagesContext = ot.slice(0), this.x = ze, this.y = Bt, this.matrix = bt, this.width = Ls(T), this.height = Uo(T), this.outputDestination = He, this.id = "", this.objectNumber = -1;
  };
  Ha.prototype.restore = function() {
    vt = this.page, T = this.currentPage, ot = this.pagesContext, Ie = this.pages, ze = this.x, Bt = this.y, bt = this.matrix, Bo(T, this.width), di(T, this.height), He = this.outputDestination;
  };
  var Ss = function(g, w, q, Q, ae) {
    qr.push(new Ha()), vt = T = 0, Ie = [], ze = g, Bt = w, bt = ae, ys([q, Q]);
  };
  for (var la in d.beginFormObject = function(g, w, q, Q, ae) {
    return Ss(g, w, q, Q, ae), this;
  }, d.endFormObject = function(g) {
    return (function(w) {
      if (ai[w]) qr.pop().restore();
      else {
        var q = new Ha(), Q = "Xo" + (Object.keys(Mn).length + 1).toString(10);
        q.id = Q, ai[w] = Q, Mn[Q] = q, Mt.publish("addFormObject", q), qr.pop().restore();
      }
    })(g), this;
  }, d.doFormObject = function(g, w) {
    var q = Mn[ai[g]];
    return F("q"), F(w.toString() + " cm"), F("/" + q.id + " Do"), F("Q"), this;
  }, d.getFormObject = function(g) {
    var w = Mn[ai[g]];
    return { x: w.x, y: w.y, width: w.width, height: w.height, matrix: w.matrix };
  }, d.save = function(g, w) {
    return g = g || "generated.pdf", (w = w || {}).returnPromise = w.returnPromise || !1, w.returnPromise === !1 ? (_a(Fa(Vr()), g), typeof _a.unload == "function" && ct.setTimeout && setTimeout(_a.unload, 911), this) : new Promise(function(q, Q) {
      try {
        var ae = _a(Fa(Vr()), g);
        typeof _a.unload == "function" && ct.setTimeout && setTimeout(_a.unload, 911), q(ae);
      } catch (we) {
        Q(we.message);
      }
    });
  }, et.API) et.API.hasOwnProperty(la) && (la === "events" && et.API.events.length ? (function(g, w) {
    var q, Q, ae;
    for (ae = w.length - 1; ae !== -1; ae--) q = w[ae][0], Q = w[ae][1], g.subscribe.apply(g, [q].concat(typeof Q == "function" ? [Q] : Q));
  })(Mt, et.API.events) : d[la] = et.API[la]);
  function Ls(g) {
    return ot[g].mediaBox.topRightX - ot[g].mediaBox.bottomLeftX;
  }
  function Bo(g, w) {
    ot[g].mediaBox.topRightX = w + ot[g].mediaBox.bottomLeftX;
  }
  function Uo(g) {
    return ot[g].mediaBox.topRightY - ot[g].mediaBox.bottomLeftY;
  }
  function di(g, w) {
    ot[g].mediaBox.topRightY = w + ot[g].mediaBox.bottomLeftY;
  }
  var pi = d.getPageWidth = function(g) {
    return Ls(g = g || T) / qe;
  }, Ho = d.setPageWidth = function(g, w) {
    Bo(g, w * qe);
  }, ca = d.getPageHeight = function(g) {
    return Uo(g = g || T) / qe;
  }, jo = d.setPageHeight = function(g, w) {
    di(g, w * qe);
  };
  return d.internal = { pdfEscape: yr, getStyle: Ro, getFont: cl, getFontSize: Ye, getCharSpace: El, getTextColor: bl, getLineHeight: hl, getLineHeightFactor: pl, getLineWidth: fl, write: Ue, getHorizontalCoordinate: li, getVerticalCoordinate: ci, getCoordinateString: ml, getVerticalCoordinateString: gl, collections: {}, newObject: nn, newAdditionalObject: ra, newObjectDeferred: vn, newObjectDeferredBegin: Cn, getFilters: Cr, putStream: Er, events: Mt, scaleFactor: qe, pageSize: { getWidth: function() {
    return pi(T);
  }, setWidth: function(g) {
    Ho(T, g);
  }, getHeight: function() {
    return ca(T);
  }, setHeight: function(g) {
    jo(T, g);
  } }, encryptionOptions: f, encryption: yn, getEncryptor: function(g) {
    return f !== null ? yn.encryptor(g, 0) : function(w) {
      return w;
    };
  }, output: Po, getNumberOfPages: ko, get pages() {
    return Ie;
  }, out: F, f2: N, f3: I, getPageInfo: ui, getPageInfoByObjId: Oo, getCurrentPageInfo: al, getPDFVersion: v, Point: hi, Rectangle: vs, Matrix: ut, hasHotfix: Tr }, Object.defineProperty(d.internal.pageSize, "width", { get: function() {
    return pi(T);
  }, set: function(g) {
    Ho(T, g);
  }, enumerable: !0, configurable: !0 }), Object.defineProperty(d.internal.pageSize, "height", { get: function() {
    return ca(T);
  }, set: function(g) {
    jo(T, g);
  }, enumerable: !0, configurable: !0 }), (function(g) {
    for (var w = 0, q = at.length; w < q; w++) {
      var Q = vo.call(this, g[w][0], g[w][1], g[w][2], at[w][3], !0);
      p === !1 && (E[Q] = !0);
      var ae = g[w][0].split("-");
      No({ id: Q, fontName: ae[0], fontStyle: ae[1] || "" });
    }
    Mt.publish("addFonts", { fonts: ht, dictionary: dt });
  }).call(d, at), Re = "F1", So(i, n), Mt.publish("initialized"), d;
}
es.prototype.lsbFirstWord = function(e) {
  return String.fromCharCode(255 & e, e >> 8 & 255, e >> 16 & 255, e >> 24 & 255);
}, es.prototype.toHexString = function(e) {
  return e.split("").map(function(t) {
    return ("0" + (255 & t.charCodeAt(0)).toString(16)).slice(-2);
  }).join("");
}, es.prototype.hexToBytes = function(e) {
  for (var t = [], n = 0; n < e.length; n += 2) t.push(String.fromCharCode(parseInt(e.substr(n, 2), 16)));
  return t.join("");
}, es.prototype.processOwnerPassword = function(e, t) {
  return Gc(Vc(t).substr(0, 5), e);
}, es.prototype.encryptor = function(e, t) {
  var n = Vc(this.encryptionKey + String.fromCharCode(255 & e, e >> 8 & 255, e >> 16 & 255, 255 & t, t >> 8 & 255)).substr(0, 10);
  return function(r) {
    return Gc(n, r);
  };
}, Hu.prototype.equals = function(e) {
  var t, n = "id,objectNumber,equals";
  if (!e || qt(e) !== qt(this)) return !1;
  var r = 0;
  for (t in this) if (!(n.indexOf(t) >= 0)) {
    if (this.hasOwnProperty(t) && !e.hasOwnProperty(t) || this[t] !== e[t]) return !1;
    r++;
  }
  for (t in e) e.hasOwnProperty(t) && n.indexOf(t) < 0 && r--;
  return r === 0;
}, et.API = { events: [] }, et.version = "4.0.0";
var sn = et.API, vf = 1, Pa = function(e) {
  return e.replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
}, Qa = function(e) {
  return e.replace(/\\\\/g, "\\").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}, mt = function(e) {
  return e.toFixed(2);
}, Gi = function(e) {
  return e.toFixed(5);
};
sn.__acroform__ = {};
var nr = function(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e;
}, vd = function(e) {
  return e * vf;
}, Jr = function(e) {
  var t = new kp(), n = Ve.internal.getHeight(e) || 0, r = Ve.internal.getWidth(e) || 0;
  return t.BBox = [0, 0, Number(mt(r)), Number(mt(n))], t;
}, $x = sn.__acroform__.setBit = function(e, t) {
  if (e = e || 0, t = t || 0, isNaN(e) || isNaN(t)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBit");
  return e | 1 << t;
}, Xx = sn.__acroform__.clearBit = function(e, t) {
  if (e = e || 0, t = t || 0, isNaN(e) || isNaN(t)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBit");
  return e & ~(1 << t);
}, Kx = sn.__acroform__.getBit = function(e, t) {
  if (isNaN(e) || isNaN(t)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBit");
  return e & 1 << t ? 1 : 0;
}, fn = sn.__acroform__.getBitForPdf = function(e, t) {
  if (isNaN(e) || isNaN(t)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBitForPdf");
  return Kx(e, t - 1);
}, hn = sn.__acroform__.setBitForPdf = function(e, t) {
  if (isNaN(e) || isNaN(t)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBitForPdf");
  return $x(e, t - 1);
}, dn = sn.__acroform__.clearBitForPdf = function(e, t) {
  if (isNaN(e) || isNaN(t)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBitForPdf");
  return Xx(e, t - 1);
}, Qx = sn.__acroform__.calculateCoordinates = function(e, t) {
  var n = t.internal.getHorizontalCoordinate, r = t.internal.getVerticalCoordinate, i = e[0], a = e[1], s = e[2], o = e[3], u = {};
  return u.lowerLeft_X = n(i) || 0, u.lowerLeft_Y = r(a + o) || 0, u.upperRight_X = n(i + s) || 0, u.upperRight_Y = r(a) || 0, [Number(mt(u.lowerLeft_X)), Number(mt(u.lowerLeft_Y)), Number(mt(u.upperRight_X)), Number(mt(u.upperRight_Y))];
}, Jx = function(e) {
  if (e.appearanceStreamContent) return e.appearanceStreamContent;
  if (e.V || e.DV) {
    var t = [], n = e._V || e.DV, r = $c(e, n), i = e.scope.internal.getFont(e.fontName, e.fontStyle).id;
    t.push("/Tx BMC"), t.push("q"), t.push("BT"), t.push(e.scope.__private__.encodeColorString(e.color)), t.push("/" + i + " " + mt(r.fontSize) + " Tf"), t.push("1 0 0 1 0 0 Tm"), t.push(r.text), t.push("ET"), t.push("Q"), t.push("EMC");
    var a = Jr(e);
    return a.scope = e.scope, a.stream = t.join(`
`), a;
  }
}, $c = function(e, t) {
  var n = e.fontSize === 0 ? e.maxFontSize : e.fontSize, r = { text: "", fontSize: "" }, i = (t = (t = t.substr(0, 1) == "(" ? t.substr(1) : t).substr(t.length - 1) == ")" ? t.substr(0, t.length - 1) : t).split(" ");
  i = e.multiline ? i.map(function(N) {
    return N.split(`
`);
  }) : i.map(function(N) {
    return [N];
  });
  var a = n, s = Ve.internal.getHeight(e) || 0;
  s = s < 0 ? -s : s;
  var o = Ve.internal.getWidth(e) || 0;
  o = o < 0 ? -o : o;
  var u = function(N, I, $) {
    if (N + 1 < i.length) {
      var Y = I + " " + i[N + 1][0];
      return Eu(Y, e, $).width <= o - 4;
    }
    return !1;
  };
  a++;
  e: for (; a > 0; ) {
    t = "", a--;
    var c, f, p = Eu("3", e, a).height, E = e.multiline ? s - a : (s - p) / 2, d = E += 2, A = 0, v = 0, C = 0;
    if (a <= 0) {
      t = `(...) Tj
`, t += "% Width of Text: " + Eu(t, e, a = 12).width + ", FieldWidth:" + o + `
`;
      break;
    }
    for (var _ = "", U = 0, B = 0; B < i.length; B++) if (i.hasOwnProperty(B)) {
      var V = !1;
      if (i[B].length !== 1 && C !== i[B].length - 1) {
        if ((p + 2) * (U + 2) + 2 > s) continue e;
        _ += i[B][C], V = !0, v = B, B--;
      } else {
        _ = (_ += i[B][C] + " ").substr(_.length - 1) == " " ? _.substr(0, _.length - 1) : _;
        var ie = parseInt(B), K = u(ie, _, a), fe = B >= i.length - 1;
        if (K && !fe) {
          _ += " ", C = 0;
          continue;
        }
        if (K || fe) {
          if (fe) v = ie;
          else if (e.multiline && (p + 2) * (U + 2) + 2 > s) continue e;
        } else {
          if (!e.multiline || (p + 2) * (U + 2) + 2 > s) continue e;
          v = ie;
        }
      }
      for (var Z = "", z = A; z <= v; z++) {
        var D = i[z];
        if (e.multiline) {
          if (z === v) {
            Z += D[C] + " ", C = (C + 1) % D.length;
            continue;
          }
          if (z === A) {
            Z += D[D.length - 1] + " ";
            continue;
          }
        }
        Z += D[0] + " ";
      }
      switch (Z = Z.substr(Z.length - 1) == " " ? Z.substr(0, Z.length - 1) : Z, f = Eu(Z, e, a).width, e.textAlign) {
        case "right":
          c = o - f - 2;
          break;
        case "center":
          c = (o - f) / 2;
          break;
        default:
          c = 2;
      }
      t += mt(c) + " " + mt(d) + ` Td
`, t += "(" + Pa(Z) + `) Tj
`, t += -mt(c) + ` 0 Td
`, d = -(a + 2), f = 0, A = V ? v : v + 1, U++, _ = "";
    }
    break;
  }
  return r.text = t, r.fontSize = a, r;
}, Eu = function(e, t, n) {
  var r = t.scope.internal.getFont(t.fontName, t.fontStyle), i = t.scope.getStringUnitWidth(e, { font: r, fontSize: parseFloat(n), charSpace: 0 }) * parseFloat(n);
  return { height: t.scope.getStringUnitWidth("3", { font: r, fontSize: parseFloat(n), charSpace: 0 }) * parseFloat(n) * 1.5, width: i };
}, Zx = { fields: [], xForms: [], acroFormDictionaryRoot: null, printedOut: !1, internal: null, isInitialized: !1 }, e8 = function(e, t) {
  var n = { type: "reference", object: e };
  t.internal.getPageInfo(e.page).pageContext.annotations.find(function(r) {
    return r.type === n.type && r.object === n.object;
  }) === void 0 && t.internal.getPageInfo(e.page).pageContext.annotations.push(n);
}, t8 = function(e, t) {
  if (t.scope = e, e.internal !== void 0 && (e.internal.acroformPlugin === void 0 || e.internal.acroformPlugin.isInitialized === !1)) {
    if (Hr.FieldNum = 0, e.internal.acroformPlugin = JSON.parse(JSON.stringify(Zx)), e.internal.acroformPlugin.acroFormDictionaryRoot) throw new Error("Exception while creating AcroformDictionary");
    vf = e.internal.scaleFactor, e.internal.acroformPlugin.acroFormDictionaryRoot = new Cp(), e.internal.acroformPlugin.acroFormDictionaryRoot.scope = e, e.internal.acroformPlugin.acroFormDictionaryRoot._eventID = e.internal.events.subscribe("postPutResources", function() {
      (function(n) {
        n.internal.events.unsubscribe(n.internal.acroformPlugin.acroFormDictionaryRoot._eventID), delete n.internal.acroformPlugin.acroFormDictionaryRoot._eventID, n.internal.acroformPlugin.printedOut = !0;
      })(e);
    }), e.internal.events.subscribe("buildDocument", function() {
      (function(n) {
        n.internal.acroformPlugin.acroFormDictionaryRoot.objId = void 0;
        var r = n.internal.acroformPlugin.acroFormDictionaryRoot.Fields;
        for (var i in r) if (r.hasOwnProperty(i)) {
          var a = r[i];
          a.objId = void 0, a.hasAnnotation && e8(a, n);
        }
      })(e);
    }), e.internal.events.subscribe("putCatalog", function() {
      (function(n) {
        if (n.internal.acroformPlugin.acroFormDictionaryRoot === void 0) throw new Error("putCatalogCallback: Root missing.");
        n.internal.write("/AcroForm " + n.internal.acroformPlugin.acroFormDictionaryRoot.objId + " 0 R");
      })(e);
    }), e.internal.events.subscribe("postPutPages", function(n) {
      (function(r, i) {
        var a = !r;
        for (var s in r || (i.internal.newObjectDeferredBegin(i.internal.acroformPlugin.acroFormDictionaryRoot.objId, !0), i.internal.acroformPlugin.acroFormDictionaryRoot.putStream()), r = r || i.internal.acroformPlugin.acroFormDictionaryRoot.Kids) if (r.hasOwnProperty(s)) {
          var o = r[s], u = [], c = o.Rect;
          if (o.Rect && (o.Rect = Qx(o.Rect, i)), i.internal.newObjectDeferredBegin(o.objId, !0), o.DA = Ve.createDefaultAppearanceStream(o), qt(o) === "object" && typeof o.getKeyValueListForStream == "function" && (u = o.getKeyValueListForStream()), o.Rect = c, o.hasAppearanceStream && !o.appearanceStreamContent) {
            var f = Jx(o);
            u.push({ key: "AP", value: "<</N " + f + ">>" }), i.internal.acroformPlugin.xForms.push(f);
          }
          if (o.appearanceStreamContent) {
            var p = "";
            for (var E in o.appearanceStreamContent) if (o.appearanceStreamContent.hasOwnProperty(E)) {
              var d = o.appearanceStreamContent[E];
              if (p += "/" + E + " ", p += "<<", Object.keys(d).length >= 1 || Array.isArray(d)) {
                for (var s in d) if (d.hasOwnProperty(s)) {
                  var A = d[s];
                  typeof A == "function" && (A = A.call(i, o)), p += "/" + s + " " + A + " ", i.internal.acroformPlugin.xForms.indexOf(A) >= 0 || i.internal.acroformPlugin.xForms.push(A);
                }
              } else typeof (A = d) == "function" && (A = A.call(i, o)), p += "/" + s + " " + A, i.internal.acroformPlugin.xForms.indexOf(A) >= 0 || i.internal.acroformPlugin.xForms.push(A);
              p += ">>";
            }
            u.push({ key: "AP", value: `<<
` + p + ">>" });
          }
          i.internal.putStream({ additionalKeyValues: u, objectId: o.objId }), i.internal.out("endobj");
        }
        a && (function(v, C) {
          for (var _ in v) if (v.hasOwnProperty(_)) {
            var U = _, B = v[_];
            C.internal.newObjectDeferredBegin(B.objId, !0), qt(B) === "object" && typeof B.putStream == "function" && B.putStream(), delete v[U];
          }
        })(i.internal.acroformPlugin.xForms, i);
      })(n, e);
    }), e.internal.acroformPlugin.isInitialized = !0;
  }
}, Lp = sn.__acroform__.arrayToPdfArray = function(e, t, n) {
  var r = function(s) {
    return s;
  };
  if (Array.isArray(e)) {
    for (var i = "[", a = 0; a < e.length; a++) switch (a !== 0 && (i += " "), qt(e[a])) {
      case "boolean":
      case "number":
      case "object":
        i += e[a].toString();
        break;
      case "string":
        e[a].substr(0, 1) !== "/" ? (t !== void 0 && n && (r = n.internal.getEncryptor(t)), i += "(" + Pa(r(e[a].toString())) + ")") : i += e[a].toString();
    }
    return i + "]";
  }
  throw new Error("Invalid argument passed to jsPDF.__acroform__.arrayToPdfArray");
}, bc = function(e, t, n) {
  var r = function(i) {
    return i;
  };
  return t !== void 0 && n && (r = n.internal.getEncryptor(t)), (e = e || "").toString(), "(" + Pa(r(e)) + ")";
}, ti = function() {
  this._objId = void 0, this._scope = void 0, Object.defineProperty(this, "objId", { get: function() {
    if (this._objId === void 0) {
      if (this.scope === void 0) return;
      this._objId = this.scope.internal.newObjectDeferred();
    }
    return this._objId;
  }, set: function(e) {
    this._objId = e;
  } }), Object.defineProperty(this, "scope", { value: this._scope, writable: !0 });
};
ti.prototype.toString = function() {
  return this.objId + " 0 R";
}, ti.prototype.putStream = function() {
  var e = this.getKeyValueListForStream();
  this.scope.internal.putStream({ data: this.stream, additionalKeyValues: e, objectId: this.objId }), this.scope.internal.out("endobj");
}, ti.prototype.getKeyValueListForStream = function() {
  var e = [], t = Object.getOwnPropertyNames(this).filter(function(a) {
    return a != "content" && a != "appearanceStreamContent" && a != "scope" && a != "objId" && a.substring(0, 1) != "_";
  });
  for (var n in t) if (Object.getOwnPropertyDescriptor(this, t[n]).configurable === !1) {
    var r = t[n], i = this[r];
    i && (Array.isArray(i) ? e.push({ key: r, value: Lp(i, this.objId, this.scope) }) : i instanceof ti ? (i.scope = this.scope, e.push({ key: r, value: i.objId + " 0 R" })) : typeof i != "function" && e.push({ key: r, value: i }));
  }
  return e;
};
var kp = function() {
  ti.call(this), Object.defineProperty(this, "Type", { value: "/XObject", configurable: !1, writable: !0 }), Object.defineProperty(this, "Subtype", { value: "/Form", configurable: !1, writable: !0 }), Object.defineProperty(this, "FormType", { value: 1, configurable: !1, writable: !0 });
  var e, t = [];
  Object.defineProperty(this, "BBox", { configurable: !1, get: function() {
    return t;
  }, set: function(n) {
    t = n;
  } }), Object.defineProperty(this, "Resources", { value: "2 0 R", configurable: !1, writable: !0 }), Object.defineProperty(this, "stream", { enumerable: !1, configurable: !0, set: function(n) {
    e = n.trim();
  }, get: function() {
    return e || null;
  } });
};
nr(kp, ti);
var Cp = function() {
  ti.call(this);
  var e, t = [];
  Object.defineProperty(this, "Kids", { enumerable: !1, configurable: !0, get: function() {
    return t.length > 0 ? t : void 0;
  } }), Object.defineProperty(this, "Fields", { enumerable: !1, configurable: !1, get: function() {
    return t;
  } }), Object.defineProperty(this, "DA", { enumerable: !1, configurable: !1, get: function() {
    if (e) {
      var n = function(r) {
        return r;
      };
      return this.scope && (n = this.scope.internal.getEncryptor(this.objId)), "(" + Pa(n(e)) + ")";
    }
  }, set: function(n) {
    e = n;
  } });
};
nr(Cp, ti);
var Hr = function e() {
  ti.call(this);
  var t = 4;
  Object.defineProperty(this, "F", { enumerable: !1, configurable: !1, get: function() {
    return t;
  }, set: function(_) {
    if (isNaN(_)) throw new Error('Invalid value "' + _ + '" for attribute F supplied.');
    t = _;
  } }), Object.defineProperty(this, "showWhenPrinted", { enumerable: !0, configurable: !0, get: function() {
    return !!fn(t, 3);
  }, set: function(_) {
    _ ? this.F = hn(t, 3) : this.F = dn(t, 3);
  } });
  var n = 0;
  Object.defineProperty(this, "Ff", { enumerable: !1, configurable: !1, get: function() {
    return n;
  }, set: function(_) {
    if (isNaN(_)) throw new Error('Invalid value "' + _ + '" for attribute Ff supplied.');
    n = _;
  } });
  var r = [];
  Object.defineProperty(this, "Rect", { enumerable: !1, configurable: !1, get: function() {
    if (r.length !== 0) return r;
  }, set: function(_) {
    r = _ !== void 0 ? _ : [];
  } }), Object.defineProperty(this, "x", { enumerable: !0, configurable: !0, get: function() {
    return !r || isNaN(r[0]) ? 0 : r[0];
  }, set: function(_) {
    r[0] = _;
  } }), Object.defineProperty(this, "y", { enumerable: !0, configurable: !0, get: function() {
    return !r || isNaN(r[1]) ? 0 : r[1];
  }, set: function(_) {
    r[1] = _;
  } }), Object.defineProperty(this, "width", { enumerable: !0, configurable: !0, get: function() {
    return !r || isNaN(r[2]) ? 0 : r[2];
  }, set: function(_) {
    r[2] = _;
  } }), Object.defineProperty(this, "height", { enumerable: !0, configurable: !0, get: function() {
    return !r || isNaN(r[3]) ? 0 : r[3];
  }, set: function(_) {
    r[3] = _;
  } });
  var i = "";
  Object.defineProperty(this, "FT", { enumerable: !0, configurable: !1, get: function() {
    return i;
  }, set: function(_) {
    switch (_) {
      case "/Btn":
      case "/Tx":
      case "/Ch":
      case "/Sig":
        i = _;
        break;
      default:
        throw new Error('Invalid value "' + _ + '" for attribute FT supplied.');
    }
  } });
  var a = null;
  Object.defineProperty(this, "T", { enumerable: !0, configurable: !1, get: function() {
    if (!a || a.length < 1) {
      if (this instanceof ju) return;
      a = "FieldObject" + e.FieldNum++;
    }
    var _ = function(U) {
      return U;
    };
    return this.scope && (_ = this.scope.internal.getEncryptor(this.objId)), "(" + Pa(_(a)) + ")";
  }, set: function(_) {
    a = _.toString();
  } }), Object.defineProperty(this, "fieldName", { configurable: !0, enumerable: !0, get: function() {
    return a;
  }, set: function(_) {
    a = _;
  } });
  var s = "helvetica";
  Object.defineProperty(this, "fontName", { enumerable: !0, configurable: !0, get: function() {
    return s;
  }, set: function(_) {
    s = _;
  } });
  var o = "normal";
  Object.defineProperty(this, "fontStyle", { enumerable: !0, configurable: !0, get: function() {
    return o;
  }, set: function(_) {
    o = _;
  } });
  var u = 0;
  Object.defineProperty(this, "fontSize", { enumerable: !0, configurable: !0, get: function() {
    return u;
  }, set: function(_) {
    u = _;
  } });
  var c = void 0;
  Object.defineProperty(this, "maxFontSize", { enumerable: !0, configurable: !0, get: function() {
    return c === void 0 ? 50 / vf : c;
  }, set: function(_) {
    c = _;
  } });
  var f = "black";
  Object.defineProperty(this, "color", { enumerable: !0, configurable: !0, get: function() {
    return f;
  }, set: function(_) {
    f = _;
  } });
  var p = "/F1 0 Tf 0 g";
  Object.defineProperty(this, "DA", { enumerable: !0, configurable: !1, get: function() {
    if (!(!p || this instanceof ju || this instanceof Na)) return bc(p, this.objId, this.scope);
  }, set: function(_) {
    _ = _.toString(), p = _;
  } });
  var E = null;
  Object.defineProperty(this, "DV", { enumerable: !1, configurable: !1, get: function() {
    if (E) return this instanceof Ln == 0 ? bc(E, this.objId, this.scope) : E;
  }, set: function(_) {
    _ = _.toString(), E = this instanceof Ln == 0 ? _.substr(0, 1) === "(" ? Qa(_.substr(1, _.length - 2)) : Qa(_) : _;
  } }), Object.defineProperty(this, "defaultValue", { enumerable: !0, configurable: !0, get: function() {
    return this instanceof Ln == 1 ? Qa(E.substr(1, E.length - 1)) : E;
  }, set: function(_) {
    _ = _.toString(), E = this instanceof Ln == 1 ? "/" + _ : _;
  } });
  var d = null;
  Object.defineProperty(this, "_V", { enumerable: !1, configurable: !1, get: function() {
    if (d) return d;
  }, set: function(_) {
    this.V = _;
  } }), Object.defineProperty(this, "V", { enumerable: !1, configurable: !1, get: function() {
    if (d) return this instanceof Ln == 0 ? bc(d, this.objId, this.scope) : d;
  }, set: function(_) {
    _ = _.toString(), d = this instanceof Ln == 0 ? _.substr(0, 1) === "(" ? Qa(_.substr(1, _.length - 2)) : Qa(_) : _;
  } }), Object.defineProperty(this, "value", { enumerable: !0, configurable: !0, get: function() {
    return this instanceof Ln == 1 ? Qa(d.substr(1, d.length - 1)) : d;
  }, set: function(_) {
    _ = _.toString(), d = this instanceof Ln == 1 ? "/" + _ : _;
  } }), Object.defineProperty(this, "hasAnnotation", { enumerable: !0, configurable: !0, get: function() {
    return this.Rect;
  } }), Object.defineProperty(this, "Type", { enumerable: !0, configurable: !1, get: function() {
    return this.hasAnnotation ? "/Annot" : null;
  } }), Object.defineProperty(this, "Subtype", { enumerable: !0, configurable: !1, get: function() {
    return this.hasAnnotation ? "/Widget" : null;
  } });
  var A, v = !1;
  Object.defineProperty(this, "hasAppearanceStream", { enumerable: !0, configurable: !0, get: function() {
    return v;
  }, set: function(_) {
    _ = !!_, v = _;
  } }), Object.defineProperty(this, "page", { enumerable: !0, configurable: !0, get: function() {
    if (A) return A;
  }, set: function(_) {
    A = _;
  } }), Object.defineProperty(this, "readOnly", { enumerable: !0, configurable: !0, get: function() {
    return !!fn(this.Ff, 1);
  }, set: function(_) {
    _ ? this.Ff = hn(this.Ff, 1) : this.Ff = dn(this.Ff, 1);
  } }), Object.defineProperty(this, "required", { enumerable: !0, configurable: !0, get: function() {
    return !!fn(this.Ff, 2);
  }, set: function(_) {
    _ ? this.Ff = hn(this.Ff, 2) : this.Ff = dn(this.Ff, 2);
  } }), Object.defineProperty(this, "noExport", { enumerable: !0, configurable: !0, get: function() {
    return !!fn(this.Ff, 3);
  }, set: function(_) {
    _ ? this.Ff = hn(this.Ff, 3) : this.Ff = dn(this.Ff, 3);
  } });
  var C = null;
  Object.defineProperty(this, "Q", { enumerable: !0, configurable: !1, get: function() {
    if (C !== null) return C;
  }, set: function(_) {
    if ([0, 1, 2].indexOf(_) === -1) throw new Error('Invalid value "' + _ + '" for attribute Q supplied.');
    C = _;
  } }), Object.defineProperty(this, "textAlign", { get: function() {
    var _;
    switch (C) {
      case 0:
      default:
        _ = "left";
        break;
      case 1:
        _ = "center";
        break;
      case 2:
        _ = "right";
    }
    return _;
  }, configurable: !0, enumerable: !0, set: function(_) {
    switch (_) {
      case "right":
      case 2:
        C = 2;
        break;
      case "center":
      case 1:
        C = 1;
        break;
      default:
        C = 0;
    }
  } });
};
nr(Hr, ti);
var as = function() {
  Hr.call(this), this.FT = "/Ch", this.V = "()", this.fontName = "zapfdingbats";
  var e = 0;
  Object.defineProperty(this, "TI", { enumerable: !0, configurable: !1, get: function() {
    return e;
  }, set: function(n) {
    e = n;
  } }), Object.defineProperty(this, "topIndex", { enumerable: !0, configurable: !0, get: function() {
    return e;
  }, set: function(n) {
    e = n;
  } });
  var t = [];
  Object.defineProperty(this, "Opt", { enumerable: !0, configurable: !1, get: function() {
    return Lp(t, this.objId, this.scope);
  }, set: function(n) {
    var r, i;
    i = [], typeof (r = n) == "string" && (i = (function(a, s, o) {
      o || (o = 1);
      for (var u, c = []; u = s.exec(a); ) c.push(u[o]);
      return c;
    })(r, /\((.*?)\)/g)), t = i;
  } }), this.getOptions = function() {
    return t;
  }, this.setOptions = function(n) {
    t = n, this.sort && t.sort();
  }, this.addOption = function(n) {
    n = (n = n || "").toString(), t.push(n), this.sort && t.sort();
  }, this.removeOption = function(n, r) {
    for (r = r || !1, n = (n = n || "").toString(); t.indexOf(n) !== -1 && (t.splice(t.indexOf(n), 1), r !== !1); ) ;
  }, Object.defineProperty(this, "combo", { enumerable: !0, configurable: !0, get: function() {
    return !!fn(this.Ff, 18);
  }, set: function(n) {
    n ? this.Ff = hn(this.Ff, 18) : this.Ff = dn(this.Ff, 18);
  } }), Object.defineProperty(this, "edit", { enumerable: !0, configurable: !0, get: function() {
    return !!fn(this.Ff, 19);
  }, set: function(n) {
    this.combo === !0 && (n ? this.Ff = hn(this.Ff, 19) : this.Ff = dn(this.Ff, 19));
  } }), Object.defineProperty(this, "sort", { enumerable: !0, configurable: !0, get: function() {
    return !!fn(this.Ff, 20);
  }, set: function(n) {
    n ? (this.Ff = hn(this.Ff, 20), t.sort()) : this.Ff = dn(this.Ff, 20);
  } }), Object.defineProperty(this, "multiSelect", { enumerable: !0, configurable: !0, get: function() {
    return !!fn(this.Ff, 22);
  }, set: function(n) {
    n ? this.Ff = hn(this.Ff, 22) : this.Ff = dn(this.Ff, 22);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: !0, configurable: !0, get: function() {
    return !!fn(this.Ff, 23);
  }, set: function(n) {
    n ? this.Ff = hn(this.Ff, 23) : this.Ff = dn(this.Ff, 23);
  } }), Object.defineProperty(this, "commitOnSelChange", { enumerable: !0, configurable: !0, get: function() {
    return !!fn(this.Ff, 27);
  }, set: function(n) {
    n ? this.Ff = hn(this.Ff, 27) : this.Ff = dn(this.Ff, 27);
  } }), this.hasAppearanceStream = !1;
};
nr(as, Hr);
var ss = function() {
  as.call(this), this.fontName = "helvetica", this.combo = !1;
};
nr(ss, as);
var os = function() {
  ss.call(this), this.combo = !0;
};
nr(os, ss);
var vu = function() {
  os.call(this), this.edit = !0;
};
nr(vu, os);
var Ln = function() {
  Hr.call(this), this.FT = "/Btn", Object.defineProperty(this, "noToggleToOff", { enumerable: !0, configurable: !0, get: function() {
    return !!fn(this.Ff, 15);
  }, set: function(n) {
    n ? this.Ff = hn(this.Ff, 15) : this.Ff = dn(this.Ff, 15);
  } }), Object.defineProperty(this, "radio", { enumerable: !0, configurable: !0, get: function() {
    return !!fn(this.Ff, 16);
  }, set: function(n) {
    n ? this.Ff = hn(this.Ff, 16) : this.Ff = dn(this.Ff, 16);
  } }), Object.defineProperty(this, "pushButton", { enumerable: !0, configurable: !0, get: function() {
    return !!fn(this.Ff, 17);
  }, set: function(n) {
    n ? this.Ff = hn(this.Ff, 17) : this.Ff = dn(this.Ff, 17);
  } }), Object.defineProperty(this, "radioIsUnison", { enumerable: !0, configurable: !0, get: function() {
    return !!fn(this.Ff, 26);
  }, set: function(n) {
    n ? this.Ff = hn(this.Ff, 26) : this.Ff = dn(this.Ff, 26);
  } });
  var e, t = {};
  Object.defineProperty(this, "MK", { enumerable: !1, configurable: !1, get: function() {
    var n = function(a) {
      return a;
    };
    if (this.scope && (n = this.scope.internal.getEncryptor(this.objId)), Object.keys(t).length !== 0) {
      var r, i = [];
      for (r in i.push("<<"), t) i.push("/" + r + " (" + Pa(n(t[r])) + ")");
      return i.push(">>"), i.join(`
`);
    }
  }, set: function(n) {
    qt(n) === "object" && (t = n);
  } }), Object.defineProperty(this, "caption", { enumerable: !0, configurable: !0, get: function() {
    return t.CA || "";
  }, set: function(n) {
    typeof n == "string" && (t.CA = n);
  } }), Object.defineProperty(this, "AS", { enumerable: !1, configurable: !1, get: function() {
    return e;
  }, set: function(n) {
    e = n;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: !0, configurable: !0, get: function() {
    return e.substr(1, e.length - 1);
  }, set: function(n) {
    e = "/" + n;
  } });
};
nr(Ln, Hr);
var Su = function() {
  Ln.call(this), this.pushButton = !0;
};
nr(Su, Ln);
var us = function() {
  Ln.call(this), this.radio = !0, this.pushButton = !1;
  var e = [];
  Object.defineProperty(this, "Kids", { enumerable: !0, configurable: !1, get: function() {
    return e;
  }, set: function(t) {
    e = t !== void 0 ? t : [];
  } });
};
nr(us, Ln);
var ju = function() {
  var e, t;
  Hr.call(this), Object.defineProperty(this, "Parent", { enumerable: !1, configurable: !1, get: function() {
    return e;
  }, set: function(i) {
    e = i;
  } }), Object.defineProperty(this, "optionName", { enumerable: !1, configurable: !0, get: function() {
    return t;
  }, set: function(i) {
    t = i;
  } });
  var n, r = {};
  Object.defineProperty(this, "MK", { enumerable: !1, configurable: !1, get: function() {
    var i = function(o) {
      return o;
    };
    this.scope && (i = this.scope.internal.getEncryptor(this.objId));
    var a, s = [];
    for (a in s.push("<<"), r) s.push("/" + a + " (" + Pa(i(r[a])) + ")");
    return s.push(">>"), s.join(`
`);
  }, set: function(i) {
    qt(i) === "object" && (r = i);
  } }), Object.defineProperty(this, "caption", { enumerable: !0, configurable: !0, get: function() {
    return r.CA || "";
  }, set: function(i) {
    typeof i == "string" && (r.CA = i);
  } }), Object.defineProperty(this, "AS", { enumerable: !1, configurable: !1, get: function() {
    return n;
  }, set: function(i) {
    n = i;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: !0, configurable: !0, get: function() {
    return n.substr(1, n.length - 1);
  }, set: function(i) {
    n = "/" + i;
  } }), this.caption = "l", this.appearanceState = "Off", this._AppearanceType = Ve.RadioButton.Circle, this.appearanceStreamContent = this._AppearanceType.createAppearanceStream(this.optionName);
};
nr(ju, Hr), us.prototype.setAppearance = function(e) {
  if (!("createAppearanceStream" in e) || !("getCA" in e)) throw new Error("Couldn't assign Appearance to RadioButton. Appearance was Invalid!");
  for (var t in this.Kids) if (this.Kids.hasOwnProperty(t)) {
    var n = this.Kids[t];
    n.appearanceStreamContent = e.createAppearanceStream(n.optionName), n.caption = e.getCA();
  }
}, us.prototype.createOption = function(e) {
  var t = new ju();
  return t.Parent = this, t.optionName = e, this.Kids.push(t), n8.call(this.scope, t), t;
};
var Lu = function() {
  Ln.call(this), this.fontName = "zapfdingbats", this.caption = "3", this.appearanceState = "On", this.value = "On", this.textAlign = "center", this.appearanceStreamContent = Ve.CheckBox.createAppearanceStream();
};
nr(Lu, Ln);
var Na = function() {
  Hr.call(this), this.FT = "/Tx", Object.defineProperty(this, "multiline", { enumerable: !0, configurable: !0, get: function() {
    return !!fn(this.Ff, 13);
  }, set: function(t) {
    t ? this.Ff = hn(this.Ff, 13) : this.Ff = dn(this.Ff, 13);
  } }), Object.defineProperty(this, "fileSelect", { enumerable: !0, configurable: !0, get: function() {
    return !!fn(this.Ff, 21);
  }, set: function(t) {
    t ? this.Ff = hn(this.Ff, 21) : this.Ff = dn(this.Ff, 21);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: !0, configurable: !0, get: function() {
    return !!fn(this.Ff, 23);
  }, set: function(t) {
    t ? this.Ff = hn(this.Ff, 23) : this.Ff = dn(this.Ff, 23);
  } }), Object.defineProperty(this, "doNotScroll", { enumerable: !0, configurable: !0, get: function() {
    return !!fn(this.Ff, 24);
  }, set: function(t) {
    t ? this.Ff = hn(this.Ff, 24) : this.Ff = dn(this.Ff, 24);
  } }), Object.defineProperty(this, "comb", { enumerable: !0, configurable: !0, get: function() {
    return !!fn(this.Ff, 25);
  }, set: function(t) {
    t ? this.Ff = hn(this.Ff, 25) : this.Ff = dn(this.Ff, 25);
  } }), Object.defineProperty(this, "richText", { enumerable: !0, configurable: !0, get: function() {
    return !!fn(this.Ff, 26);
  }, set: function(t) {
    t ? this.Ff = hn(this.Ff, 26) : this.Ff = dn(this.Ff, 26);
  } });
  var e = null;
  Object.defineProperty(this, "MaxLen", { enumerable: !0, configurable: !1, get: function() {
    return e;
  }, set: function(t) {
    e = t;
  } }), Object.defineProperty(this, "maxLength", { enumerable: !0, configurable: !0, get: function() {
    return e;
  }, set: function(t) {
    Number.isInteger(t) && (e = t);
  } }), Object.defineProperty(this, "hasAppearanceStream", { enumerable: !0, configurable: !0, get: function() {
    return this.V || this.DV;
  } });
};
nr(Na, Hr);
var ku = function() {
  Na.call(this), Object.defineProperty(this, "password", { enumerable: !0, configurable: !0, get: function() {
    return !!fn(this.Ff, 14);
  }, set: function(e) {
    e ? this.Ff = hn(this.Ff, 14) : this.Ff = dn(this.Ff, 14);
  } }), this.password = !0;
};
nr(ku, Na);
var Ve = { CheckBox: { createAppearanceStream: function() {
  return { N: { On: Ve.CheckBox.YesNormal }, D: { On: Ve.CheckBox.YesPushDown, Off: Ve.CheckBox.OffPushDown } };
}, YesPushDown: function(e) {
  var t = Jr(e);
  t.scope = e.scope;
  var n = [], r = e.scope.internal.getFont(e.fontName, e.fontStyle).id, i = e.scope.__private__.encodeColorString(e.color), a = $c(e, e.caption);
  return n.push("0.749023 g"), n.push("0 0 " + mt(Ve.internal.getWidth(e)) + " " + mt(Ve.internal.getHeight(e)) + " re"), n.push("f"), n.push("BMC"), n.push("q"), n.push("0 0 1 rg"), n.push("/" + r + " " + mt(a.fontSize) + " Tf " + i), n.push("BT"), n.push(a.text), n.push("ET"), n.push("Q"), n.push("EMC"), t.stream = n.join(`
`), t;
}, YesNormal: function(e) {
  var t = Jr(e);
  t.scope = e.scope;
  var n = e.scope.internal.getFont(e.fontName, e.fontStyle).id, r = e.scope.__private__.encodeColorString(e.color), i = [], a = Ve.internal.getHeight(e), s = Ve.internal.getWidth(e), o = $c(e, e.caption);
  return i.push("1 g"), i.push("0 0 " + mt(s) + " " + mt(a) + " re"), i.push("f"), i.push("q"), i.push("0 0 1 rg"), i.push("0 0 " + mt(s - 1) + " " + mt(a - 1) + " re"), i.push("W"), i.push("n"), i.push("0 g"), i.push("BT"), i.push("/" + n + " " + mt(o.fontSize) + " Tf " + r), i.push(o.text), i.push("ET"), i.push("Q"), t.stream = i.join(`
`), t;
}, OffPushDown: function(e) {
  var t = Jr(e);
  t.scope = e.scope;
  var n = [];
  return n.push("0.749023 g"), n.push("0 0 " + mt(Ve.internal.getWidth(e)) + " " + mt(Ve.internal.getHeight(e)) + " re"), n.push("f"), t.stream = n.join(`
`), t;
} }, RadioButton: { Circle: { createAppearanceStream: function(e) {
  var t = { D: { Off: Ve.RadioButton.Circle.OffPushDown }, N: {} };
  return t.N[e] = Ve.RadioButton.Circle.YesNormal, t.D[e] = Ve.RadioButton.Circle.YesPushDown, t;
}, getCA: function() {
  return "l";
}, YesNormal: function(e) {
  var t = Jr(e);
  t.scope = e.scope;
  var n = [], r = Ve.internal.getWidth(e) <= Ve.internal.getHeight(e) ? Ve.internal.getWidth(e) / 4 : Ve.internal.getHeight(e) / 4;
  r = Number((0.9 * r).toFixed(5));
  var i = Ve.internal.Bezier_C, a = Number((r * i).toFixed(5));
  return n.push("q"), n.push("1 0 0 1 " + Gi(Ve.internal.getWidth(e) / 2) + " " + Gi(Ve.internal.getHeight(e) / 2) + " cm"), n.push(r + " 0 m"), n.push(r + " " + a + " " + a + " " + r + " 0 " + r + " c"), n.push("-" + a + " " + r + " -" + r + " " + a + " -" + r + " 0 c"), n.push("-" + r + " -" + a + " -" + a + " -" + r + " 0 -" + r + " c"), n.push(a + " -" + r + " " + r + " -" + a + " " + r + " 0 c"), n.push("f"), n.push("Q"), t.stream = n.join(`
`), t;
}, YesPushDown: function(e) {
  var t = Jr(e);
  t.scope = e.scope;
  var n = [], r = Ve.internal.getWidth(e) <= Ve.internal.getHeight(e) ? Ve.internal.getWidth(e) / 4 : Ve.internal.getHeight(e) / 4;
  r = Number((0.9 * r).toFixed(5));
  var i = Number((2 * r).toFixed(5)), a = Number((i * Ve.internal.Bezier_C).toFixed(5)), s = Number((r * Ve.internal.Bezier_C).toFixed(5));
  return n.push("0.749023 g"), n.push("q"), n.push("1 0 0 1 " + Gi(Ve.internal.getWidth(e) / 2) + " " + Gi(Ve.internal.getHeight(e) / 2) + " cm"), n.push(i + " 0 m"), n.push(i + " " + a + " " + a + " " + i + " 0 " + i + " c"), n.push("-" + a + " " + i + " -" + i + " " + a + " -" + i + " 0 c"), n.push("-" + i + " -" + a + " -" + a + " -" + i + " 0 -" + i + " c"), n.push(a + " -" + i + " " + i + " -" + a + " " + i + " 0 c"), n.push("f"), n.push("Q"), n.push("0 g"), n.push("q"), n.push("1 0 0 1 " + Gi(Ve.internal.getWidth(e) / 2) + " " + Gi(Ve.internal.getHeight(e) / 2) + " cm"), n.push(r + " 0 m"), n.push(r + " " + s + " " + s + " " + r + " 0 " + r + " c"), n.push("-" + s + " " + r + " -" + r + " " + s + " -" + r + " 0 c"), n.push("-" + r + " -" + s + " -" + s + " -" + r + " 0 -" + r + " c"), n.push(s + " -" + r + " " + r + " -" + s + " " + r + " 0 c"), n.push("f"), n.push("Q"), t.stream = n.join(`
`), t;
}, OffPushDown: function(e) {
  var t = Jr(e);
  t.scope = e.scope;
  var n = [], r = Ve.internal.getWidth(e) <= Ve.internal.getHeight(e) ? Ve.internal.getWidth(e) / 4 : Ve.internal.getHeight(e) / 4;
  r = Number((0.9 * r).toFixed(5));
  var i = Number((2 * r).toFixed(5)), a = Number((i * Ve.internal.Bezier_C).toFixed(5));
  return n.push("0.749023 g"), n.push("q"), n.push("1 0 0 1 " + Gi(Ve.internal.getWidth(e) / 2) + " " + Gi(Ve.internal.getHeight(e) / 2) + " cm"), n.push(i + " 0 m"), n.push(i + " " + a + " " + a + " " + i + " 0 " + i + " c"), n.push("-" + a + " " + i + " -" + i + " " + a + " -" + i + " 0 c"), n.push("-" + i + " -" + a + " -" + a + " -" + i + " 0 -" + i + " c"), n.push(a + " -" + i + " " + i + " -" + a + " " + i + " 0 c"), n.push("f"), n.push("Q"), t.stream = n.join(`
`), t;
} }, Cross: { createAppearanceStream: function(e) {
  var t = { D: { Off: Ve.RadioButton.Cross.OffPushDown }, N: {} };
  return t.N[e] = Ve.RadioButton.Cross.YesNormal, t.D[e] = Ve.RadioButton.Cross.YesPushDown, t;
}, getCA: function() {
  return "8";
}, YesNormal: function(e) {
  var t = Jr(e);
  t.scope = e.scope;
  var n = [], r = Ve.internal.calculateCross(e);
  return n.push("q"), n.push("1 1 " + mt(Ve.internal.getWidth(e) - 2) + " " + mt(Ve.internal.getHeight(e) - 2) + " re"), n.push("W"), n.push("n"), n.push(mt(r.x1.x) + " " + mt(r.x1.y) + " m"), n.push(mt(r.x2.x) + " " + mt(r.x2.y) + " l"), n.push(mt(r.x4.x) + " " + mt(r.x4.y) + " m"), n.push(mt(r.x3.x) + " " + mt(r.x3.y) + " l"), n.push("s"), n.push("Q"), t.stream = n.join(`
`), t;
}, YesPushDown: function(e) {
  var t = Jr(e);
  t.scope = e.scope;
  var n = Ve.internal.calculateCross(e), r = [];
  return r.push("0.749023 g"), r.push("0 0 " + mt(Ve.internal.getWidth(e)) + " " + mt(Ve.internal.getHeight(e)) + " re"), r.push("f"), r.push("q"), r.push("1 1 " + mt(Ve.internal.getWidth(e) - 2) + " " + mt(Ve.internal.getHeight(e) - 2) + " re"), r.push("W"), r.push("n"), r.push(mt(n.x1.x) + " " + mt(n.x1.y) + " m"), r.push(mt(n.x2.x) + " " + mt(n.x2.y) + " l"), r.push(mt(n.x4.x) + " " + mt(n.x4.y) + " m"), r.push(mt(n.x3.x) + " " + mt(n.x3.y) + " l"), r.push("s"), r.push("Q"), t.stream = r.join(`
`), t;
}, OffPushDown: function(e) {
  var t = Jr(e);
  t.scope = e.scope;
  var n = [];
  return n.push("0.749023 g"), n.push("0 0 " + mt(Ve.internal.getWidth(e)) + " " + mt(Ve.internal.getHeight(e)) + " re"), n.push("f"), t.stream = n.join(`
`), t;
} } }, createDefaultAppearanceStream: function(e) {
  var t = e.scope.internal.getFont(e.fontName, e.fontStyle).id, n = e.scope.__private__.encodeColorString(e.color);
  return "/" + t + " " + e.fontSize + " Tf " + n;
} };
Ve.internal = { Bezier_C: 0.551915024494, calculateCross: function(e) {
  var t = Ve.internal.getWidth(e), n = Ve.internal.getHeight(e), r = Math.min(t, n);
  return { x1: { x: (t - r) / 2, y: (n - r) / 2 + r }, x2: { x: (t - r) / 2 + r, y: (n - r) / 2 }, x3: { x: (t - r) / 2, y: (n - r) / 2 }, x4: { x: (t - r) / 2 + r, y: (n - r) / 2 + r } };
} }, Ve.internal.getWidth = function(e) {
  var t = 0;
  return qt(e) === "object" && (t = vd(e.Rect[2])), t;
}, Ve.internal.getHeight = function(e) {
  var t = 0;
  return qt(e) === "object" && (t = vd(e.Rect[3])), t;
};
var n8 = sn.addField = function(e) {
  if (t8(this, e), !(e instanceof Hr)) throw new Error("Invalid argument passed to jsPDF.addField.");
  var t;
  return (t = e).scope.internal.acroformPlugin.printedOut && (t.scope.internal.acroformPlugin.printedOut = !1, t.scope.internal.acroformPlugin.acroFormDictionaryRoot = null), t.scope.internal.acroformPlugin.acroFormDictionaryRoot.Fields.push(t), e.page = e.scope.internal.getCurrentPageInfo().pageNumber, this;
};
sn.AcroFormChoiceField = as, sn.AcroFormListBox = ss, sn.AcroFormComboBox = os, sn.AcroFormEditBox = vu, sn.AcroFormButton = Ln, sn.AcroFormPushButton = Su, sn.AcroFormRadioButton = us, sn.AcroFormCheckBox = Lu, sn.AcroFormTextField = Na, sn.AcroFormPasswordField = ku, sn.AcroFormAppearance = Ve, sn.AcroForm = { ChoiceField: as, ListBox: ss, ComboBox: os, EditBox: vu, Button: Ln, PushButton: Su, RadioButton: us, CheckBox: Lu, TextField: Na, PasswordField: ku, Appearance: Ve }, et.AcroForm = { ChoiceField: as, ListBox: ss, ComboBox: os, EditBox: vu, Button: Ln, PushButton: Su, RadioButton: us, CheckBox: Lu, TextField: Na, PasswordField: ku, Appearance: Ve };
et.AcroForm;
function Ip(e) {
  return e.reduce(function(t, n, r) {
    return t[n] = r, t;
  }, {});
}
(function(e) {
  var t = "addImage_";
  e.__addimage__ = {};
  var n = "UNKNOWN", r = { PNG: [[137, 80, 78, 71]], TIFF: [[77, 77, 0, 42], [73, 73, 42, 0]], JPEG: [[255, 216, 255, 224, void 0, void 0, 74, 70, 73, 70, 0], [255, 216, 255, 225, void 0, void 0, 69, 120, 105, 102, 0, 0], [255, 216, 255, 219], [255, 216, 255, 238]], JPEG2000: [[0, 0, 0, 12, 106, 80, 32, 32]], GIF87a: [[71, 73, 70, 56, 55, 97]], GIF89a: [[71, 73, 70, 56, 57, 97]], WEBP: [[82, 73, 70, 70, void 0, void 0, void 0, void 0, 87, 69, 66, 80]], BMP: [[66, 77], [66, 65], [67, 73], [67, 80], [73, 67], [80, 84]] }, i = e.__addimage__.getImageFileTypeByImageData = function(N, I) {
    var $, Y, J, ue, me, se = n;
    if ((I = I || n) === "RGBA" || N.data !== void 0 && N.data instanceof Uint8ClampedArray && "height" in N && "width" in N) return "RGBA";
    if (K(N)) for (me in r) for (J = r[me], $ = 0; $ < J.length; $ += 1) {
      for (ue = !0, Y = 0; Y < J[$].length; Y += 1) if (J[$][Y] !== void 0 && J[$][Y] !== N[Y]) {
        ue = !1;
        break;
      }
      if (ue === !0) {
        se = me;
        break;
      }
    }
    else for (me in r) for (J = r[me], $ = 0; $ < J.length; $ += 1) {
      for (ue = !0, Y = 0; Y < J[$].length; Y += 1) if (J[$][Y] !== void 0 && J[$][Y] !== N.charCodeAt(Y)) {
        ue = !1;
        break;
      }
      if (ue === !0) {
        se = me;
        break;
      }
    }
    return se === n && I !== n && (se = I), se;
  }, a = function N(I) {
    for (var $ = this.internal.write, Y = this.internal.putStream, J = (0, this.internal.getFilters)(); J.indexOf("FlateEncode") !== -1; ) J.splice(J.indexOf("FlateEncode"), 1);
    I.objectId = this.internal.newObject();
    var ue = [];
    if (ue.push({ key: "Type", value: "/XObject" }), ue.push({ key: "Subtype", value: "/Image" }), ue.push({ key: "Width", value: I.width }), ue.push({ key: "Height", value: I.height }), I.colorSpace === _.INDEXED ? ue.push({ key: "ColorSpace", value: "[/Indexed /DeviceRGB " + (I.palette.length / 3 - 1) + " " + ("sMask" in I && I.sMask !== void 0 ? I.objectId + 2 : I.objectId + 1) + " 0 R]" }) : (ue.push({ key: "ColorSpace", value: "/" + I.colorSpace }), I.colorSpace === _.DEVICE_CMYK && ue.push({ key: "Decode", value: "[1 0 1 0 1 0 1 0]" })), ue.push({ key: "BitsPerComponent", value: I.bitsPerComponent }), "decodeParameters" in I && I.decodeParameters !== void 0 && ue.push({ key: "DecodeParms", value: "<<" + I.decodeParameters + ">>" }), "transparency" in I && Array.isArray(I.transparency) && I.transparency.length > 0) {
      for (var me = "", se = 0, Ee = I.transparency.length; se < Ee; se++) me += I.transparency[se] + " " + I.transparency[se] + " ";
      ue.push({ key: "Mask", value: "[" + me + "]" });
    }
    I.sMask !== void 0 && ue.push({ key: "SMask", value: I.objectId + 1 + " 0 R" });
    var M = I.filter !== void 0 ? ["/" + I.filter] : void 0;
    if (Y({ data: I.data, additionalKeyValues: ue, alreadyAppliedFilters: M, objectId: I.objectId }), $("endobj"), "sMask" in I && I.sMask !== void 0) {
      var xe, L = (xe = I.sMaskBitsPerComponent) !== null && xe !== void 0 ? xe : I.bitsPerComponent, T = { width: I.width, height: I.height, colorSpace: "DeviceGray", bitsPerComponent: L, data: I.sMask };
      "filter" in I && (T.decodeParameters = "/Predictor ".concat(I.predictor, " /Colors 1 /BitsPerComponent ").concat(L, " /Columns ").concat(I.width), T.filter = I.filter), N.call(this, T);
    }
    if (I.colorSpace === _.INDEXED) {
      var G = this.internal.newObject();
      Y({ data: Z(new Uint8Array(I.palette)), objectId: G }), $("endobj");
    }
  }, s = function() {
    var N = this.internal.collections[t + "images"];
    for (var I in N) a.call(this, N[I]);
  }, o = function() {
    var N, I = this.internal.collections[t + "images"], $ = this.internal.write;
    for (var Y in I) $("/I" + (N = I[Y]).index, N.objectId, "0", "R");
  }, u = function() {
    this.internal.collections[t + "images"] || (this.internal.collections[t + "images"] = {}, this.internal.events.subscribe("putResources", s), this.internal.events.subscribe("putXobjectDict", o));
  }, c = function() {
    var N = this.internal.collections[t + "images"];
    return u.call(this), N;
  }, f = function() {
    return Object.keys(this.internal.collections[t + "images"]).length;
  }, p = function(N) {
    return typeof e["process" + N.toUpperCase()] == "function";
  }, E = function(N) {
    return qt(N) === "object" && N.nodeType === 1;
  }, d = function(N, I) {
    if (N.nodeName === "IMG" && N.hasAttribute("src")) {
      var $ = "" + N.getAttribute("src");
      if ($.indexOf("data:image/") === 0) return Nu(unescape($).split("base64,").pop());
      var Y = e.loadFile($, !0);
      if (Y !== void 0) return Y;
    }
    if (N.nodeName === "CANVAS") {
      if (N.width === 0 || N.height === 0) throw new Error("Given canvas must have data. Canvas width: " + N.width + ", height: " + N.height);
      var J;
      switch (I) {
        case "PNG":
          J = "image/png";
          break;
        case "WEBP":
          J = "image/webp";
          break;
        default:
          J = "image/jpeg";
      }
      return Nu(N.toDataURL(J, 1).split("base64,").pop());
    }
  }, A = function(N) {
    var I = this.internal.collections[t + "images"];
    if (I) {
      for (var $ in I) if (N === I[$].alias) return I[$];
    }
  }, v = function(N, I, $) {
    return N || I || (N = -96, I = -96), N < 0 && (N = -1 * $.width * 72 / N / this.internal.scaleFactor), I < 0 && (I = -1 * $.height * 72 / I / this.internal.scaleFactor), N === 0 && (N = I * $.width / $.height), I === 0 && (I = N * $.height / $.width), [N, I];
  }, C = function(N, I, $, Y, J, ue) {
    var me = v.call(this, $, Y, J), se = this.internal.getCoordinateString, Ee = this.internal.getVerticalCoordinateString, M = c.call(this);
    if ($ = me[0], Y = me[1], M[J.index] = J, ue) {
      ue *= Math.PI / 180;
      var xe = Math.cos(ue), L = Math.sin(ue), T = function(ee) {
        return ee.toFixed(4);
      }, G = [T(xe), T(L), T(-1 * L), T(xe), 0, 0, "cm"];
    }
    this.internal.write("q"), ue ? (this.internal.write([1, "0", "0", 1, se(N), Ee(I + Y), "cm"].join(" ")), this.internal.write(G.join(" ")), this.internal.write([se($), "0", "0", se(Y), "0", "0", "cm"].join(" "))) : this.internal.write([se($), "0", "0", se(Y), se(N), Ee(I + Y), "cm"].join(" ")), this.isAdvancedAPI() && this.internal.write([1, 0, 0, -1, 0, 0, "cm"].join(" ")), this.internal.write("/I" + J.index + " Do"), this.internal.write("Q");
  }, _ = e.color_spaces = { DEVICE_RGB: "DeviceRGB", DEVICE_GRAY: "DeviceGray", DEVICE_CMYK: "DeviceCMYK", CAL_GREY: "CalGray", CAL_RGB: "CalRGB", LAB: "Lab", ICC_BASED: "ICCBased", INDEXED: "Indexed", PATTERN: "Pattern", SEPARATION: "Separation", DEVICE_N: "DeviceN" };
  e.decode = { DCT_DECODE: "DCTDecode", FLATE_DECODE: "FlateDecode", LZW_DECODE: "LZWDecode", JPX_DECODE: "JPXDecode", JBIG2_DECODE: "JBIG2Decode", ASCII85_DECODE: "ASCII85Decode", ASCII_HEX_DECODE: "ASCIIHexDecode", RUN_LENGTH_DECODE: "RunLengthDecode", CCITT_FAX_DECODE: "CCITTFaxDecode" };
  var U = e.image_compression = { NONE: "NONE", FAST: "FAST", MEDIUM: "MEDIUM", SLOW: "SLOW" }, B = e.__addimage__.sHashCode = function(N) {
    var I, $, Y = 0;
    if (typeof N == "string") for ($ = N.length, I = 0; I < $; I++) Y = (Y << 5) - Y + N.charCodeAt(I), Y |= 0;
    else if (K(N)) for ($ = N.byteLength / 2, I = 0; I < $; I++) Y = (Y << 5) - Y + N[I], Y |= 0;
    return Y;
  }, V = e.__addimage__.validateStringAsBase64 = function(N) {
    (N = N || "").toString().trim();
    var I = !0;
    return N.length === 0 && (I = !1), N.length % 4 != 0 && (I = !1), /^[A-Za-z0-9+/]+$/.test(N.substr(0, N.length - 2)) === !1 && (I = !1), /^[A-Za-z0-9/][A-Za-z0-9+/]|[A-Za-z0-9+/]=|==$/.test(N.substr(-2)) === !1 && (I = !1), I;
  }, ie = e.__addimage__.extractImageFromDataUrl = function(N) {
    if (N == null || !(N = N.trim()).startsWith("data:")) return null;
    var I = N.indexOf(",");
    return I < 0 ? null : N.substring(0, I).trim().endsWith("base64") ? N.substring(I + 1) : null;
  };
  e.__addimage__.isArrayBuffer = function(N) {
    return N instanceof ArrayBuffer;
  };
  var K = e.__addimage__.isArrayBufferView = function(N) {
    return N instanceof Int8Array || N instanceof Uint8Array || N instanceof Uint8ClampedArray || N instanceof Int16Array || N instanceof Uint16Array || N instanceof Int32Array || N instanceof Uint32Array || N instanceof Float32Array || N instanceof Float64Array;
  }, fe = e.__addimage__.binaryStringToUint8Array = function(N) {
    for (var I = N.length, $ = new Uint8Array(I), Y = 0; Y < I; Y++) $[Y] = N.charCodeAt(Y);
    return $;
  }, Z = e.__addimage__.arrayBufferToBinaryString = function(N) {
    for (var I = "", $ = K(N) ? N : new Uint8Array(N), Y = 0; Y < $.length; Y += 8192) I += String.fromCharCode.apply(null, $.subarray(Y, Y + 8192));
    return I;
  };
  e.addImage = function() {
    var N, I, $, Y, J, ue, me, se, Ee;
    if (typeof arguments[1] == "number" ? (I = n, $ = arguments[1], Y = arguments[2], J = arguments[3], ue = arguments[4], me = arguments[5], se = arguments[6], Ee = arguments[7]) : (I = arguments[1], $ = arguments[2], Y = arguments[3], J = arguments[4], ue = arguments[5], me = arguments[6], se = arguments[7], Ee = arguments[8]), qt(N = arguments[0]) === "object" && !E(N) && "imageData" in N) {
      var M = N;
      N = M.imageData, I = M.format || I || n, $ = M.x || $ || 0, Y = M.y || Y || 0, J = M.w || M.width || J, ue = M.h || M.height || ue, me = M.alias || me, se = M.compression || se, Ee = M.rotation || M.angle || Ee;
    }
    var xe = this.internal.getFilters();
    if (se === void 0 && xe.indexOf("FlateEncode") !== -1 && (se = "SLOW"), isNaN($) || isNaN(Y)) throw new Error("Invalid coordinates passed to jsPDF.addImage");
    u.call(this);
    var L = z.call(this, N, I, me, se);
    return C.call(this, $, Y, J, ue, L, Ee), this;
  };
  var z = function(N, I, $, Y) {
    var J, ue, me;
    if (typeof N == "string" && i(N) === n) {
      N = unescape(N);
      var se = D(N, !1);
      (se !== "" || (se = e.loadFile(N, !0)) !== void 0) && (N = se);
    }
    if (E(N) && (N = d(N, I)), I = i(N, I), !p(I)) throw new Error("addImage does not support files of type '" + I + "', please ensure that a plugin for '" + I + "' support is added.");
    if (((me = $) == null || me.length === 0) && ($ = (function(Ee) {
      return typeof Ee == "string" || K(Ee) ? B(Ee) : K(Ee.data) ? B(Ee.data) : null;
    })(N)), (J = A.call(this, $)) || (N instanceof Uint8Array || I === "RGBA" || (ue = N, N = fe(N)), J = this["process" + I.toUpperCase()](N, f.call(this), $, (function(Ee) {
      return Ee && typeof Ee == "string" && (Ee = Ee.toUpperCase()), Ee in e.image_compression ? Ee : U.NONE;
    })(Y), ue)), !J) throw new Error("An unknown error occurred whilst processing the image.");
    return J;
  }, D = e.__addimage__.convertBase64ToBinaryString = function(N, I) {
    I = typeof I != "boolean" || I;
    var $, Y = "";
    if (typeof N == "string") {
      var J;
      $ = (J = ie(N)) !== null && J !== void 0 ? J : N;
      try {
        Y = Nu($);
      } catch (ue) {
        if (I) throw V($) ? new Error("atob-Error in jsPDF.convertBase64ToBinaryString " + ue.message) : new Error("Supplied Data is not a valid base64-String jsPDF.convertBase64ToBinaryString ");
      }
    }
    return Y;
  };
  e.getImageProperties = function(N) {
    var I, $, Y = "";
    if (E(N) && (N = d(N)), typeof N == "string" && i(N) === n && ((Y = D(N, !1)) === "" && (Y = e.loadFile(N) || ""), N = Y), $ = i(N), !p($)) throw new Error("addImage does not support files of type '" + $ + "', please ensure that a plugin for '" + $ + "' support is added.");
    if (N instanceof Uint8Array || (N = fe(N)), !(I = this["process" + $.toUpperCase()](N))) throw new Error("An unknown error occurred whilst processing the image");
    return I.fileType = $, I;
  };
})(et.API), /**
 * @license
 * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
(function(e) {
  var t = function(n) {
    if (n !== void 0 && n != "") return !0;
  };
  et.API.events.push(["addPage", function(n) {
    this.internal.getPageInfo(n.pageNumber).pageContext.annotations = [];
  }]), e.events.push(["putPage", function(n) {
    for (var r, i, a, s = this.internal.getCoordinateString, o = this.internal.getVerticalCoordinateString, u = this.internal.getPageInfoByObjId(n.objId), c = n.pageContext.annotations, f = !1, p = 0; p < c.length && !f; p++) switch ((r = c[p]).type) {
      case "link":
        (t(r.options.url) || t(r.options.pageNumber)) && (f = !0);
        break;
      case "reference":
      case "text":
      case "freetext":
        f = !0;
    }
    if (f != 0) {
      this.internal.write("/Annots [");
      for (var E = 0; E < c.length; E++) {
        r = c[E];
        var d = this.internal.pdfEscape, A = this.internal.getEncryptor(n.objId);
        switch (r.type) {
          case "reference":
            this.internal.write(" " + r.object.objId + " 0 R ");
            break;
          case "text":
            var v = this.internal.newAdditionalObject(), C = this.internal.newAdditionalObject(), _ = this.internal.getEncryptor(v.objId), U = r.title || "Note";
            a = "<</Type /Annot /Subtype /Text " + (i = "/Rect [" + s(r.bounds.x) + " " + o(r.bounds.y + r.bounds.h) + " " + s(r.bounds.x + r.bounds.w) + " " + o(r.bounds.y) + "] ") + "/Contents (" + d(_(r.contents)) + ")", a += " /Popup " + C.objId + " 0 R", a += " /P " + u.objId + " 0 R", a += " /T (" + d(_(U)) + ") >>", v.content = a;
            var B = v.objId + " 0 R";
            a = "<</Type /Annot /Subtype /Popup " + (i = "/Rect [" + s(r.bounds.x + 30) + " " + o(r.bounds.y + r.bounds.h) + " " + s(r.bounds.x + r.bounds.w + 30) + " " + o(r.bounds.y) + "] ") + " /Parent " + B, r.open && (a += " /Open true"), a += " >>", C.content = a, this.internal.write(v.objId, "0 R", C.objId, "0 R");
            break;
          case "freetext":
            i = "/Rect [" + s(r.bounds.x) + " " + o(r.bounds.y) + " " + s(r.bounds.x + r.bounds.w) + " " + o(r.bounds.y + r.bounds.h) + "] ";
            var V = r.color || "#000000";
            a = "<</Type /Annot /Subtype /FreeText " + i + "/Contents (" + d(A(r.contents)) + ")", a += " /DS(font: Helvetica,sans-serif 12.0pt; text-align:left; color:#" + V + ")", a += " /Border [0 0 0]", a += " >>", this.internal.write(a);
            break;
          case "link":
            if (r.options.name) {
              var ie = this.annotations._nameMap[r.options.name];
              r.options.pageNumber = ie.page, r.options.top = ie.y;
            } else r.options.top || (r.options.top = 0);
            if (i = "/Rect [" + r.finalBounds.x + " " + r.finalBounds.y + " " + r.finalBounds.w + " " + r.finalBounds.h + "] ", a = "", r.options.url) a = "<</Type /Annot /Subtype /Link " + i + "/Border [0 0 0] /A <</S /URI /URI (" + d(A(r.options.url)) + ") >>";
            else if (r.options.pageNumber) switch (a = "<</Type /Annot /Subtype /Link " + i + "/Border [0 0 0] /Dest [" + this.internal.getPageInfo(r.options.pageNumber).objId + " 0 R", r.options.magFactor = r.options.magFactor || "XYZ", r.options.magFactor) {
              case "Fit":
                a += " /Fit]";
                break;
              case "FitH":
                a += " /FitH " + r.options.top + "]";
                break;
              case "FitV":
                r.options.left = r.options.left || 0, a += " /FitV " + r.options.left + "]";
                break;
              default:
                var K = o(r.options.top);
                r.options.left = r.options.left || 0, r.options.zoom === void 0 && (r.options.zoom = 0), a += " /XYZ " + r.options.left + " " + K + " " + r.options.zoom + "]";
            }
            a != "" && (a += " >>", this.internal.write(a));
        }
      }
      this.internal.write("]");
    }
  }]), e.createAnnotation = function(n) {
    var r = this.internal.getCurrentPageInfo();
    switch (n.type) {
      case "link":
        this.link(n.bounds.x, n.bounds.y, n.bounds.w, n.bounds.h, n);
        break;
      case "text":
      case "freetext":
        r.pageContext.annotations.push(n);
    }
  }, e.link = function(n, r, i, a, s) {
    var o = this.internal.getCurrentPageInfo(), u = this.internal.getCoordinateString, c = this.internal.getVerticalCoordinateString;
    o.pageContext.annotations.push({ finalBounds: { x: u(n), y: c(r), w: u(n + i), h: c(r + a) }, options: s, type: "link" });
  }, e.textWithLink = function(n, r, i, a) {
    var s, o, u = this.getTextWidth(n), c = this.internal.getLineHeight() / this.internal.scaleFactor;
    if (a.maxWidth !== void 0) {
      o = a.maxWidth;
      var f = this.splitTextToSize(n, o).length;
      s = Math.ceil(c * f);
    } else o = u, s = c;
    return this.text(n, r, i, a), i += 0.2 * c, a.align === "center" && (r -= u / 2), a.align === "right" && (r -= u), this.link(r, i - c, o, s, a), u;
  }, e.getTextWidth = function(n) {
    var r = this.internal.getFontSize();
    return this.getStringUnitWidth(n) * r / this.internal.scaleFactor;
  };
})(et.API), /**
 * @license
 * Copyright (c) 2017 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
(function(e) {
  var t = { 1569: [65152], 1570: [65153, 65154], 1571: [65155, 65156], 1572: [65157, 65158], 1573: [65159, 65160], 1574: [65161, 65162, 65163, 65164], 1575: [65165, 65166], 1576: [65167, 65168, 65169, 65170], 1577: [65171, 65172], 1578: [65173, 65174, 65175, 65176], 1579: [65177, 65178, 65179, 65180], 1580: [65181, 65182, 65183, 65184], 1581: [65185, 65186, 65187, 65188], 1582: [65189, 65190, 65191, 65192], 1583: [65193, 65194], 1584: [65195, 65196], 1585: [65197, 65198], 1586: [65199, 65200], 1587: [65201, 65202, 65203, 65204], 1588: [65205, 65206, 65207, 65208], 1589: [65209, 65210, 65211, 65212], 1590: [65213, 65214, 65215, 65216], 1591: [65217, 65218, 65219, 65220], 1592: [65221, 65222, 65223, 65224], 1593: [65225, 65226, 65227, 65228], 1594: [65229, 65230, 65231, 65232], 1601: [65233, 65234, 65235, 65236], 1602: [65237, 65238, 65239, 65240], 1603: [65241, 65242, 65243, 65244], 1604: [65245, 65246, 65247, 65248], 1605: [65249, 65250, 65251, 65252], 1606: [65253, 65254, 65255, 65256], 1607: [65257, 65258, 65259, 65260], 1608: [65261, 65262], 1609: [65263, 65264, 64488, 64489], 1610: [65265, 65266, 65267, 65268], 1649: [64336, 64337], 1655: [64477], 1657: [64358, 64359, 64360, 64361], 1658: [64350, 64351, 64352, 64353], 1659: [64338, 64339, 64340, 64341], 1662: [64342, 64343, 64344, 64345], 1663: [64354, 64355, 64356, 64357], 1664: [64346, 64347, 64348, 64349], 1667: [64374, 64375, 64376, 64377], 1668: [64370, 64371, 64372, 64373], 1670: [64378, 64379, 64380, 64381], 1671: [64382, 64383, 64384, 64385], 1672: [64392, 64393], 1676: [64388, 64389], 1677: [64386, 64387], 1678: [64390, 64391], 1681: [64396, 64397], 1688: [64394, 64395], 1700: [64362, 64363, 64364, 64365], 1702: [64366, 64367, 64368, 64369], 1705: [64398, 64399, 64400, 64401], 1709: [64467, 64468, 64469, 64470], 1711: [64402, 64403, 64404, 64405], 1713: [64410, 64411, 64412, 64413], 1715: [64406, 64407, 64408, 64409], 1722: [64414, 64415], 1723: [64416, 64417, 64418, 64419], 1726: [64426, 64427, 64428, 64429], 1728: [64420, 64421], 1729: [64422, 64423, 64424, 64425], 1733: [64480, 64481], 1734: [64473, 64474], 1735: [64471, 64472], 1736: [64475, 64476], 1737: [64482, 64483], 1739: [64478, 64479], 1740: [64508, 64509, 64510, 64511], 1744: [64484, 64485, 64486, 64487], 1746: [64430, 64431], 1747: [64432, 64433] }, n = { 65247: { 65154: 65269, 65156: 65271, 65160: 65273, 65166: 65275 }, 65248: { 65154: 65270, 65156: 65272, 65160: 65274, 65166: 65276 }, 65165: { 65247: { 65248: { 65258: 65010 } } }, 1617: { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 } }, r = { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 }, i = [1570, 1571, 1573, 1575];
  e.__arabicParser__ = {};
  var a = e.__arabicParser__.isInArabicSubstitutionA = function(v) {
    return t[v.charCodeAt(0)] !== void 0;
  }, s = e.__arabicParser__.isArabicLetter = function(v) {
    return typeof v == "string" && /^[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]+$/.test(v);
  }, o = e.__arabicParser__.isArabicEndLetter = function(v) {
    return s(v) && a(v) && t[v.charCodeAt(0)].length <= 2;
  }, u = e.__arabicParser__.isArabicAlfLetter = function(v) {
    return s(v) && i.indexOf(v.charCodeAt(0)) >= 0;
  };
  e.__arabicParser__.arabicLetterHasIsolatedForm = function(v) {
    return s(v) && a(v) && t[v.charCodeAt(0)].length >= 1;
  };
  var c = e.__arabicParser__.arabicLetterHasFinalForm = function(v) {
    return s(v) && a(v) && t[v.charCodeAt(0)].length >= 2;
  };
  e.__arabicParser__.arabicLetterHasInitialForm = function(v) {
    return s(v) && a(v) && t[v.charCodeAt(0)].length >= 3;
  };
  var f = e.__arabicParser__.arabicLetterHasMedialForm = function(v) {
    return s(v) && a(v) && t[v.charCodeAt(0)].length == 4;
  }, p = e.__arabicParser__.resolveLigatures = function(v) {
    var C = 0, _ = n, U = "", B = 0;
    for (C = 0; C < v.length; C += 1) _[v.charCodeAt(C)] !== void 0 ? (B++, typeof (_ = _[v.charCodeAt(C)]) == "number" && (U += String.fromCharCode(_), _ = n, B = 0), C === v.length - 1 && (_ = n, U += v.charAt(C - (B - 1)), C -= B - 1, B = 0)) : (_ = n, U += v.charAt(C - B), C -= B, B = 0);
    return U;
  };
  e.__arabicParser__.isArabicDiacritic = function(v) {
    return v !== void 0 && r[v.charCodeAt(0)] !== void 0;
  };
  var E = e.__arabicParser__.getCorrectForm = function(v, C, _) {
    return s(v) ? a(v) === !1 ? -1 : !c(v) || !s(C) && !s(_) || !s(_) && o(C) || o(v) && !s(C) || o(v) && u(C) || o(v) && o(C) ? 0 : f(v) && s(C) && !o(C) && s(_) && c(_) ? 3 : o(v) || !s(_) ? 1 : 2 : -1;
  }, d = function(v) {
    var C = 0, _ = 0, U = 0, B = "", V = "", ie = "", K = (v = v || "").split("\\s+"), fe = [];
    for (C = 0; C < K.length; C += 1) {
      for (fe.push(""), _ = 0; _ < K[C].length; _ += 1) B = K[C][_], V = K[C][_ - 1], ie = K[C][_ + 1], s(B) ? (U = E(B, V, ie), fe[C] += U !== -1 ? String.fromCharCode(t[B.charCodeAt(0)][U]) : B) : fe[C] += B;
      fe[C] = p(fe[C]);
    }
    return fe.join(" ");
  }, A = e.__arabicParser__.processArabic = e.processArabic = function() {
    var v, C = typeof arguments[0] == "string" ? arguments[0] : arguments[0].text, _ = [];
    if (Array.isArray(C)) {
      var U = 0;
      for (_ = [], U = 0; U < C.length; U += 1) Array.isArray(C[U]) ? _.push([d(C[U][0]), C[U][1], C[U][2]]) : _.push([d(C[U])]);
      v = _;
    } else v = d(C);
    return typeof arguments[0] == "string" ? v : (arguments[0].text = v, arguments[0]);
  };
  e.events.push(["preProcessText", A]);
})(et.API), et.API.autoPrint = function(e) {
  var t;
  return (e = e || {}).variant = e.variant || "non-conform", e.variant === "javascript" ? this.addJS("print({});") : (this.internal.events.subscribe("postPutResources", function() {
    t = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /Named"), this.internal.out("/Type /Action"), this.internal.out("/N /Print"), this.internal.out(">>"), this.internal.out("endobj");
  }), this.internal.events.subscribe("putCatalog", function() {
    this.internal.out("/OpenAction " + t + " 0 R");
  })), this;
}, /**
 * @license
 * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
(function(e) {
  var t = function() {
    var n = void 0;
    Object.defineProperty(this, "pdf", { get: function() {
      return n;
    }, set: function(o) {
      n = o;
    } });
    var r = 150;
    Object.defineProperty(this, "width", { get: function() {
      return r;
    }, set: function(o) {
      r = isNaN(o) || Number.isInteger(o) === !1 || o < 0 ? 150 : o, this.getContext("2d").pageWrapXEnabled && (this.getContext("2d").pageWrapX = r + 1);
    } });
    var i = 300;
    Object.defineProperty(this, "height", { get: function() {
      return i;
    }, set: function(o) {
      i = isNaN(o) || Number.isInteger(o) === !1 || o < 0 ? 300 : o, this.getContext("2d").pageWrapYEnabled && (this.getContext("2d").pageWrapY = i + 1);
    } });
    var a = [];
    Object.defineProperty(this, "childNodes", { get: function() {
      return a;
    }, set: function(o) {
      a = o;
    } });
    var s = {};
    Object.defineProperty(this, "style", { get: function() {
      return s;
    }, set: function(o) {
      s = o;
    } }), Object.defineProperty(this, "parentNode", {});
  };
  t.prototype.getContext = function(n, r) {
    var i;
    if ((n = n || "2d") !== "2d") return null;
    for (i in r) this.pdf.context2d.hasOwnProperty(i) && (this.pdf.context2d[i] = r[i]);
    return this.pdf.context2d._canvas = this, this.pdf.context2d;
  }, t.prototype.toDataURL = function() {
    throw new Error("toDataURL is not implemented.");
  }, e.events.push(["initialized", function() {
    this.canvas = new t(), this.canvas.pdf = this;
  }]);
})(et.API), (function(e) {
  var t = { left: 0, top: 0, bottom: 0, right: 0 }, n = !1, r = function() {
    this.internal.__cell__ === void 0 && (this.internal.__cell__ = {}, this.internal.__cell__.padding = 3, this.internal.__cell__.headerFunction = void 0, this.internal.__cell__.margins = Object.assign({}, t), this.internal.__cell__.margins.width = this.getPageWidth(), i.call(this));
  }, i = function() {
    this.internal.__cell__.lastCell = new a(), this.internal.__cell__.pages = 1;
  }, a = function() {
    var u = arguments[0];
    Object.defineProperty(this, "x", { enumerable: !0, get: function() {
      return u;
    }, set: function(v) {
      u = v;
    } });
    var c = arguments[1];
    Object.defineProperty(this, "y", { enumerable: !0, get: function() {
      return c;
    }, set: function(v) {
      c = v;
    } });
    var f = arguments[2];
    Object.defineProperty(this, "width", { enumerable: !0, get: function() {
      return f;
    }, set: function(v) {
      f = v;
    } });
    var p = arguments[3];
    Object.defineProperty(this, "height", { enumerable: !0, get: function() {
      return p;
    }, set: function(v) {
      p = v;
    } });
    var E = arguments[4];
    Object.defineProperty(this, "text", { enumerable: !0, get: function() {
      return E;
    }, set: function(v) {
      E = v;
    } });
    var d = arguments[5];
    Object.defineProperty(this, "lineNumber", { enumerable: !0, get: function() {
      return d;
    }, set: function(v) {
      d = v;
    } });
    var A = arguments[6];
    return Object.defineProperty(this, "align", { enumerable: !0, get: function() {
      return A;
    }, set: function(v) {
      A = v;
    } }), this;
  };
  a.prototype.clone = function() {
    return new a(this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align);
  }, a.prototype.toArray = function() {
    return [this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align];
  }, e.setHeaderFunction = function(u) {
    return r.call(this), this.internal.__cell__.headerFunction = typeof u == "function" ? u : void 0, this;
  }, e.getTextDimensions = function(u, c) {
    r.call(this);
    var f = (c = c || {}).fontSize || this.getFontSize(), p = c.font || this.getFont(), E = c.scaleFactor || this.internal.scaleFactor, d = 0, A = 0, v = 0, C = this;
    if (!Array.isArray(u) && typeof u != "string") {
      if (typeof u != "number") throw new Error("getTextDimensions expects text-parameter to be of type String or type Number or an Array of Strings.");
      u = String(u);
    }
    var _ = c.maxWidth;
    _ > 0 ? typeof u == "string" ? u = this.splitTextToSize(u, _) : Object.prototype.toString.call(u) === "[object Array]" && (u = u.reduce(function(B, V) {
      return B.concat(C.splitTextToSize(V, _));
    }, [])) : u = Array.isArray(u) ? u : [u];
    for (var U = 0; U < u.length; U++) d < (v = this.getStringUnitWidth(u[U], { font: p }) * f) && (d = v);
    return d !== 0 && (A = u.length), { w: d /= E, h: Math.max((A * f * this.getLineHeightFactor() - f * (this.getLineHeightFactor() - 1)) / E, 0) };
  }, e.cellAddPage = function() {
    r.call(this), this.addPage();
    var u = this.internal.__cell__.margins || t;
    return this.internal.__cell__.lastCell = new a(u.left, u.top, void 0, void 0), this.internal.__cell__.pages += 1, this;
  };
  var s = e.cell = function() {
    var u;
    u = arguments[0] instanceof a ? arguments[0] : new a(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6]), r.call(this);
    var c = this.internal.__cell__.lastCell, f = this.internal.__cell__.padding, p = this.internal.__cell__.margins || t, E = this.internal.__cell__.tableHeaderRow, d = this.internal.__cell__.printHeaders;
    return c.lineNumber !== void 0 && (c.lineNumber === u.lineNumber ? (u.x = (c.x || 0) + (c.width || 0), u.y = c.y || 0) : c.y + c.height + u.height + p.bottom > this.getPageHeight() ? (this.cellAddPage(), u.y = p.top, d && E && (this.printHeaderRow(u.lineNumber, !0), u.y += E[0].height)) : u.y = c.y + c.height || u.y), u.text[0] !== void 0 && (this.rect(u.x, u.y, u.width, u.height, n === !0 ? "FD" : void 0), u.align === "right" ? this.text(u.text, u.x + u.width - f, u.y + f, { align: "right", baseline: "top" }) : u.align === "center" ? this.text(u.text, u.x + u.width / 2, u.y + f, { align: "center", baseline: "top", maxWidth: u.width - f - f }) : this.text(u.text, u.x + f, u.y + f, { align: "left", baseline: "top", maxWidth: u.width - f - f })), this.internal.__cell__.lastCell = u, this;
  };
  e.table = function(u, c, f, p, E) {
    if (r.call(this), !f) throw new Error("No data for PDF table.");
    var d, A, v, C, _ = [], U = [], B = [], V = {}, ie = {}, K = [], fe = [], Z = (E = E || {}).autoSize || !1, z = E.printHeaders !== !1, D = E.css && E.css["font-size"] !== void 0 ? 16 * E.css["font-size"] : E.fontSize || 12, N = E.margins || Object.assign({ width: this.getPageWidth() }, t), I = typeof E.padding == "number" ? E.padding : 3, $ = E.headerBackgroundColor || "#c8c8c8", Y = E.headerTextColor || "#000";
    if (i.call(this), this.internal.__cell__.printHeaders = z, this.internal.__cell__.margins = N, this.internal.__cell__.table_font_size = D, this.internal.__cell__.padding = I, this.internal.__cell__.headerBackgroundColor = $, this.internal.__cell__.headerTextColor = Y, this.setFontSize(D), p == null) U = _ = Object.keys(f[0]), B = _.map(function() {
      return "left";
    });
    else if (Array.isArray(p) && qt(p[0]) === "object") for (_ = p.map(function(M) {
      return M.name;
    }), U = p.map(function(M) {
      return M.prompt || M.name || "";
    }), B = p.map(function(M) {
      return M.align || "left";
    }), d = 0; d < p.length; d += 1) ie[p[d].name] = 0.7499990551181103 * p[d].width;
    else Array.isArray(p) && typeof p[0] == "string" && (U = _ = p, B = _.map(function() {
      return "left";
    }));
    if (Z || Array.isArray(p) && typeof p[0] == "string") for (d = 0; d < _.length; d += 1) {
      for (V[C = _[d]] = f.map(function(M) {
        return M[C];
      }), this.setFont(void 0, "bold"), K.push(this.getTextDimensions(U[d], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w), A = V[C], this.setFont(void 0, "normal"), v = 0; v < A.length; v += 1) K.push(this.getTextDimensions(A[v], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w);
      ie[C] = Math.max.apply(null, K) + I + I, K = [];
    }
    if (z) {
      var J = {};
      for (d = 0; d < _.length; d += 1) J[_[d]] = {}, J[_[d]].text = U[d], J[_[d]].align = B[d];
      var ue = o.call(this, J, ie);
      fe = _.map(function(M) {
        return new a(u, c, ie[M], ue, J[M].text, void 0, J[M].align);
      }), this.setTableHeaderRow(fe), this.printHeaderRow(1, !1);
    }
    var me = p.reduce(function(M, xe) {
      return M[xe.name] = xe.align, M;
    }, {});
    for (d = 0; d < f.length; d += 1) {
      "rowStart" in E && E.rowStart instanceof Function && E.rowStart({ row: d, data: f[d] }, this);
      var se = o.call(this, f[d], ie);
      for (v = 0; v < _.length; v += 1) {
        var Ee = f[d][_[v]];
        "cellStart" in E && E.cellStart instanceof Function && E.cellStart({ row: d, col: v, data: Ee }, this), s.call(this, new a(u, c, ie[_[v]], se, Ee, d + 2, me[_[v]]));
      }
    }
    return this.internal.__cell__.table_x = u, this.internal.__cell__.table_y = c, this;
  };
  var o = function(u, c) {
    var f = this.internal.__cell__.padding, p = this.internal.__cell__.table_font_size, E = this.internal.scaleFactor;
    return Object.keys(u).map(function(d) {
      var A = u[d];
      return this.splitTextToSize(A.hasOwnProperty("text") ? A.text : A, c[d] - f - f);
    }, this).map(function(d) {
      return this.getLineHeightFactor() * d.length * p / E + f + f;
    }, this).reduce(function(d, A) {
      return Math.max(d, A);
    }, 0);
  };
  e.setTableHeaderRow = function(u) {
    r.call(this), this.internal.__cell__.tableHeaderRow = u;
  }, e.printHeaderRow = function(u, c) {
    if (r.call(this), !this.internal.__cell__.tableHeaderRow) throw new Error("Property tableHeaderRow does not exist.");
    var f;
    if (n = !0, typeof this.internal.__cell__.headerFunction == "function") {
      var p = this.internal.__cell__.headerFunction(this, this.internal.__cell__.pages);
      this.internal.__cell__.lastCell = new a(p[0], p[1], p[2], p[3], void 0, -1);
    }
    this.setFont(void 0, "bold");
    for (var E = [], d = 0; d < this.internal.__cell__.tableHeaderRow.length; d += 1) {
      f = this.internal.__cell__.tableHeaderRow[d].clone(), c && (f.y = this.internal.__cell__.margins.top || 0, E.push(f)), f.lineNumber = u;
      var A = this.getTextColor();
      this.setTextColor(this.internal.__cell__.headerTextColor), this.setFillColor(this.internal.__cell__.headerBackgroundColor), s.call(this, f), this.setTextColor(A);
    }
    E.length > 0 && this.setTableHeaderRow(E), this.setFont(void 0, "normal"), n = !1;
  };
})(et.API);
var Pp = { italic: ["italic", "oblique", "normal"], oblique: ["oblique", "italic", "normal"], normal: ["normal", "oblique", "italic"] }, Op = ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded"], Xc = Ip(Op), Rp = [100, 200, 300, 400, 500, 600, 700, 800, 900], r8 = Ip(Rp);
function Ec(e) {
  var t = e.family.replace(/"|'/g, "").toLowerCase(), n = (function(a) {
    return Pp[a = a || "normal"] ? a : "normal";
  })(e.style), r = (function(a) {
    return a ? typeof a == "number" ? a >= 100 && a <= 900 && a % 100 == 0 ? a : 400 : /^\d00$/.test(a) ? parseInt(a) : a === "bold" ? 700 : 400 : 400;
  })(e.weight), i = (function(a) {
    return typeof Xc[a = a || "normal"] == "number" ? a : "normal";
  })(e.stretch);
  return { family: t, style: n, weight: r, stretch: i, src: e.src || [], ref: e.ref || { name: t, style: [i, n, r].join(" ") } };
}
function Sd(e, t, n, r) {
  var i;
  for (i = n; i >= 0 && i < t.length; i += r) if (e[t[i]]) return e[t[i]];
  for (i = n; i >= 0 && i < t.length; i -= r) if (e[t[i]]) return e[t[i]];
}
var i8 = { "sans-serif": "helvetica", fixed: "courier", monospace: "courier", terminal: "courier", cursive: "times", fantasy: "times", serif: "times" }, Ld = { caption: "times", icon: "times", menu: "times", "message-box": "times", "small-caption": "times", "status-bar": "times" };
function kd(e) {
  return [e.stretch, e.style, e.weight, e.family].join(" ");
}
function Cd(e) {
  return e.trimLeft();
}
function a8(e, t) {
  for (var n = 0; n < e.length; ) {
    if (e.charAt(n) === t) return [e.substring(0, n), e.substring(n + 1)];
    n += 1;
  }
  return null;
}
function s8(e) {
  var t = e.match(/^(-[a-z_]|[a-z_])[a-z0-9_-]*/i);
  return t === null ? null : [t[0], e.substring(t[0].length)];
}
var yu, Id, Pd, Ja, Tu, Od, Rd, Dd, yc = ["times"];
function Md(e, t, n, r, i) {
  var a = 4, s = Bd;
  switch (i) {
    case et.API.image_compression.FAST:
      a = 1, s = Fd;
      break;
    case et.API.image_compression.MEDIUM:
      a = 6, s = Ud;
      break;
    case et.API.image_compression.SLOW:
      a = 9, s = Hd;
  }
  e = (function(u, c, f, p) {
    for (var E, d = u.length / c, A = new Uint8Array(u.length + d), v = [o8, Fd, Bd, Ud, Hd], C = 0; C < d; C += 1) {
      var _ = C * c, U = u.subarray(_, _ + c);
      if (p) A.set(p(U, f, E), _ + C);
      else {
        for (var B = v.length, V = [], ie = 0; ie < B; ie += 1) V[ie] = v[ie](U, f, E);
        var K = l8(V.concat());
        A.set(V[K], _ + C);
      }
      E = U;
    }
    return A;
  })(e, t, Math.ceil(n * r / 8), s);
  var o = qc(e, { level: a });
  return et.API.__addimage__.arrayBufferToBinaryString(o);
}
function o8(e) {
  var t = Array.apply([], e);
  return t.unshift(0), t;
}
function Fd(e, t) {
  var n = e.length, r = [];
  r[0] = 1;
  for (var i = 0; i < n; i += 1) {
    var a = e[i - t] || 0;
    r[i + 1] = e[i] - a + 256 & 255;
  }
  return r;
}
function Bd(e, t, n) {
  var r = e.length, i = [];
  i[0] = 2;
  for (var a = 0; a < r; a += 1) {
    var s = n && n[a] || 0;
    i[a + 1] = e[a] - s + 256 & 255;
  }
  return i;
}
function Ud(e, t, n) {
  var r = e.length, i = [];
  i[0] = 3;
  for (var a = 0; a < r; a += 1) {
    var s = e[a - t] || 0, o = n && n[a] || 0;
    i[a + 1] = e[a] + 256 - (s + o >>> 1) & 255;
  }
  return i;
}
function Hd(e, t, n) {
  var r = e.length, i = [];
  i[0] = 4;
  for (var a = 0; a < r; a += 1) {
    var s = u8(e[a - t] || 0, n && n[a] || 0, n && n[a - t] || 0);
    i[a + 1] = e[a] - s + 256 & 255;
  }
  return i;
}
function u8(e, t, n) {
  if (e === t && t === n) return e;
  var r = Math.abs(t - n), i = Math.abs(e - n), a = Math.abs(e + t - n - n);
  return r <= i && r <= a ? e : i <= a ? t : n;
}
function l8(e) {
  var t = e.map(function(n) {
    return n.reduce(function(r, i) {
      return r + Math.abs(i);
    }, 0);
  });
  return t.indexOf(Math.min.apply(null, t));
}
function Tc(e, t, n) {
  var r = t * n, i = Math.floor(r / 8), a = 16 - (r - 8 * i + n), s = (1 << n) - 1;
  return Dp(e, i) >> a & s;
}
function jd(e, t, n, r) {
  var i = n * r, a = Math.floor(i / 8), s = 16 - (i - 8 * a + r), o = (1 << r) - 1, u = (t & o) << s;
  (function(c, f, p) {
    if (f + 1 < c.byteLength) c.setUint16(f, p, !1);
    else {
      var E = p >> 8 & 255;
      c.setUint8(f, E);
    }
  })(e, a, Dp(e, a) & ~(o << s) & 65535 | u);
}
function Dp(e, t) {
  return t + 1 < e.byteLength ? e.getUint16(t, !1) : e.getUint8(t) << 8;
}
function c8(e) {
  var t = 0;
  if (e[t++] !== 71 || e[t++] !== 73 || e[t++] !== 70 || e[t++] !== 56 || (e[t++] + 1 & 253) != 56 || e[t++] !== 97) throw new Error("Invalid GIF 87a/89a header.");
  var n = e[t++] | e[t++] << 8, r = e[t++] | e[t++] << 8, i = e[t++], a = i >> 7, s = 1 << 1 + (7 & i);
  e[t++], e[t++];
  var o = null, u = null;
  a && (o = t, u = s, t += 3 * s);
  var c = !0, f = [], p = 0, E = null, d = 0, A = null;
  for (this.width = n, this.height = r; c && t < e.length; ) switch (e[t++]) {
    case 33:
      switch (e[t++]) {
        case 255:
          if (e[t] !== 11 || e[t + 1] == 78 && e[t + 2] == 69 && e[t + 3] == 84 && e[t + 4] == 83 && e[t + 5] == 67 && e[t + 6] == 65 && e[t + 7] == 80 && e[t + 8] == 69 && e[t + 9] == 50 && e[t + 10] == 46 && e[t + 11] == 48 && e[t + 12] == 3 && e[t + 13] == 1 && e[t + 16] == 0) t += 14, A = e[t++] | e[t++] << 8, t++;
          else for (t += 12; ; ) {
            if (!((N = e[t++]) >= 0)) throw Error("Invalid block size");
            if (N === 0) break;
            t += N;
          }
          break;
        case 249:
          if (e[t++] !== 4 || e[t + 4] !== 0) throw new Error("Invalid graphics extension block.");
          var v = e[t++];
          p = e[t++] | e[t++] << 8, E = e[t++], 1 & v || (E = null), d = v >> 2 & 7, t++;
          break;
        case 254:
          for (; ; ) {
            if (!((N = e[t++]) >= 0)) throw Error("Invalid block size");
            if (N === 0) break;
            t += N;
          }
          break;
        default:
          throw new Error("Unknown graphic control label: 0x" + e[t - 1].toString(16));
      }
      break;
    case 44:
      var C = e[t++] | e[t++] << 8, _ = e[t++] | e[t++] << 8, U = e[t++] | e[t++] << 8, B = e[t++] | e[t++] << 8, V = e[t++], ie = V >> 6 & 1, K = 1 << 1 + (7 & V), fe = o, Z = u, z = !1;
      V >> 7 && (z = !0, fe = t, Z = K, t += 3 * K);
      var D = t;
      for (t++; ; ) {
        var N;
        if (!((N = e[t++]) >= 0)) throw Error("Invalid block size");
        if (N === 0) break;
        t += N;
      }
      f.push({ x: C, y: _, width: U, height: B, has_local_palette: z, palette_offset: fe, palette_size: Z, data_offset: D, data_length: t - D, transparent_index: E, interlaced: !!ie, delay: p, disposal: d });
      break;
    case 59:
      c = !1;
      break;
    default:
      throw new Error("Unknown gif block: 0x" + e[t - 1].toString(16));
  }
  this.numFrames = function() {
    return f.length;
  }, this.loopCount = function() {
    return A;
  }, this.frameInfo = function(I) {
    if (I < 0 || I >= f.length) throw new Error("Frame index out of range.");
    return f[I];
  }, this.decodeAndBlitFrameBGRA = function(I, $) {
    var Y = this.frameInfo(I), J = Y.width * Y.height, ue = new Uint8Array(J);
    qd(e, Y.data_offset, ue, J);
    var me = Y.palette_offset, se = Y.transparent_index;
    se === null && (se = 256);
    var Ee = Y.width, M = n - Ee, xe = Ee, L = 4 * (Y.y * n + Y.x), T = 4 * ((Y.y + Y.height) * n + Y.x), G = L, ee = 4 * M;
    Y.interlaced === !0 && (ee += 4 * n * 7);
    for (var te = 8, le = 0, ge = ue.length; le < ge; ++le) {
      var be = ue[le];
      if (xe === 0 && (xe = Ee, (G += ee) >= T && (ee = 4 * M + 4 * n * (te - 1), G = L + (Ee + M) * (te << 1), te >>= 1)), be === se) G += 4;
      else {
        var Ae = e[me + 3 * be], Ie = e[me + 3 * be + 1], je = e[me + 3 * be + 2];
        $[G++] = je, $[G++] = Ie, $[G++] = Ae, $[G++] = 255;
      }
      --xe;
    }
  }, this.decodeAndBlitFrameRGBA = function(I, $) {
    var Y = this.frameInfo(I), J = Y.width * Y.height, ue = new Uint8Array(J);
    qd(e, Y.data_offset, ue, J);
    var me = Y.palette_offset, se = Y.transparent_index;
    se === null && (se = 256);
    var Ee = Y.width, M = n - Ee, xe = Ee, L = 4 * (Y.y * n + Y.x), T = 4 * ((Y.y + Y.height) * n + Y.x), G = L, ee = 4 * M;
    Y.interlaced === !0 && (ee += 4 * n * 7);
    for (var te = 8, le = 0, ge = ue.length; le < ge; ++le) {
      var be = ue[le];
      if (xe === 0 && (xe = Ee, (G += ee) >= T && (ee = 4 * M + 4 * n * (te - 1), G = L + (Ee + M) * (te << 1), te >>= 1)), be === se) G += 4;
      else {
        var Ae = e[me + 3 * be], Ie = e[me + 3 * be + 1], je = e[me + 3 * be + 2];
        $[G++] = Ae, $[G++] = Ie, $[G++] = je, $[G++] = 255;
      }
      --xe;
    }
  };
}
function qd(e, t, n, r) {
  for (var i = e[t++], a = 1 << i, s = a + 1, o = s + 1, u = i + 1, c = (1 << u) - 1, f = 0, p = 0, E = 0, d = e[t++], A = new Int32Array(4096), v = null; ; ) {
    for (; f < 16 && d !== 0; ) p |= e[t++] << f, f += 8, d === 1 ? d = e[t++] : --d;
    if (f < u) break;
    var C = p & c;
    if (p >>= u, f -= u, C !== a) {
      if (C === s) break;
      for (var _ = C < o ? C : v, U = 0, B = _; B > a; ) B = A[B] >> 8, ++U;
      var V = B;
      if (E + U + (_ !== C ? 1 : 0) > r) return void Wt.log("Warning, gif stream longer than expected.");
      n[E++] = V;
      var ie = E += U;
      for (_ !== C && (n[E++] = V), B = _; U--; ) B = A[B], n[--ie] = 255 & B, B >>= 8;
      v !== null && o < 4096 && (A[o++] = v << 8 | V, o >= c + 1 && u < 12 && (++u, c = c << 1 | 1)), v = C;
    } else o = s + 1, c = (1 << (u = i + 1)) - 1, v = null;
  }
  return E !== r && Wt.log("Warning, gif stream shorter than expected."), n;
}
/**
 * @license
  Copyright (c) 2008, Adobe Systems Incorporated
  All rights reserved.

  Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are
  met:

  * Redistributions of source code must retain the above copyright notice, 
    this list of conditions and the following disclaimer.
  
  * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the 
    documentation and/or other materials provided with the distribution.
  
  * Neither the name of Adobe Systems Incorporated nor the names of its 
    contributors may be used to endorse or promote products derived from 
    this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
function _c(e) {
  var t, n, r, i, a, s = Math.floor, o = new Array(64), u = new Array(64), c = new Array(64), f = new Array(64), p = new Array(65535), E = new Array(65535), d = new Array(64), A = new Array(64), v = [], C = 0, _ = 7, U = new Array(64), B = new Array(64), V = new Array(64), ie = new Array(256), K = new Array(2048), fe = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63], Z = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], z = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], D = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125], N = [1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20, 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51, 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250], I = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], $ = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], Y = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119], J = [0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50, 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114, 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41, 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229, 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249, 250];
  function ue(L, T) {
    for (var G = 0, ee = 0, te = new Array(), le = 1; le <= 16; le++) {
      for (var ge = 1; ge <= L[le]; ge++) te[T[ee]] = [], te[T[ee]][0] = G, te[T[ee]][1] = le, ee++, G++;
      G *= 2;
    }
    return te;
  }
  function me(L) {
    for (var T = L[0], G = L[1] - 1; G >= 0; ) T & 1 << G && (C |= 1 << _), G--, --_ < 0 && (C == 255 ? (se(255), se(0)) : se(C), _ = 7, C = 0);
  }
  function se(L) {
    v.push(L);
  }
  function Ee(L) {
    se(L >> 8 & 255), se(255 & L);
  }
  function M(L, T, G, ee, te) {
    for (var le, ge = te[0], be = te[240], Ae = (function(ke, rt) {
      var Ye, it, nt, Dt, xt, he, ve, Fe, Re, qe, ze = 0;
      for (Re = 0; Re < 8; ++Re) {
        Ye = ke[ze], it = ke[ze + 1], nt = ke[ze + 2], Dt = ke[ze + 3], xt = ke[ze + 4], he = ke[ze + 5], ve = ke[ze + 6];
        var Bt = Ye + (Fe = ke[ze + 7]), bt = Ye - Fe, ht = it + ve, dt = it - ve, Nt = nt + he, Qe = nt - he, kt = Dt + xt, lt = Dt - xt, Et = Bt + kt, Jt = Bt - kt, vt = ht + Nt, ot = ht - Nt;
        ke[ze] = Et + vt, ke[ze + 4] = Et - vt;
        var Mt = 0.707106781 * (ot + Jt);
        ke[ze + 2] = Jt + Mt, ke[ze + 6] = Jt - Mt;
        var na = 0.382683433 * ((Et = lt + Qe) - (ot = dt + bt)), Mn = 0.5411961 * Et + na, ai = 1.306562965 * ot + na, qr = 0.707106781 * (vt = Qe + dt), ut = bt + qr, si = bt - qr;
        ke[ze + 5] = si + Mn, ke[ze + 3] = si - Mn, ke[ze + 1] = ut + ai, ke[ze + 7] = ut - ai, ze += 8;
      }
      for (ze = 0, Re = 0; Re < 8; ++Re) {
        Ye = ke[ze], it = ke[ze + 8], nt = ke[ze + 16], Dt = ke[ze + 24], xt = ke[ze + 32], he = ke[ze + 40], ve = ke[ze + 48];
        var oi = Ye + (Fe = ke[ze + 56]), gr = Ye - Fe, br = it + ve, nn = it - ve, vn = nt + he, Cn = nt - he, ra = Dt + xt, Li = Dt - xt, Lr = oi + ra, zr = oi - ra, kr = br + vn, Cr = br - vn;
        ke[ze] = Lr + kr, ke[ze + 32] = Lr - kr;
        var Er = 0.707106781 * (Cr + zr);
        ke[ze + 16] = zr + Er, ke[ze + 48] = zr - Er;
        var ia = 0.382683433 * ((Lr = Li + Cn) - (Cr = nn + gr)), Yr = 0.5411961 * Lr + ia, aa = 1.306562965 * Cr + ia, Oa = 0.707106781 * (kr = Cn + nn), Ra = gr + Oa, Da = gr - Oa;
        ke[ze + 40] = Da + Yr, ke[ze + 24] = Da - Yr, ke[ze + 8] = Ra + aa, ke[ze + 56] = Ra - aa, ze++;
      }
      for (Re = 0; Re < 64; ++Re) qe = ke[Re] * rt[Re], d[Re] = qe > 0 ? qe + 0.5 | 0 : qe - 0.5 | 0;
      return d;
    })(L, T), Ie = 0; Ie < 64; ++Ie) A[fe[Ie]] = Ae[Ie];
    var je = A[0] - G;
    G = A[0], je == 0 ? me(ee[0]) : (me(ee[E[le = 32767 + je]]), me(p[le]));
    for (var He = 63; He > 0 && A[He] == 0; ) He--;
    if (He == 0) return me(ge), G;
    for (var tt, F = 1; F <= He; ) {
      for (var Ue = F; A[F] == 0 && F <= He; ) ++F;
      var gt = F - Ue;
      if (gt >= 16) {
        tt = gt >> 4;
        for (var at = 1; at <= tt; ++at) me(be);
        gt &= 15;
      }
      le = 32767 + A[F], me(te[(gt << 4) + E[le]]), me(p[le]), F++;
    }
    return He != 63 && me(ge), G;
  }
  function xe(L) {
    L = Math.min(Math.max(L, 1), 100), a != L && ((function(T) {
      for (var G = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99], ee = 0; ee < 64; ee++) {
        var te = s((G[ee] * T + 50) / 100);
        te = Math.min(Math.max(te, 1), 255), o[fe[ee]] = te;
      }
      for (var le = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99], ge = 0; ge < 64; ge++) {
        var be = s((le[ge] * T + 50) / 100);
        be = Math.min(Math.max(be, 1), 255), u[fe[ge]] = be;
      }
      for (var Ae = [1, 1.387039845, 1.306562965, 1.175875602, 1, 0.785694958, 0.5411961, 0.275899379], Ie = 0, je = 0; je < 8; je++) for (var He = 0; He < 8; He++) c[Ie] = 1 / (o[fe[Ie]] * Ae[je] * Ae[He] * 8), f[Ie] = 1 / (u[fe[Ie]] * Ae[je] * Ae[He] * 8), Ie++;
    })(L < 50 ? Math.floor(5e3 / L) : Math.floor(200 - 2 * L)), a = L);
  }
  this.encode = function(L, T) {
    T && xe(T), v = new Array(), C = 0, _ = 7, Ee(65496), Ee(65504), Ee(16), se(74), se(70), se(73), se(70), se(0), se(1), se(1), se(0), Ee(1), Ee(1), se(0), se(0), (function() {
      Ee(65499), Ee(132), se(0);
      for (var it = 0; it < 64; it++) se(o[it]);
      se(1);
      for (var nt = 0; nt < 64; nt++) se(u[nt]);
    })(), (function(it, nt) {
      Ee(65472), Ee(17), se(8), Ee(nt), Ee(it), se(3), se(1), se(17), se(0), se(2), se(17), se(1), se(3), se(17), se(1);
    })(L.width, L.height), (function() {
      Ee(65476), Ee(418), se(0);
      for (var it = 0; it < 16; it++) se(Z[it + 1]);
      for (var nt = 0; nt <= 11; nt++) se(z[nt]);
      se(16);
      for (var Dt = 0; Dt < 16; Dt++) se(D[Dt + 1]);
      for (var xt = 0; xt <= 161; xt++) se(N[xt]);
      se(1);
      for (var he = 0; he < 16; he++) se(I[he + 1]);
      for (var ve = 0; ve <= 11; ve++) se($[ve]);
      se(17);
      for (var Fe = 0; Fe < 16; Fe++) se(Y[Fe + 1]);
      for (var Re = 0; Re <= 161; Re++) se(J[Re]);
    })(), Ee(65498), Ee(12), se(3), se(1), se(0), se(2), se(17), se(3), se(17), se(0), se(63), se(0);
    var G = 0, ee = 0, te = 0;
    C = 0, _ = 7, this.encode.displayName = "_encode_";
    for (var le, ge, be, Ae, Ie, je, He, tt, F, Ue = L.data, gt = L.width, at = L.height, ke = 4 * gt, rt = 0; rt < at; ) {
      for (le = 0; le < ke; ) {
        for (Ie = ke * rt + le, He = -1, tt = 0, F = 0; F < 64; F++) je = Ie + (tt = F >> 3) * ke + (He = 4 * (7 & F)), rt + tt >= at && (je -= ke * (rt + 1 + tt - at)), le + He >= ke && (je -= le + He - ke + 4), ge = Ue[je++], be = Ue[je++], Ae = Ue[je++], U[F] = (K[ge] + K[be + 256 | 0] + K[Ae + 512 | 0] >> 16) - 128, B[F] = (K[ge + 768 | 0] + K[be + 1024 | 0] + K[Ae + 1280 | 0] >> 16) - 128, V[F] = (K[ge + 1280 | 0] + K[be + 1536 | 0] + K[Ae + 1792 | 0] >> 16) - 128;
        G = M(U, c, G, t, r), ee = M(B, f, ee, n, i), te = M(V, f, te, n, i), le += 32;
      }
      rt += 8;
    }
    if (_ >= 0) {
      var Ye = [];
      Ye[1] = _ + 1, Ye[0] = (1 << _ + 1) - 1, me(Ye);
    }
    return Ee(65497), new Uint8Array(v);
  }, e = e || 50, (function() {
    for (var L = String.fromCharCode, T = 0; T < 256; T++) ie[T] = L(T);
  })(), t = ue(Z, z), n = ue(I, $), r = ue(D, N), i = ue(Y, J), (function() {
    for (var L = 1, T = 2, G = 1; G <= 15; G++) {
      for (var ee = L; ee < T; ee++) E[32767 + ee] = G, p[32767 + ee] = [], p[32767 + ee][1] = G, p[32767 + ee][0] = ee;
      for (var te = -(T - 1); te <= -L; te++) E[32767 + te] = G, p[32767 + te] = [], p[32767 + te][1] = G, p[32767 + te][0] = T - 1 + te;
      L <<= 1, T <<= 1;
    }
  })(), (function() {
    for (var L = 0; L < 256; L++) K[L] = 19595 * L, K[L + 256 | 0] = 38470 * L, K[L + 512 | 0] = 7471 * L + 32768, K[L + 768 | 0] = -11059 * L, K[L + 1024 | 0] = -21709 * L, K[L + 1280 | 0] = 32768 * L + 8421375, K[L + 1536 | 0] = -27439 * L, K[L + 1792 | 0] = -5329 * L;
  })(), xe(e);
}
/**
 * @license
 * Copyright (c) 2017 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function Mr(e, t) {
  if (this.pos = 0, this.buffer = e, this.datav = new DataView(e.buffer), this.is_with_alpha = !!t, this.bottom_up = !0, this.flag = String.fromCharCode(this.buffer[0]) + String.fromCharCode(this.buffer[1]), this.pos += 2, ["BM", "BA", "CI", "CP", "IC", "PT"].indexOf(this.flag) === -1) throw new Error("Invalid BMP File");
  this.parseHeader(), this.parseBGR();
}
function zd(e) {
  function t(z) {
    if (!z) throw Error("assert :P");
  }
  function n(z, D, N) {
    for (var I = 0; 4 > I; I++) if (z[D + I] != N.charCodeAt(I)) return !0;
    return !1;
  }
  function r(z, D, N, I, $) {
    for (var Y = 0; Y < $; Y++) z[D + Y] = N[I + Y];
  }
  function i(z, D, N, I) {
    for (var $ = 0; $ < I; $++) z[D + $] = N;
  }
  function a(z) {
    return new Int32Array(z);
  }
  function s(z, D) {
    for (var N = [], I = 0; I < z; I++) N.push(new D());
    return N;
  }
  function o(z, D) {
    var N = [];
    return (function I($, Y, J) {
      for (var ue = J[Y], me = 0; me < ue && ($.push(J.length > Y + 1 ? [] : new D()), !(J.length < Y + 1)); me++) I($[me], Y + 1, J);
    })(N, 0, z), N;
  }
  var u = function() {
    var z = this;
    function D(l, h) {
      for (var b = 1 << h - 1 >>> 0; l & b; ) b >>>= 1;
      return b ? (l & b - 1) + b : l;
    }
    function N(l, h, b, y, x) {
      t(!(y % b));
      do
        l[h + (y -= b)] = x;
      while (0 < y);
    }
    function I(l, h, b, y, x) {
      if (t(2328 >= x), 512 >= x) var S = a(512);
      else if ((S = a(x)) == null) return 0;
      return (function(k, P, O, H, ne, pe) {
        var j, re, oe = P, Te = 1 << O, de = a(16), _e = a(16);
        for (t(ne != 0), t(H != null), t(k != null), t(0 < O), re = 0; re < ne; ++re) {
          if (15 < H[re]) return 0;
          ++de[H[re]];
        }
        if (de[0] == ne) return 0;
        for (_e[1] = 0, j = 1; 15 > j; ++j) {
          if (de[j] > 1 << j) return 0;
          _e[j + 1] = _e[j] + de[j];
        }
        for (re = 0; re < ne; ++re) j = H[re], 0 < H[re] && (pe[_e[j]++] = re);
        if (_e[15] == 1) return (H = new $()).g = 0, H.value = pe[0], N(k, oe, 1, Te, H), Te;
        var Ne, Pe = -1, Le = Te - 1, Ze = 0, We = 1, _t = 1, $e = 1 << O;
        for (re = 0, j = 1, ne = 2; j <= O; ++j, ne <<= 1) {
          if (We += _t <<= 1, 0 > (_t -= de[j])) return 0;
          for (; 0 < de[j]; --de[j]) (H = new $()).g = j, H.value = pe[re++], N(k, oe + Ze, ne, $e, H), Ze = D(Ze, j);
        }
        for (j = O + 1, ne = 2; 15 >= j; ++j, ne <<= 1) {
          if (We += _t <<= 1, 0 > (_t -= de[j])) return 0;
          for (; 0 < de[j]; --de[j]) {
            if (H = new $(), (Ze & Le) != Pe) {
              for (oe += $e, Ne = 1 << (Pe = j) - O; 15 > Pe && !(0 >= (Ne -= de[Pe])); ) ++Pe, Ne <<= 1;
              Te += $e = 1 << (Ne = Pe - O), k[P + (Pe = Ze & Le)].g = Ne + O, k[P + Pe].value = oe - P - Pe;
            }
            H.g = j - O, H.value = pe[re++], N(k, oe + (Ze >> O), ne, $e, H), Ze = D(Ze, j);
          }
        }
        return We != 2 * _e[15] - 1 ? 0 : Te;
      })(l, h, b, y, x, S);
    }
    function $() {
      this.value = this.g = 0;
    }
    function Y() {
      this.value = this.g = 0;
    }
    function J() {
      this.G = s(5, $), this.H = a(5), this.jc = this.Qb = this.qb = this.nd = 0, this.pd = s(ga, Y);
    }
    function ue(l, h, b, y) {
      t(l != null), t(h != null), t(2147483648 > y), l.Ca = 254, l.I = 0, l.b = -8, l.Ka = 0, l.oa = h, l.pa = b, l.Jd = h, l.Yc = b + y, l.Zc = 4 <= y ? b + y - 4 + 1 : b, ge(l);
    }
    function me(l, h) {
      for (var b = 0; 0 < h--; ) b |= Ae(l, 128) << h;
      return b;
    }
    function se(l, h) {
      var b = me(l, h);
      return be(l) ? -b : b;
    }
    function Ee(l, h, b, y) {
      var x, S = 0;
      for (t(l != null), t(h != null), t(4294967288 > y), l.Sb = y, l.Ra = 0, l.u = 0, l.h = 0, 4 < y && (y = 4), x = 0; x < y; ++x) S += h[b + x] << 8 * x;
      l.Ra = S, l.bb = y, l.oa = h, l.pa = b;
    }
    function M(l) {
      for (; 8 <= l.u && l.bb < l.Sb; ) l.Ra >>>= 8, l.Ra += l.oa[l.pa + l.bb] << Pi - 8 >>> 0, ++l.bb, l.u -= 8;
      ee(l) && (l.h = 1, l.u = 0);
    }
    function xe(l, h) {
      if (t(0 <= h), !l.h && h <= ir) {
        var b = G(l) & rr[h];
        return l.u += h, M(l), b;
      }
      return l.h = 1, l.u = 0;
    }
    function L() {
      this.b = this.Ca = this.I = 0, this.oa = [], this.pa = 0, this.Jd = [], this.Yc = 0, this.Zc = [], this.Ka = 0;
    }
    function T() {
      this.Ra = 0, this.oa = [], this.h = this.u = this.bb = this.Sb = this.pa = 0;
    }
    function G(l) {
      return l.Ra >>> (l.u & Pi - 1) >>> 0;
    }
    function ee(l) {
      return t(l.bb <= l.Sb), l.h || l.bb == l.Sb && l.u > Pi;
    }
    function te(l, h) {
      l.u = h, l.h = ee(l);
    }
    function le(l) {
      l.u >= Ei && (t(l.u >= Ei), M(l));
    }
    function ge(l) {
      t(l != null && l.oa != null), l.pa < l.Zc ? (l.I = (l.oa[l.pa++] | l.I << 8) >>> 0, l.b += 8) : (t(l != null && l.oa != null), l.pa < l.Yc ? (l.b += 8, l.I = l.oa[l.pa++] | l.I << 8) : l.Ka ? l.b = 0 : (l.I <<= 8, l.b += 8, l.Ka = 1));
    }
    function be(l) {
      return me(l, 1);
    }
    function Ae(l, h) {
      var b = l.Ca;
      0 > l.b && ge(l);
      var y = l.b, x = b * h >>> 8, S = (l.I >>> y > x) + 0;
      for (S ? (b -= x, l.I -= x + 1 << y >>> 0) : b = x + 1, y = b, x = 0; 256 <= y; ) x += 8, y >>= 8;
      return y = 7 ^ x + Oi[y], l.b -= y, l.Ca = (b << y) - 1, S;
    }
    function Ie(l, h, b) {
      l[h + 0] = b >> 24 & 255, l[h + 1] = b >> 16 & 255, l[h + 2] = b >> 8 & 255, l[h + 3] = 255 & b;
    }
    function je(l, h) {
      return l[h + 0] | l[h + 1] << 8;
    }
    function He(l, h) {
      return je(l, h) | l[h + 2] << 16;
    }
    function tt(l, h) {
      return je(l, h) | je(l, h + 2) << 16;
    }
    function F(l, h) {
      var b = 1 << h;
      return t(l != null), t(0 < h), l.X = a(b), l.X == null ? 0 : (l.Mb = 32 - h, l.Xa = h, 1);
    }
    function Ue(l, h) {
      t(l != null), t(h != null), t(l.Xa == h.Xa), r(h.X, 0, l.X, 0, 1 << h.Xa);
    }
    function gt() {
      this.X = [], this.Xa = this.Mb = 0;
    }
    function at(l, h, b, y) {
      t(b != null), t(y != null);
      var x = b[0], S = y[0];
      return x == 0 && (x = (l * S + h / 2) / h), S == 0 && (S = (h * x + l / 2) / l), 0 >= x || 0 >= S ? 0 : (b[0] = x, y[0] = S, 1);
    }
    function ke(l, h) {
      return l + (1 << h) - 1 >>> h;
    }
    function rt(l, h) {
      return ((4278255360 & l) + (4278255360 & h) >>> 0 & 4278255360) + ((16711935 & l) + (16711935 & h) >>> 0 & 16711935) >>> 0;
    }
    function Ye(l, h) {
      z[h] = function(b, y, x, S, k, P, O) {
        var H;
        for (H = 0; H < k; ++H) {
          var ne = z[l](P[O + H - 1], x, S + H);
          P[O + H] = rt(b[y + H], ne);
        }
      };
    }
    function it() {
      this.ud = this.hd = this.jd = 0;
    }
    function nt(l, h) {
      return ((4278124286 & (l ^ h)) >>> 1) + (l & h) >>> 0;
    }
    function Dt(l) {
      return 0 <= l && 256 > l ? l : 0 > l ? 0 : 255 < l ? 255 : void 0;
    }
    function xt(l, h) {
      return Dt(l + (l - h + 0.5 >> 1));
    }
    function he(l, h, b) {
      return Math.abs(h - b) - Math.abs(l - b);
    }
    function ve(l, h, b, y, x, S, k) {
      for (y = S[k - 1], b = 0; b < x; ++b) S[k + b] = y = rt(l[h + b], y);
    }
    function Fe(l, h, b, y, x) {
      var S;
      for (S = 0; S < b; ++S) {
        var k = l[h + S], P = k >> 8 & 255, O = 16711935 & (O = (O = 16711935 & k) + ((P << 16) + P));
        y[x + S] = (4278255360 & k) + O >>> 0;
      }
    }
    function Re(l, h) {
      h.jd = 255 & l, h.hd = l >> 8 & 255, h.ud = l >> 16 & 255;
    }
    function qe(l, h, b, y, x, S) {
      var k;
      for (k = 0; k < y; ++k) {
        var P = h[b + k], O = P >>> 8, H = P, ne = 255 & (ne = (ne = P >>> 16) + ((l.jd << 24 >> 24) * (O << 24 >> 24) >>> 5));
        H = 255 & (H = (H += (l.hd << 24 >> 24) * (O << 24 >> 24) >>> 5) + ((l.ud << 24 >> 24) * (ne << 24 >> 24) >>> 5)), x[S + k] = (4278255360 & P) + (ne << 16) + H;
      }
    }
    function ze(l, h, b, y, x) {
      z[h] = function(S, k, P, O, H, ne, pe, j, re) {
        for (O = pe; O < j; ++O) for (pe = 0; pe < re; ++pe) H[ne++] = x(P[y(S[k++])]);
      }, z[l] = function(S, k, P, O, H, ne, pe) {
        var j = 8 >> S.b, re = S.Ea, oe = S.K[0], Te = S.w;
        if (8 > j) for (S = (1 << S.b) - 1, Te = (1 << j) - 1; k < P; ++k) {
          var de, _e = 0;
          for (de = 0; de < re; ++de) de & S || (_e = y(O[H++])), ne[pe++] = x(oe[_e & Te]), _e >>= j;
        }
        else z["VP8LMapColor" + b](O, H, oe, Te, ne, pe, k, P, re);
      };
    }
    function Bt(l, h, b, y, x) {
      for (b = h + b; h < b; ) {
        var S = l[h++];
        y[x++] = S >> 16 & 255, y[x++] = S >> 8 & 255, y[x++] = 255 & S;
      }
    }
    function bt(l, h, b, y, x) {
      for (b = h + b; h < b; ) {
        var S = l[h++];
        y[x++] = S >> 16 & 255, y[x++] = S >> 8 & 255, y[x++] = 255 & S, y[x++] = S >> 24 & 255;
      }
    }
    function ht(l, h, b, y, x) {
      for (b = h + b; h < b; ) {
        var S = (k = l[h++]) >> 16 & 240 | k >> 12 & 15, k = 240 & k | k >> 28 & 15;
        y[x++] = S, y[x++] = k;
      }
    }
    function dt(l, h, b, y, x) {
      for (b = h + b; h < b; ) {
        var S = (k = l[h++]) >> 16 & 248 | k >> 13 & 7, k = k >> 5 & 224 | k >> 3 & 31;
        y[x++] = S, y[x++] = k;
      }
    }
    function Nt(l, h, b, y, x) {
      for (b = h + b; h < b; ) {
        var S = l[h++];
        y[x++] = 255 & S, y[x++] = S >> 8 & 255, y[x++] = S >> 16 & 255;
      }
    }
    function Qe(l, h, b, y, x, S) {
      if (S == 0) for (b = h + b; h < b; ) Ie(y, ((S = l[h++])[0] >> 24 | S[1] >> 8 & 65280 | S[2] << 8 & 16711680 | S[3] << 24) >>> 0), x += 32;
      else r(y, x, l, h, b);
    }
    function kt(l, h) {
      z[h][0] = z[l + "0"], z[h][1] = z[l + "1"], z[h][2] = z[l + "2"], z[h][3] = z[l + "3"], z[h][4] = z[l + "4"], z[h][5] = z[l + "5"], z[h][6] = z[l + "6"], z[h][7] = z[l + "7"], z[h][8] = z[l + "8"], z[h][9] = z[l + "9"], z[h][10] = z[l + "10"], z[h][11] = z[l + "11"], z[h][12] = z[l + "12"], z[h][13] = z[l + "13"], z[h][14] = z[l + "0"], z[h][15] = z[l + "0"];
    }
    function lt(l) {
      return l == _l || l == Al || l == Ko || l == wl;
    }
    function Et() {
      this.eb = [], this.size = this.A = this.fb = 0;
    }
    function Jt() {
      this.y = [], this.f = [], this.ea = [], this.F = [], this.Tc = this.Ed = this.Cd = this.Fd = this.lb = this.Db = this.Ab = this.fa = this.J = this.W = this.N = this.O = 0;
    }
    function vt() {
      this.Rd = this.height = this.width = this.S = 0, this.f = {}, this.f.RGBA = new Et(), this.f.kb = new Jt(), this.sd = null;
    }
    function ot() {
      this.width = [0], this.height = [0], this.Pd = [0], this.Qd = [0], this.format = [0];
    }
    function Mt() {
      this.Id = this.fd = this.Md = this.hb = this.ib = this.da = this.bd = this.cd = this.j = this.v = this.Da = this.Sd = this.ob = 0;
    }
    function na(l) {
      return alert("todo:WebPSamplerProcessPlane"), l.T;
    }
    function Mn(l, h) {
      var b = l.T, y = h.ba.f.RGBA, x = y.eb, S = y.fb + l.ka * y.A, k = xr[h.ba.S], P = l.y, O = l.O, H = l.f, ne = l.N, pe = l.ea, j = l.W, re = h.cc, oe = h.dc, Te = h.Mc, de = h.Nc, _e = l.ka, Ne = l.ka + l.T, Pe = l.U, Le = Pe + 1 >> 1;
      for (_e == 0 ? k(P, O, null, null, H, ne, pe, j, H, ne, pe, j, x, S, null, null, Pe) : (k(h.ec, h.fc, P, O, re, oe, Te, de, H, ne, pe, j, x, S - y.A, x, S, Pe), ++b); _e + 2 < Ne; _e += 2) re = H, oe = ne, Te = pe, de = j, ne += l.Rc, j += l.Rc, S += 2 * y.A, k(P, (O += 2 * l.fa) - l.fa, P, O, re, oe, Te, de, H, ne, pe, j, x, S - y.A, x, S, Pe);
      return O += l.fa, l.j + Ne < l.o ? (r(h.ec, h.fc, P, O, Pe), r(h.cc, h.dc, H, ne, Le), r(h.Mc, h.Nc, pe, j, Le), b--) : 1 & Ne || k(P, O, null, null, H, ne, pe, j, H, ne, pe, j, x, S + y.A, null, null, Pe), b;
    }
    function ai(l, h, b) {
      var y = l.F, x = [l.J];
      if (y != null) {
        var S = l.U, k = h.ba.S, P = k == Xo || k == Ko;
        h = h.ba.f.RGBA;
        var O = [0], H = l.ka;
        O[0] = l.T, l.Kb && (H == 0 ? --O[0] : (--H, x[0] -= l.width), l.j + l.ka + l.T == l.o && (O[0] = l.o - l.j - H));
        var ne = h.eb;
        H = h.fb + H * h.A, l = Rf(y, x[0], l.width, S, O, ne, H + (P ? 0 : 3), h.A), t(b == O), l && lt(k) && Hs(ne, H, P, S, O, h.A);
      }
      return 0;
    }
    function qr(l) {
      var h = l.ma, b = h.ba.S, y = 11 > b, x = b == Go || b == $o || b == Xo || b == Tl || b == 12 || lt(b);
      if (h.memory = null, h.Ib = null, h.Jb = null, h.Nd = null, !Ps(h.Oa, l, x ? 11 : 12)) return 0;
      if (x && lt(b) && ks(), l.da) alert("todo:use_scaling");
      else {
        if (y) {
          if (h.Ib = na, l.Kb) {
            if (b = l.U + 1 >> 1, h.memory = a(l.U + 2 * b), h.memory == null) return 0;
            h.ec = h.memory, h.fc = 0, h.cc = h.ec, h.dc = h.fc + l.U, h.Mc = h.cc, h.Nc = h.dc + b, h.Ib = Mn, ks();
          }
        } else alert("todo:EmitYUV");
        x && (h.Jb = ai, y && Pr());
      }
      if (y && !Kf) {
        for (l = 0; 256 > l; ++l) nm[l] = 89858 * (l - 128) + Jo >> Qo, am[l] = -22014 * (l - 128) + Jo, im[l] = -45773 * (l - 128), rm[l] = 113618 * (l - 128) + Jo >> Qo;
        for (l = qs; l < vl; ++l) h = 76283 * (l - 16) + Jo >> Qo, sm[l - qs] = Wr(h, 255), om[l - qs] = Wr(h + 8 >> 4, 15);
        Kf = 1;
      }
      return 1;
    }
    function ut(l) {
      var h = l.ma, b = l.U, y = l.T;
      return t(!(1 & l.ka)), 0 >= b || 0 >= y ? 0 : (b = h.Ib(l, h), h.Jb != null && h.Jb(l, h, b), h.Dc += b, 1);
    }
    function si(l) {
      l.ma.memory = null;
    }
    function oi(l, h, b, y) {
      return xe(l, 8) != 47 ? 0 : (h[0] = xe(l, 14) + 1, b[0] = xe(l, 14) + 1, y[0] = xe(l, 1), xe(l, 3) != 0 ? 0 : !l.h);
    }
    function gr(l, h) {
      if (4 > l) return l + 1;
      var b = l - 2 >> 1;
      return (2 + (1 & l) << b) + xe(h, b) + 1;
    }
    function br(l, h) {
      return 120 < h ? h - 120 : 1 <= (b = ((b = qp[h - 1]) >> 4) * l + (8 - (15 & b))) ? b : 1;
      var b;
    }
    function nn(l, h, b) {
      var y = G(b), x = l[h += 255 & y].g - 8;
      return 0 < x && (te(b, b.u + 8), y = G(b), h += l[h].value, h += y & (1 << x) - 1), te(b, b.u + l[h].g), l[h].value;
    }
    function vn(l, h, b) {
      return b.g += l.g, b.value += l.value << h >>> 0, t(8 >= b.g), l.g;
    }
    function Cn(l, h, b) {
      var y = l.xc;
      return t((h = y == 0 ? 0 : l.vc[l.md * (b >> y) + (h >> y)]) < l.Wb), l.Ya[h];
    }
    function ra(l, h, b, y) {
      var x = l.ab, S = l.c * h, k = l.C;
      h = k + h;
      var P = b, O = y;
      for (y = l.Ta, b = l.Ua; 0 < x--; ) {
        var H = l.gc[x], ne = k, pe = h, j = P, re = O, oe = (O = y, P = b, H.Ea);
        switch (t(ne < pe), t(pe <= H.nc), H.hc) {
          case 2:
            on(j, re, (pe - ne) * oe, O, P);
            break;
          case 0:
            var Te = ne, de = pe, _e = O, Ne = P, Pe = ($e = H).Ea;
            Te == 0 && (Rs(j, re, null, null, 1, _e, Ne), ve(j, re + 1, 0, 0, Pe - 1, _e, Ne + 1), re += Pe, Ne += Pe, ++Te);
            for (var Le = 1 << $e.b, Ze = Le - 1, We = ke(Pe, $e.b), _t = $e.K, $e = $e.w + (Te >> $e.b) * We; Te < de; ) {
              var Ct = _t, An = $e, At = 1;
              for (za(j, re, _e, Ne - Pe, 1, _e, Ne); At < Pe; ) {
                var Xe = (At & ~Ze) + Le;
                Xe > Pe && (Xe = Pe), (0, Ms[Ct[An++] >> 8 & 15])(j, re + +At, _e, Ne + At - Pe, Xe - At, _e, Ne + At), At = Xe;
              }
              re += Pe, Ne += Pe, ++Te & Ze || ($e += We);
            }
            pe != H.nc && r(O, P - oe, O, P + (pe - ne - 1) * oe, oe);
            break;
          case 1:
            for (oe = j, de = re, Pe = (j = H.Ea) - (Ne = j & ~(_e = (re = 1 << H.b) - 1)), Te = ke(j, H.b), Le = H.K, H = H.w + (ne >> H.b) * Te; ne < pe; ) {
              for (Ze = Le, We = H, _t = new it(), $e = de + Ne, Ct = de + j; de < $e; ) Re(Ze[We++], _t), Fs(_t, oe, de, re, O, P), de += re, P += re;
              de < Ct && (Re(Ze[We++], _t), Fs(_t, oe, de, Pe, O, P), de += Pe, P += Pe), ++ne & _e || (H += Te);
            }
            break;
          case 3:
            if (j == O && re == P && 0 < H.b) {
              for (de = O, j = oe = P + (pe - ne) * oe - (Ne = (pe - ne) * ke(H.Ea, H.b)), re = O, _e = P, Te = [], Ne = (Pe = Ne) - 1; 0 <= Ne; --Ne) Te[Ne] = re[_e + Ne];
              for (Ne = Pe - 1; 0 <= Ne; --Ne) de[j + Ne] = Te[Ne];
              zo(H, ne, pe, O, oe, O, P);
            } else zo(H, ne, pe, j, re, O, P);
        }
        P = y, O = b;
      }
      O != b && r(y, b, P, O, S);
    }
    function Li(l, h) {
      var b = l.V, y = l.Ba + l.c * l.C, x = h - l.C;
      if (t(h <= l.l.o), t(16 >= x), 0 < x) {
        var S = l.l, k = l.Ta, P = l.Ua, O = S.width;
        if (ra(l, x, b, y), x = P = [P], t((b = l.C) < (y = h)), t(S.v < S.va), y > S.o && (y = S.o), b < S.j) {
          var H = S.j - b;
          b = S.j, x[0] += H * O;
        }
        if (b >= y ? b = 0 : (x[0] += 4 * S.v, S.ka = b - S.j, S.U = S.va - S.v, S.T = y - b, b = 1), b) {
          if (P = P[0], 11 > (b = l.ca).S) {
            var ne = b.f.RGBA, pe = (y = b.S, x = S.U, S = S.T, H = ne.eb, ne.A), j = S;
            for (ne = ne.fb + l.Ma * ne.A; 0 < j--; ) {
              var re = k, oe = P, Te = x, de = H, _e = ne;
              switch (y) {
                case Vo:
                  Bs(re, oe, Te, de, _e);
                  break;
                case Go:
                  Ri(re, oe, Te, de, _e);
                  break;
                case _l:
                  Ri(re, oe, Te, de, _e), Hs(de, _e, 0, Te, 1, 0);
                  break;
                case jf:
                  ba(re, oe, Te, de, _e);
                  break;
                case $o:
                  Qe(re, oe, Te, de, _e, 1);
                  break;
                case Al:
                  Qe(re, oe, Te, de, _e, 1), Hs(de, _e, 0, Te, 1, 0);
                  break;
                case Xo:
                  Qe(re, oe, Te, de, _e, 0);
                  break;
                case Ko:
                  Qe(re, oe, Te, de, _e, 0), Hs(de, _e, 1, Te, 1, 0);
                  break;
                case Tl:
                  Di(re, oe, Te, de, _e);
                  break;
                case wl:
                  Di(re, oe, Te, de, _e), Of(de, _e, Te, 1, 0);
                  break;
                case qf:
                  Mi(re, oe, Te, de, _e);
                  break;
                default:
                  t(0);
              }
              P += O, ne += pe;
            }
            l.Ma += S;
          } else alert("todo:EmitRescaledRowsYUVA");
          t(l.Ma <= b.height);
        }
      }
      l.C = h, t(l.C <= l.i);
    }
    function Lr(l) {
      var h;
      if (0 < l.ua) return 0;
      for (h = 0; h < l.Wb; ++h) {
        var b = l.Ya[h].G, y = l.Ya[h].H;
        if (0 < b[1][y[1] + 0].g || 0 < b[2][y[2] + 0].g || 0 < b[3][y[3] + 0].g) return 0;
      }
      return 1;
    }
    function zr(l, h, b, y, x, S) {
      if (l.Z != 0) {
        var k = l.qd, P = l.rd;
        for (t(Ui[l.Z] != null); h < b; ++h) Ui[l.Z](k, P, y, x, y, x, S), k = y, P = x, x += S;
        l.qd = k, l.rd = P;
      }
    }
    function kr(l, h) {
      var b = l.l.ma, y = b.Z == 0 || b.Z == 1 ? l.l.j : l.C;
      if (y = l.C < y ? y : l.C, t(h <= l.l.o), h > y) {
        var x = l.l.width, S = b.ca, k = b.tb + x * y, P = l.V, O = l.Ba + l.c * y, H = l.gc;
        t(l.ab == 1), t(H[0].hc == 3), Xr(H[0], y, h, P, O, S, k), zr(b, y, h, S, k, x);
      }
      l.C = l.Ma = h;
    }
    function Cr(l, h, b, y, x, S, k) {
      var P = l.$ / y, O = l.$ % y, H = l.m, ne = l.s, pe = b + l.$, j = pe;
      x = b + y * x;
      var re = b + y * S, oe = 280 + ne.ua, Te = l.Pb ? P : 16777216, de = 0 < ne.ua ? ne.Wa : null, _e = ne.wc, Ne = pe < re ? Cn(ne, O, P) : null;
      t(l.C < S), t(re <= x);
      var Pe = !1;
      e: for (; ; ) {
        for (; Pe || pe < re; ) {
          var Le = 0;
          if (P >= Te) {
            var Ze = pe - b;
            t((Te = l).Pb), Te.wd = Te.m, Te.xd = Ze, 0 < Te.s.ua && Ue(Te.s.Wa, Te.s.vb), Te = P + Yp;
          }
          if (O & _e || (Ne = Cn(ne, O, P)), t(Ne != null), Ne.Qb && (h[pe] = Ne.qb, Pe = !0), !Pe) if (le(H), Ne.jc) {
            Le = H, Ze = h;
            var We = pe, _t = Ne.pd[G(Le) & ga - 1];
            t(Ne.jc), 256 > _t.g ? (te(Le, Le.u + _t.g), Ze[We] = _t.value, Le = 0) : (te(Le, Le.u + _t.g - 256), t(256 <= _t.value), Le = _t.value), Le == 0 && (Pe = !0);
          } else Le = nn(Ne.G[0], Ne.H[0], H);
          if (H.h) break;
          if (Pe || 256 > Le) {
            if (!Pe) if (Ne.nd) h[pe] = (Ne.qb | Le << 8) >>> 0;
            else {
              if (le(H), Pe = nn(Ne.G[1], Ne.H[1], H), le(H), Ze = nn(Ne.G[2], Ne.H[2], H), We = nn(Ne.G[3], Ne.H[3], H), H.h) break;
              h[pe] = (We << 24 | Pe << 16 | Le << 8 | Ze) >>> 0;
            }
            if (Pe = !1, ++pe, ++O >= y && (O = 0, ++P, k != null && P <= S && !(P % 16) && k(l, P), de != null)) for (; j < pe; ) Le = h[j++], de.X[(506832829 * Le & 4294967295) >>> de.Mb] = Le;
          } else if (280 > Le) {
            if (Le = gr(Le - 256, H), Ze = nn(Ne.G[4], Ne.H[4], H), le(H), Ze = br(y, Ze = gr(Ze, H)), H.h) break;
            if (pe - b < Ze || x - pe < Le) break e;
            for (We = 0; We < Le; ++We) h[pe + We] = h[pe + We - Ze];
            for (pe += Le, O += Le; O >= y; ) O -= y, ++P, k != null && P <= S && !(P % 16) && k(l, P);
            if (t(pe <= x), O & _e && (Ne = Cn(ne, O, P)), de != null) for (; j < pe; ) Le = h[j++], de.X[(506832829 * Le & 4294967295) >>> de.Mb] = Le;
          } else {
            if (!(Le < oe)) break e;
            for (Pe = Le - 280, t(de != null); j < pe; ) Le = h[j++], de.X[(506832829 * Le & 4294967295) >>> de.Mb] = Le;
            Le = pe, t(!(Pe >>> (Ze = de).Xa)), h[Le] = Ze.X[Pe], Pe = !0;
          }
          Pe || t(H.h == ee(H));
        }
        if (l.Pb && H.h && pe < x) t(l.m.h), l.a = 5, l.m = l.wd, l.$ = l.xd, 0 < l.s.ua && Ue(l.s.vb, l.s.Wa);
        else {
          if (H.h) break e;
          k != null && k(l, P > S ? S : P), l.a = 0, l.$ = pe - b;
        }
        return 1;
      }
      return l.a = 3, 0;
    }
    function Er(l) {
      t(l != null), l.vc = null, l.yc = null, l.Ya = null;
      var h = l.Wa;
      h != null && (h.X = null), l.vb = null, t(l != null);
    }
    function ia() {
      var l = new ft();
      return l == null ? null : (l.a = 0, l.xb = Wf, kt("Predictor", "VP8LPredictors"), kt("Predictor", "VP8LPredictors_C"), kt("PredictorAdd", "VP8LPredictorsAdd"), kt("PredictorAdd", "VP8LPredictorsAdd_C"), on = Fe, Fs = qe, Bs = Bt, Ri = bt, Di = ht, Mi = dt, ba = Nt, z.VP8LMapColor32b = $r, z.VP8LMapColor8b = Ds, l);
    }
    function Yr(l, h, b, y, x) {
      var S = 1, k = [l], P = [h], O = y.m, H = y.s, ne = null, pe = 0;
      e: for (; ; ) {
        if (b) for (; S && xe(O, 1); ) {
          var j = k, re = P, oe = y, Te = 1, de = oe.m, _e = oe.gc[oe.ab], Ne = xe(de, 2);
          if (oe.Oc & 1 << Ne) S = 0;
          else {
            switch (oe.Oc |= 1 << Ne, _e.hc = Ne, _e.Ea = j[0], _e.nc = re[0], _e.K = [null], ++oe.ab, t(4 >= oe.ab), Ne) {
              case 0:
              case 1:
                _e.b = xe(de, 3) + 2, Te = Yr(ke(_e.Ea, _e.b), ke(_e.nc, _e.b), 0, oe, _e.K), _e.K = _e.K[0];
                break;
              case 3:
                var Pe, Le = xe(de, 8) + 1, Ze = 16 < Le ? 0 : 4 < Le ? 1 : 2 < Le ? 2 : 3;
                if (j[0] = ke(_e.Ea, Ze), _e.b = Ze, Pe = Te = Yr(Le, 1, 0, oe, _e.K)) {
                  var We, _t = Le, $e = _e, Ct = 1 << (8 >> $e.b), An = a(Ct);
                  if (An == null) Pe = 0;
                  else {
                    var At = $e.K[0], Xe = $e.w;
                    for (An[0] = $e.K[0][0], We = 1; We < 1 * _t; ++We) An[We] = rt(At[Xe + We], An[We - 1]);
                    for (; We < 4 * Ct; ++We) An[We] = 0;
                    $e.K[0] = null, $e.K[0] = An, Pe = 1;
                  }
                }
                Te = Pe;
                break;
              case 2:
                break;
              default:
                t(0);
            }
            S = Te;
          }
        }
        if (k = k[0], P = P[0], S && xe(O, 1) && !(S = 1 <= (pe = xe(O, 4)) && 11 >= pe)) {
          y.a = 3;
          break e;
        }
        var Be;
        if (Be = S) t: {
          var ln, yt, It, Kt = y, On = k, Vn = P, rn = pe, Fn = b, Gn = Kt.m, wn = Kt.s, Rt = [null], Ut = 1, an = 0, Ht = zp[rn];
          n: for (; ; ) {
            if (Fn && xe(Gn, 1)) {
              var Rn = xe(Gn, 3) + 2, Rr = ke(On, Rn), cn = ke(Vn, Rn), Kn = Rr * cn;
              if (!Yr(Rr, cn, 0, Kt, Rt)) break n;
              for (Rt = Rt[0], wn.xc = Rn, ln = 0; ln < Kn; ++ln) {
                var Yt = Rt[ln] >> 8 & 65535;
                Rt[ln] = Yt, Yt >= Ut && (Ut = Yt + 1);
              }
            }
            if (Gn.h) break n;
            for (yt = 0; 5 > yt; ++yt) {
              var xn = zf[yt];
              !yt && 0 < rn && (xn += 1 << rn), an < xn && (an = xn);
            }
            var sr = s(Ut * Ht, $), $n = Ut, or = s($n, J);
            if (or == null) var ur = null;
            else t(65536 >= $n), ur = or;
            var Qn = a(an);
            if (ur == null || Qn == null || sr == null) {
              Kt.a = 1;
              break n;
            }
            var lr = sr;
            for (ln = It = 0; ln < Ut; ++ln) {
              var $t = ur[ln], cr = $t.G, Dr = $t.H, ya = 0, _i = 1, Dn = 0;
              for (yt = 0; 5 > yt; ++yt) {
                xn = zf[yt], cr[yt] = lr, Dr[yt] = It, !yt && 0 < rn && (xn += 1 << rn);
                i: {
                  var eu, Sl = xn, tu = Kt, zs = Qn, cm = lr, fm = It, Ll = 0, Hi = tu.m, hm = xe(Hi, 1);
                  if (i(zs, 0, 0, Sl), hm) {
                    var dm = xe(Hi, 1) + 1, pm = xe(Hi, 1), Zf = xe(Hi, pm == 0 ? 1 : 8);
                    zs[Zf] = 1, dm == 2 && (zs[Zf = xe(Hi, 8)] = 1);
                    var nu = 1;
                  } else {
                    var eh = a(19), th = xe(Hi, 4) + 4;
                    if (19 < th) {
                      tu.a = 3;
                      var ru = 0;
                      break i;
                    }
                    for (eu = 0; eu < th; ++eu) eh[jp[eu]] = xe(Hi, 3);
                    var kl = void 0, Ys = void 0, nh = tu, mm = eh, iu = Sl, rh = zs, Cl = 0, ji = nh.m, ih = 8, ah = s(128, $);
                    r: for (; I(ah, 0, 7, mm, 19); ) {
                      if (xe(ji, 1)) {
                        var gm = 2 + 2 * xe(ji, 3);
                        if ((kl = 2 + xe(ji, gm)) > iu) break r;
                      } else kl = iu;
                      for (Ys = 0; Ys < iu && kl--; ) {
                        le(ji);
                        var sh = ah[0 + (127 & G(ji))];
                        te(ji, ji.u + sh.g);
                        var Wa = sh.value;
                        if (16 > Wa) rh[Ys++] = Wa, Wa != 0 && (ih = Wa);
                        else {
                          var bm = Wa == 16, oh = Wa - 16, Em = Up[oh], uh = xe(ji, Bp[oh]) + Em;
                          if (Ys + uh > iu) break r;
                          for (var ym = bm ? ih : 0; 0 < uh--; ) rh[Ys++] = ym;
                        }
                      }
                      Cl = 1;
                      break r;
                    }
                    Cl || (nh.a = 3), nu = Cl;
                  }
                  (nu = nu && !Hi.h) && (Ll = I(cm, fm, 8, zs, Sl)), nu && Ll != 0 ? ru = Ll : (tu.a = 3, ru = 0);
                }
                if (ru == 0) break n;
                if (_i && Hp[yt] == 1 && (_i = lr[It].g == 0), ya += lr[It].g, It += ru, 3 >= yt) {
                  var Ws, Il = Qn[0];
                  for (Ws = 1; Ws < xn; ++Ws) Qn[Ws] > Il && (Il = Qn[Ws]);
                  Dn += Il;
                }
              }
              if ($t.nd = _i, $t.Qb = 0, _i && ($t.qb = (cr[3][Dr[3] + 0].value << 24 | cr[1][Dr[1] + 0].value << 16 | cr[2][Dr[2] + 0].value) >>> 0, ya == 0 && 256 > cr[0][Dr[0] + 0].value && ($t.Qb = 1, $t.qb += cr[0][Dr[0] + 0].value << 8)), $t.jc = !$t.Qb && 6 > Dn, $t.jc) {
                var au, Ai = $t;
                for (au = 0; au < ga; ++au) {
                  var qi = au, zi = Ai.pd[qi], su = Ai.G[0][Ai.H[0] + qi];
                  256 <= su.value ? (zi.g = su.g + 256, zi.value = su.value) : (zi.g = 0, zi.value = 0, qi >>= vn(su, 8, zi), qi >>= vn(Ai.G[1][Ai.H[1] + qi], 16, zi), qi >>= vn(Ai.G[2][Ai.H[2] + qi], 0, zi), vn(Ai.G[3][Ai.H[3] + qi], 24, zi));
                }
              }
            }
            wn.vc = Rt, wn.Wb = Ut, wn.Ya = ur, wn.yc = sr, Be = 1;
            break t;
          }
          Be = 0;
        }
        if (!(S = Be)) {
          y.a = 3;
          break e;
        }
        if (0 < pe) {
          if (H.ua = 1 << pe, !F(H.Wa, pe)) {
            y.a = 1, S = 0;
            break e;
          }
        } else H.ua = 0;
        var Pl = y, lh = k, Tm = P, Ol = Pl.s, Rl = Ol.xc;
        if (Pl.c = lh, Pl.i = Tm, Ol.md = ke(lh, Rl), Ol.wc = Rl == 0 ? -1 : (1 << Rl) - 1, b) {
          y.xb = Qp;
          break e;
        }
        if ((ne = a(k * P)) == null) {
          y.a = 1, S = 0;
          break e;
        }
        S = (S = Cr(y, ne, 0, k, P, P, null)) && !O.h;
        break e;
      }
      return S ? (x != null ? x[0] = ne : (t(ne == null), t(b)), y.$ = 0, b || Er(H)) : Er(H), S;
    }
    function aa(l, h) {
      var b = l.c * l.i, y = b + h + 16 * h;
      return t(l.c <= h), l.V = a(y), l.V == null ? (l.Ta = null, l.Ua = 0, l.a = 1, 0) : (l.Ta = l.V, l.Ua = l.Ba + b + h, 1);
    }
    function Oa(l, h) {
      var b = l.C, y = h - b, x = l.V, S = l.Ba + l.c * b;
      for (t(h <= l.l.o); 0 < y; ) {
        var k = 16 < y ? 16 : y, P = l.l.ma, O = l.l.width, H = O * k, ne = P.ca, pe = P.tb + O * b, j = l.Ta, re = l.Ua;
        ra(l, k, x, S), Df(j, re, ne, pe, H), zr(P, b, b + k, ne, pe, O), y -= k, x += k * l.c, b += k;
      }
      t(b == h), l.C = l.Ma = h;
    }
    function Ra() {
      this.ub = this.yd = this.td = this.Rb = 0;
    }
    function Da() {
      this.Kd = this.Ld = this.Ud = this.Td = this.i = this.c = 0;
    }
    function rl() {
      this.Fb = this.Bb = this.Cb = 0, this.Zb = a(4), this.Lb = a(4);
    }
    function Es() {
      this.Yb = (function() {
        var l = [];
        return (function h(b, y, x) {
          for (var S = x[y], k = 0; k < S && (b.push(x.length > y + 1 ? [] : 0), !(x.length < y + 1)); k++) h(b[k], y + 1, x);
        })(l, 0, [3, 11]), l;
      })();
    }
    function No() {
      this.jb = a(3), this.Wc = o([4, 8], Es), this.Xc = o([4, 17], Es);
    }
    function vo() {
      this.Pc = this.wb = this.Tb = this.zd = 0, this.vd = new a(4), this.od = new a(4);
    }
    function yr() {
      this.ld = this.La = this.dd = this.tc = 0;
    }
    function ys() {
      this.Na = this.la = 0;
    }
    function So() {
      this.Sc = [0, 0], this.Eb = [0, 0], this.Qc = [0, 0], this.ia = this.lc = 0;
    }
    function Ts() {
      this.ad = a(384), this.Za = 0, this.Ob = a(16), this.$b = this.Ad = this.ia = this.Gc = this.Hc = this.Dd = 0;
    }
    function Lo() {
      this.uc = this.M = this.Nb = 0, this.wa = Array(new yr()), this.Y = 0, this.ya = Array(new Ts()), this.aa = 0, this.l = new Ma();
    }
    function ko() {
      this.y = a(16), this.f = a(8), this.ea = a(8);
    }
    function Co() {
      this.cb = this.a = 0, this.sc = "", this.m = new L(), this.Od = new Ra(), this.Kc = new Da(), this.ed = new vo(), this.Qa = new rl(), this.Ic = this.$c = this.Aa = 0, this.D = new Lo(), this.Xb = this.Va = this.Hb = this.zb = this.yb = this.Ub = this.za = 0, this.Jc = s(8, L), this.ia = 0, this.pb = s(4, So), this.Pa = new No(), this.Bd = this.kc = 0, this.Ac = [], this.Bc = 0, this.zc = [0, 0, 0, 0], this.Gd = Array(new ko()), this.Hd = 0, this.rb = Array(new ys()), this.sb = 0, this.wa = Array(new yr()), this.Y = 0, this.oc = [], this.pc = 0, this.sa = [], this.ta = 0, this.qa = [], this.ra = 0, this.Ha = [], this.B = this.R = this.Ia = 0, this.Ec = [], this.M = this.ja = this.Vb = this.Fc = 0, this.ya = Array(new Ts()), this.L = this.aa = 0, this.gd = o([4, 2], yr), this.ga = null, this.Fa = [], this.Cc = this.qc = this.P = 0, this.Gb = [], this.Uc = 0, this.mb = [], this.nb = 0, this.rc = [], this.Ga = this.Vc = 0;
    }
    function Wr(l, h) {
      return 0 > l ? 0 : l > h ? h : l;
    }
    function Ma() {
      this.T = this.U = this.ka = this.height = this.width = 0, this.y = [], this.f = [], this.ea = [], this.Rc = this.fa = this.W = this.N = this.O = 0, this.ma = "void", this.put = "VP8IoPutHook", this.ac = "VP8IoSetupHook", this.bc = "VP8IoTeardownHook", this.ha = this.Kb = 0, this.data = [], this.hb = this.ib = this.da = this.o = this.j = this.va = this.v = this.Da = this.ob = this.w = 0, this.F = [], this.J = 0;
    }
    function il() {
      var l = new Co();
      return l != null && (l.a = 0, l.sc = "OK", l.cb = 0, l.Xb = 0, js || (js = Fa)), l;
    }
    function mn(l, h, b) {
      return l.a == 0 && (l.a = h, l.sc = b, l.cb = 0), 0;
    }
    function Io(l, h, b) {
      return 3 <= b && l[h + 0] == 157 && l[h + 1] == 1 && l[h + 2] == 42;
    }
    function Vr(l, h) {
      if (l == null) return 0;
      if (l.a = 0, l.sc = "OK", h == null) return mn(l, 2, "null VP8Io passed to VP8GetHeaders()");
      var b = h.data, y = h.w, x = h.ha;
      if (4 > x) return mn(l, 7, "Truncated header.");
      var S = b[y + 0] | b[y + 1] << 8 | b[y + 2] << 16, k = l.Od;
      if (k.Rb = !(1 & S), k.td = S >> 1 & 7, k.yd = S >> 4 & 1, k.ub = S >> 5, 3 < k.td) return mn(l, 3, "Incorrect keyframe parameters.");
      if (!k.yd) return mn(l, 4, "Frame not displayable.");
      y += 3, x -= 3;
      var P = l.Kc;
      if (k.Rb) {
        if (7 > x) return mn(l, 7, "cannot parse picture header");
        if (!Io(b, y, x)) return mn(l, 3, "Bad code word");
        P.c = 16383 & (b[y + 4] << 8 | b[y + 3]), P.Td = b[y + 4] >> 6, P.i = 16383 & (b[y + 6] << 8 | b[y + 5]), P.Ud = b[y + 6] >> 6, y += 7, x -= 7, l.za = P.c + 15 >> 4, l.Ub = P.i + 15 >> 4, h.width = P.c, h.height = P.i, h.Da = 0, h.j = 0, h.v = 0, h.va = h.width, h.o = h.height, h.da = 0, h.ib = h.width, h.hb = h.height, h.U = h.width, h.T = h.height, i((S = l.Pa).jb, 0, 255, S.jb.length), t((S = l.Qa) != null), S.Cb = 0, S.Bb = 0, S.Fb = 1, i(S.Zb, 0, 0, S.Zb.length), i(S.Lb, 0, 0, S.Lb);
      }
      if (k.ub > x) return mn(l, 7, "bad partition length");
      ue(S = l.m, b, y, k.ub), y += k.ub, x -= k.ub, k.Rb && (P.Ld = be(S), P.Kd = be(S)), P = l.Qa;
      var O, H = l.Pa;
      if (t(S != null), t(P != null), P.Cb = be(S), P.Cb) {
        if (P.Bb = be(S), be(S)) {
          for (P.Fb = be(S), O = 0; 4 > O; ++O) P.Zb[O] = be(S) ? se(S, 7) : 0;
          for (O = 0; 4 > O; ++O) P.Lb[O] = be(S) ? se(S, 6) : 0;
        }
        if (P.Bb) for (O = 0; 3 > O; ++O) H.jb[O] = be(S) ? me(S, 8) : 255;
      } else P.Bb = 0;
      if (S.Ka) return mn(l, 3, "cannot parse segment header");
      if ((P = l.ed).zd = be(S), P.Tb = me(S, 6), P.wb = me(S, 3), P.Pc = be(S), P.Pc && be(S)) {
        for (H = 0; 4 > H; ++H) be(S) && (P.vd[H] = se(S, 6));
        for (H = 0; 4 > H; ++H) be(S) && (P.od[H] = se(S, 6));
      }
      if (l.L = P.Tb == 0 ? 0 : P.zd ? 1 : 2, S.Ka) return mn(l, 3, "cannot parse filter header");
      var ne = x;
      if (x = O = y, y = O + ne, P = ne, l.Xb = (1 << me(l.m, 2)) - 1, ne < 3 * (H = l.Xb)) b = 7;
      else {
        for (O += 3 * H, P -= 3 * H, ne = 0; ne < H; ++ne) {
          var pe = b[x + 0] | b[x + 1] << 8 | b[x + 2] << 16;
          pe > P && (pe = P), ue(l.Jc[+ne], b, O, pe), O += pe, P -= pe, x += 3;
        }
        ue(l.Jc[+H], b, O, P), b = O < y ? 0 : 5;
      }
      if (b != 0) return mn(l, b, "cannot parse partitions");
      for (b = me(O = l.m, 7), x = be(O) ? se(O, 4) : 0, y = be(O) ? se(O, 4) : 0, P = be(O) ? se(O, 4) : 0, H = be(O) ? se(O, 4) : 0, O = be(O) ? se(O, 4) : 0, ne = l.Qa, pe = 0; 4 > pe; ++pe) {
        if (ne.Cb) {
          var j = ne.Zb[pe];
          ne.Fb || (j += b);
        } else {
          if (0 < pe) {
            l.pb[pe] = l.pb[0];
            continue;
          }
          j = b;
        }
        var re = l.pb[pe];
        re.Sc[0] = xl[Wr(j + x, 127)], re.Sc[1] = Nl[Wr(j + 0, 127)], re.Eb[0] = 2 * xl[Wr(j + y, 127)], re.Eb[1] = 101581 * Nl[Wr(j + P, 127)] >> 16, 8 > re.Eb[1] && (re.Eb[1] = 8), re.Qc[0] = xl[Wr(j + H, 117)], re.Qc[1] = Nl[Wr(j + O, 127)], re.lc = j + O;
      }
      if (!k.Rb) return mn(l, 4, "Not a key frame.");
      for (be(S), k = l.Pa, b = 0; 4 > b; ++b) {
        for (x = 0; 8 > x; ++x) for (y = 0; 3 > y; ++y) for (P = 0; 11 > P; ++P) H = Ae(S, Xp[b][x][y][P]) ? me(S, 8) : Gp[b][x][y][P], k.Wc[b][x].Yb[y][P] = H;
        for (x = 0; 17 > x; ++x) k.Xc[b][x] = k.Wc[b][Kp[x]];
      }
      return l.kc = be(S), l.kc && (l.Bd = me(S, 8)), l.cb = 1;
    }
    function Fa(l, h, b, y, x, S, k) {
      var P = h[x].Yb[b];
      for (b = 0; 16 > x; ++x) {
        if (!Ae(l, P[b + 0])) return x;
        for (; !Ae(l, P[b + 1]); ) if (P = h[++x].Yb[0], b = 0, x == 16) return 16;
        var O = h[x + 1].Yb;
        if (Ae(l, P[b + 2])) {
          var H = l, ne = 0;
          if (Ae(H, (j = P)[(pe = b) + 3])) if (Ae(H, j[pe + 6])) {
            for (P = 0, pe = 2 * (ne = Ae(H, j[pe + 8])) + (j = Ae(H, j[pe + 9 + ne])), ne = 0, j = Wp[pe]; j[P]; ++P) ne += ne + Ae(H, j[P]);
            ne += 3 + (8 << pe);
          } else Ae(H, j[pe + 7]) ? (ne = 7 + 2 * Ae(H, 165), ne += Ae(H, 145)) : ne = 5 + Ae(H, 159);
          else ne = Ae(H, j[pe + 4]) ? 3 + Ae(H, j[pe + 5]) : 2;
          P = O[2];
        } else ne = 1, P = O[1];
        O = k + Vp[x], 0 > (H = l).b && ge(H);
        var pe, j = H.b, re = (pe = H.Ca >> 1) - (H.I >> j) >> 31;
        --H.b, H.Ca += re, H.Ca |= 1, H.I -= (pe + 1 & re) << j, S[O] = ((ne ^ re) - re) * y[(0 < x) + 0];
      }
      return 16;
    }
    function Po(l) {
      var h = l.rb[l.sb - 1];
      h.la = 0, h.Na = 0, i(l.zc, 0, 0, l.zc.length), l.ja = 0;
    }
    function Tr(l, h, b, y, x) {
      x = l[h + b + 32 * y] + (x >> 3), l[h + b + 32 * y] = -256 & x ? 0 > x ? 0 : 255 : x;
    }
    function yn(l, h, b, y, x, S) {
      Tr(l, h, 0, b, y + x), Tr(l, h, 1, b, y + S), Tr(l, h, 2, b, y - S), Tr(l, h, 3, b, y - x);
    }
    function ui(l) {
      return (20091 * l >> 16) + l;
    }
    function Oo(l, h, b, y) {
      var x, S = 0, k = a(16);
      for (x = 0; 4 > x; ++x) {
        var P = l[h + 0] + l[h + 8], O = l[h + 0] - l[h + 8], H = (35468 * l[h + 4] >> 16) - ui(l[h + 12]), ne = ui(l[h + 4]) + (35468 * l[h + 12] >> 16);
        k[S + 0] = P + ne, k[S + 1] = O + H, k[S + 2] = O - H, k[S + 3] = P - ne, S += 4, h++;
      }
      for (x = S = 0; 4 > x; ++x) P = (l = k[S + 0] + 4) + k[S + 8], O = l - k[S + 8], H = (35468 * k[S + 4] >> 16) - ui(k[S + 12]), Tr(b, y, 0, 0, P + (ne = ui(k[S + 4]) + (35468 * k[S + 12] >> 16))), Tr(b, y, 1, 0, O + H), Tr(b, y, 2, 0, O - H), Tr(b, y, 3, 0, P - ne), S++, y += 32;
    }
    function al(l, h, b, y) {
      var x = l[h + 0] + 4, S = 35468 * l[h + 4] >> 16, k = ui(l[h + 4]), P = 35468 * l[h + 1] >> 16;
      yn(b, y, 0, x + k, l = ui(l[h + 1]), P), yn(b, y, 1, x + S, l, P), yn(b, y, 2, x - S, l, P), yn(b, y, 3, x - k, l, P);
    }
    function sl(l, h, b, y, x) {
      Oo(l, h, b, y), x && Oo(l, h + 16, b, y + 4);
    }
    function Gr(l, h, b, y) {
      Ea(l, h + 0, b, y, 1), Ea(l, h + 32, b, y + 128, 1);
    }
    function Ro(l, h, b, y) {
      var x;
      for (l = l[h + 0] + 4, x = 0; 4 > x; ++x) for (h = 0; 4 > h; ++h) Tr(b, y, h, x, l);
    }
    function Do(l, h, b, y) {
      l[h + 0] && Ft(l, h + 0, b, y), l[h + 16] && Ft(l, h + 16, b, y + 4), l[h + 32] && Ft(l, h + 32, b, y + 128), l[h + 48] && Ft(l, h + 48, b, y + 128 + 4);
    }
    function Ba(l, h, b, y) {
      var x, S = a(16);
      for (x = 0; 4 > x; ++x) {
        var k = l[h + 0 + x] + l[h + 12 + x], P = l[h + 4 + x] + l[h + 8 + x], O = l[h + 4 + x] - l[h + 8 + x], H = l[h + 0 + x] - l[h + 12 + x];
        S[0 + x] = k + P, S[8 + x] = k - P, S[4 + x] = H + O, S[12 + x] = H - O;
      }
      for (x = 0; 4 > x; ++x) k = (l = S[0 + 4 * x] + 3) + S[3 + 4 * x], P = S[1 + 4 * x] + S[2 + 4 * x], O = S[1 + 4 * x] - S[2 + 4 * x], H = l - S[3 + 4 * x], b[y + 0] = k + P >> 3, b[y + 16] = H + O >> 3, b[y + 32] = k - P >> 3, b[y + 48] = H - O >> 3, y += 64;
    }
    function sa(l, h, b) {
      var y, x = h - 32, S = ar, k = 255 - l[x - 1];
      for (y = 0; y < b; ++y) {
        var P, O = S, H = k + l[h - 1];
        for (P = 0; P < b; ++P) l[h + P] = O[H + l[x + P]];
        h += 32;
      }
    }
    function ol(l, h) {
      sa(l, h, 4);
    }
    function ul(l, h) {
      sa(l, h, 8);
    }
    function ll(l, h) {
      sa(l, h, 16);
    }
    function _s(l, h) {
      var b;
      for (b = 0; 16 > b; ++b) r(l, h + 32 * b, l, h - 32, 16);
    }
    function Mo(l, h) {
      var b;
      for (b = 16; 0 < b; --b) i(l, h, l[h - 1], 16), h += 32;
    }
    function Ir(l, h, b) {
      var y;
      for (y = 0; 16 > y; ++y) i(h, b + 32 * y, l, 16);
    }
    function cl(l, h) {
      var b, y = 16;
      for (b = 0; 16 > b; ++b) y += l[h - 1 + 32 * b] + l[h + b - 32];
      Ir(y >> 5, l, h);
    }
    function oa(l, h) {
      var b, y = 8;
      for (b = 0; 16 > b; ++b) y += l[h - 1 + 32 * b];
      Ir(y >> 4, l, h);
    }
    function As(l, h) {
      var b, y = 8;
      for (b = 0; 16 > b; ++b) y += l[h + b - 32];
      Ir(y >> 4, l, h);
    }
    function fl(l, h) {
      Ir(128, l, h);
    }
    function pt(l, h, b) {
      return l + 2 * h + b + 2 >> 2;
    }
    function hl(l, h) {
      var b, y = h - 32;
      for (y = new Uint8Array([pt(l[y - 1], l[y + 0], l[y + 1]), pt(l[y + 0], l[y + 1], l[y + 2]), pt(l[y + 1], l[y + 2], l[y + 3]), pt(l[y + 2], l[y + 3], l[y + 4])]), b = 0; 4 > b; ++b) r(l, h + 32 * b, y, 0, y.length);
    }
    function dl(l, h) {
      var b = l[h - 1], y = l[h - 1 + 32], x = l[h - 1 + 64], S = l[h - 1 + 96];
      Ie(l, h + 0, 16843009 * pt(l[h - 1 - 32], b, y)), Ie(l, h + 32, 16843009 * pt(b, y, x)), Ie(l, h + 64, 16843009 * pt(y, x, S)), Ie(l, h + 96, 16843009 * pt(x, S, S));
    }
    function pl(l, h) {
      var b, y = 4;
      for (b = 0; 4 > b; ++b) y += l[h + b - 32] + l[h - 1 + 32 * b];
      for (y >>= 3, b = 0; 4 > b; ++b) i(l, h + 32 * b, y, 4);
    }
    function li(l, h) {
      var b = l[h - 1 + 0], y = l[h - 1 + 32], x = l[h - 1 + 64], S = l[h - 1 - 32], k = l[h + 0 - 32], P = l[h + 1 - 32], O = l[h + 2 - 32], H = l[h + 3 - 32];
      l[h + 0 + 96] = pt(y, x, l[h - 1 + 96]), l[h + 1 + 96] = l[h + 0 + 64] = pt(b, y, x), l[h + 2 + 96] = l[h + 1 + 64] = l[h + 0 + 32] = pt(S, b, y), l[h + 3 + 96] = l[h + 2 + 64] = l[h + 1 + 32] = l[h + 0 + 0] = pt(k, S, b), l[h + 3 + 64] = l[h + 2 + 32] = l[h + 1 + 0] = pt(P, k, S), l[h + 3 + 32] = l[h + 2 + 0] = pt(O, P, k), l[h + 3 + 0] = pt(H, O, P);
    }
    function ci(l, h) {
      var b = l[h + 1 - 32], y = l[h + 2 - 32], x = l[h + 3 - 32], S = l[h + 4 - 32], k = l[h + 5 - 32], P = l[h + 6 - 32], O = l[h + 7 - 32];
      l[h + 0 + 0] = pt(l[h + 0 - 32], b, y), l[h + 1 + 0] = l[h + 0 + 32] = pt(b, y, x), l[h + 2 + 0] = l[h + 1 + 32] = l[h + 0 + 64] = pt(y, x, S), l[h + 3 + 0] = l[h + 2 + 32] = l[h + 1 + 64] = l[h + 0 + 96] = pt(x, S, k), l[h + 3 + 32] = l[h + 2 + 64] = l[h + 1 + 96] = pt(S, k, P), l[h + 3 + 64] = l[h + 2 + 96] = pt(k, P, O), l[h + 3 + 96] = pt(P, O, O);
    }
    function ml(l, h) {
      var b = l[h - 1 + 0], y = l[h - 1 + 32], x = l[h - 1 + 64], S = l[h - 1 - 32], k = l[h + 0 - 32], P = l[h + 1 - 32], O = l[h + 2 - 32], H = l[h + 3 - 32];
      l[h + 0 + 0] = l[h + 1 + 64] = S + k + 1 >> 1, l[h + 1 + 0] = l[h + 2 + 64] = k + P + 1 >> 1, l[h + 2 + 0] = l[h + 3 + 64] = P + O + 1 >> 1, l[h + 3 + 0] = O + H + 1 >> 1, l[h + 0 + 96] = pt(x, y, b), l[h + 0 + 64] = pt(y, b, S), l[h + 0 + 32] = l[h + 1 + 96] = pt(b, S, k), l[h + 1 + 32] = l[h + 2 + 96] = pt(S, k, P), l[h + 2 + 32] = l[h + 3 + 96] = pt(k, P, O), l[h + 3 + 32] = pt(P, O, H);
    }
    function gl(l, h) {
      var b = l[h + 0 - 32], y = l[h + 1 - 32], x = l[h + 2 - 32], S = l[h + 3 - 32], k = l[h + 4 - 32], P = l[h + 5 - 32], O = l[h + 6 - 32], H = l[h + 7 - 32];
      l[h + 0 + 0] = b + y + 1 >> 1, l[h + 1 + 0] = l[h + 0 + 64] = y + x + 1 >> 1, l[h + 2 + 0] = l[h + 1 + 64] = x + S + 1 >> 1, l[h + 3 + 0] = l[h + 2 + 64] = S + k + 1 >> 1, l[h + 0 + 32] = pt(b, y, x), l[h + 1 + 32] = l[h + 0 + 96] = pt(y, x, S), l[h + 2 + 32] = l[h + 1 + 96] = pt(x, S, k), l[h + 3 + 32] = l[h + 2 + 96] = pt(S, k, P), l[h + 3 + 64] = pt(k, P, O), l[h + 3 + 96] = pt(P, O, H);
    }
    function Ua(l, h) {
      var b = l[h - 1 + 0], y = l[h - 1 + 32], x = l[h - 1 + 64], S = l[h - 1 + 96];
      l[h + 0 + 0] = b + y + 1 >> 1, l[h + 2 + 0] = l[h + 0 + 32] = y + x + 1 >> 1, l[h + 2 + 32] = l[h + 0 + 64] = x + S + 1 >> 1, l[h + 1 + 0] = pt(b, y, x), l[h + 3 + 0] = l[h + 1 + 32] = pt(y, x, S), l[h + 3 + 32] = l[h + 1 + 64] = pt(x, S, S), l[h + 3 + 64] = l[h + 2 + 64] = l[h + 0 + 96] = l[h + 1 + 96] = l[h + 2 + 96] = l[h + 3 + 96] = S;
    }
    function ws(l, h) {
      var b = l[h - 1 + 0], y = l[h - 1 + 32], x = l[h - 1 + 64], S = l[h - 1 + 96], k = l[h - 1 - 32], P = l[h + 0 - 32], O = l[h + 1 - 32], H = l[h + 2 - 32];
      l[h + 0 + 0] = l[h + 2 + 32] = b + k + 1 >> 1, l[h + 0 + 32] = l[h + 2 + 64] = y + b + 1 >> 1, l[h + 0 + 64] = l[h + 2 + 96] = x + y + 1 >> 1, l[h + 0 + 96] = S + x + 1 >> 1, l[h + 3 + 0] = pt(P, O, H), l[h + 2 + 0] = pt(k, P, O), l[h + 1 + 0] = l[h + 3 + 32] = pt(b, k, P), l[h + 1 + 32] = l[h + 3 + 64] = pt(y, b, k), l[h + 1 + 64] = l[h + 3 + 96] = pt(x, y, b), l[h + 1 + 96] = pt(S, x, y);
    }
    function ua(l, h) {
      var b;
      for (b = 0; 8 > b; ++b) r(l, h + 32 * b, l, h - 32, 8);
    }
    function bl(l, h) {
      var b;
      for (b = 0; 8 > b; ++b) i(l, h, l[h - 1], 8), h += 32;
    }
    function fi(l, h, b) {
      var y;
      for (y = 0; 8 > y; ++y) i(h, b + 32 * y, l, 8);
    }
    function El(l, h) {
      var b, y = 8;
      for (b = 0; 8 > b; ++b) y += l[h + b - 32] + l[h - 1 + 32 * b];
      fi(y >> 4, l, h);
    }
    function xs(l, h) {
      var b, y = 4;
      for (b = 0; 8 > b; ++b) y += l[h + b - 32];
      fi(y >> 3, l, h);
    }
    function Ns(l, h) {
      var b, y = 4;
      for (b = 0; 8 > b; ++b) y += l[h - 1 + 32 * b];
      fi(y >> 3, l, h);
    }
    function Fo(l, h) {
      fi(128, l, h);
    }
    function hi(l, h, b) {
      var y = l[h - b], x = l[h + 0], S = 3 * (x - y) + yl[1020 + l[h - 2 * b] - l[h + b]], k = Wo[112 + (S + 4 >> 3)];
      l[h - b] = ar[255 + y + Wo[112 + (S + 3 >> 3)]], l[h + 0] = ar[255 + x - k];
    }
    function vs(l, h, b, y) {
      var x = l[h + 0], S = l[h + b];
      return wr[255 + l[h - 2 * b] - l[h - b]] > y || wr[255 + S - x] > y;
    }
    function Ha(l, h, b, y) {
      return 4 * wr[255 + l[h - b] - l[h + 0]] + wr[255 + l[h - 2 * b] - l[h + b]] <= y;
    }
    function Ss(l, h, b, y, x) {
      var S = l[h - 3 * b], k = l[h - 2 * b], P = l[h - b], O = l[h + 0], H = l[h + b], ne = l[h + 2 * b], pe = l[h + 3 * b];
      return 4 * wr[255 + P - O] + wr[255 + k - H] > y ? 0 : wr[255 + l[h - 4 * b] - S] <= x && wr[255 + S - k] <= x && wr[255 + k - P] <= x && wr[255 + pe - ne] <= x && wr[255 + ne - H] <= x && wr[255 + H - O] <= x;
    }
    function la(l, h, b, y) {
      var x = 2 * y + 1;
      for (y = 0; 16 > y; ++y) Ha(l, h + y, b, x) && hi(l, h + y, b);
    }
    function Ls(l, h, b, y) {
      var x = 2 * y + 1;
      for (y = 0; 16 > y; ++y) Ha(l, h + y * b, 1, x) && hi(l, h + y * b, 1);
    }
    function Bo(l, h, b, y) {
      var x;
      for (x = 3; 0 < x; --x) la(l, h += 4 * b, b, y);
    }
    function Uo(l, h, b, y) {
      var x;
      for (x = 3; 0 < x; --x) Ls(l, h += 4, b, y);
    }
    function di(l, h, b, y, x, S, k, P) {
      for (S = 2 * S + 1; 0 < x--; ) {
        if (Ss(l, h, b, S, k)) if (vs(l, h, b, P)) hi(l, h, b);
        else {
          var O = l, H = h, ne = b, pe = O[H - 2 * ne], j = O[H - ne], re = O[H + 0], oe = O[H + ne], Te = O[H + 2 * ne], de = 27 * (Ne = yl[1020 + 3 * (re - j) + yl[1020 + pe - oe]]) + 63 >> 7, _e = 18 * Ne + 63 >> 7, Ne = 9 * Ne + 63 >> 7;
          O[H - 3 * ne] = ar[255 + O[H - 3 * ne] + Ne], O[H - 2 * ne] = ar[255 + pe + _e], O[H - ne] = ar[255 + j + de], O[H + 0] = ar[255 + re - de], O[H + ne] = ar[255 + oe - _e], O[H + 2 * ne] = ar[255 + Te - Ne];
        }
        h += y;
      }
    }
    function pi(l, h, b, y, x, S, k, P) {
      for (S = 2 * S + 1; 0 < x--; ) {
        if (Ss(l, h, b, S, k)) if (vs(l, h, b, P)) hi(l, h, b);
        else {
          var O = l, H = h, ne = b, pe = O[H - ne], j = O[H + 0], re = O[H + ne], oe = Wo[112 + (4 + (Te = 3 * (j - pe)) >> 3)], Te = Wo[112 + (Te + 3 >> 3)], de = oe + 1 >> 1;
          O[H - 2 * ne] = ar[255 + O[H - 2 * ne] + de], O[H - ne] = ar[255 + pe + Te], O[H + 0] = ar[255 + j - oe], O[H + ne] = ar[255 + re - de];
        }
        h += y;
      }
    }
    function Ho(l, h, b, y, x, S) {
      di(l, h, b, 1, 16, y, x, S);
    }
    function ca(l, h, b, y, x, S) {
      di(l, h, 1, b, 16, y, x, S);
    }
    function jo(l, h, b, y, x, S) {
      var k;
      for (k = 3; 0 < k; --k) pi(l, h += 4 * b, b, 1, 16, y, x, S);
    }
    function g(l, h, b, y, x, S) {
      var k;
      for (k = 3; 0 < k; --k) pi(l, h += 4, 1, b, 16, y, x, S);
    }
    function w(l, h, b, y, x, S, k, P) {
      di(l, h, x, 1, 8, S, k, P), di(b, y, x, 1, 8, S, k, P);
    }
    function q(l, h, b, y, x, S, k, P) {
      di(l, h, 1, x, 8, S, k, P), di(b, y, 1, x, 8, S, k, P);
    }
    function Q(l, h, b, y, x, S, k, P) {
      pi(l, h + 4 * x, x, 1, 8, S, k, P), pi(b, y + 4 * x, x, 1, 8, S, k, P);
    }
    function ae(l, h, b, y, x, S, k, P) {
      pi(l, h + 4, 1, x, 8, S, k, P), pi(b, y + 4, 1, x, 8, S, k, P);
    }
    function we() {
      this.ba = new vt(), this.ec = [], this.cc = [], this.Mc = [], this.Dc = this.Nc = this.dc = this.fc = 0, this.Oa = new Mt(), this.memory = 0, this.Ib = "OutputFunc", this.Jb = "OutputAlphaFunc", this.Nd = "OutputRowFunc";
    }
    function Se() {
      this.data = [], this.offset = this.kd = this.ha = this.w = 0, this.na = [], this.xa = this.gb = this.Ja = this.Sa = this.P = 0;
    }
    function Ge() {
      this.nc = this.Ea = this.b = this.hc = 0, this.K = [], this.w = 0;
    }
    function Je() {
      this.ua = 0, this.Wa = new gt(), this.vb = new gt(), this.md = this.xc = this.wc = 0, this.vc = [], this.Wb = 0, this.Ya = new J(), this.yc = new $();
    }
    function ft() {
      this.xb = this.a = 0, this.l = new Ma(), this.ca = new vt(), this.V = [], this.Ba = 0, this.Ta = [], this.Ua = 0, this.m = new T(), this.Pb = 0, this.wd = new T(), this.Ma = this.$ = this.C = this.i = this.c = this.xd = 0, this.s = new Je(), this.ab = 0, this.gc = s(4, Ge), this.Oc = 0;
    }
    function Tt() {
      this.Lc = this.Z = this.$a = this.i = this.c = 0, this.l = new Ma(), this.ic = 0, this.ca = [], this.tb = 0, this.qd = null, this.rd = 0;
    }
    function Ot(l, h, b, y, x, S, k) {
      for (l = l == null ? 0 : l[h + 0], h = 0; h < k; ++h) x[S + h] = l + b[y + h] & 255, l = x[S + h];
    }
    function tn(l, h, b, y, x, S, k) {
      var P;
      if (l == null) Ot(null, null, b, y, x, S, k);
      else for (P = 0; P < k; ++P) x[S + P] = l[h + P] + b[y + P] & 255;
    }
    function gn(l, h, b, y, x, S, k) {
      if (l == null) Ot(null, null, b, y, x, S, k);
      else {
        var P, O = l[h + 0], H = O, ne = O;
        for (P = 0; P < k; ++P) H = ne + (O = l[h + P]) - H, ne = b[y + P] + (-256 & H ? 0 > H ? 0 : 255 : H) & 255, H = O, x[S + P] = ne;
      }
    }
    function Gt(l, h, b, y) {
      var x = h.width, S = h.o;
      if (t(l != null && h != null), 0 > b || 0 >= y || b + y > S) return null;
      if (!l.Cc) {
        if (l.ga == null) {
          var k;
          if (l.ga = new Tt(), (k = l.ga == null) || (k = h.width * h.o, t(l.Gb.length == 0), l.Gb = a(k), l.Uc = 0, l.Gb == null ? k = 0 : (l.mb = l.Gb, l.nb = l.Uc, l.rc = null, k = 1), k = !k), !k) {
            k = l.ga;
            var P = l.Fa, O = l.P, H = l.qc, ne = l.mb, pe = l.nb, j = O + 1, re = H - 1, oe = k.l;
            if (t(P != null && ne != null && h != null), Ui[0] = null, Ui[1] = Ot, Ui[2] = tn, Ui[3] = gn, k.ca = ne, k.tb = pe, k.c = h.width, k.i = h.height, t(0 < k.c && 0 < k.i), 1 >= H) h = 0;
            else if (k.$a = 3 & P[O + 0], k.Z = P[O + 0] >> 2 & 3, k.Lc = P[O + 0] >> 4 & 3, O = P[O + 0] >> 6 & 3, 0 > k.$a || 1 < k.$a || 4 <= k.Z || 1 < k.Lc || O) h = 0;
            else if (oe.put = ut, oe.ac = qr, oe.bc = si, oe.ma = k, oe.width = h.width, oe.height = h.height, oe.Da = h.Da, oe.v = h.v, oe.va = h.va, oe.j = h.j, oe.o = h.o, k.$a) e: {
              t(k.$a == 1), h = ia();
              t: for (; ; ) {
                if (h == null) {
                  h = 0;
                  break e;
                }
                if (t(k != null), k.mc = h, h.c = k.c, h.i = k.i, h.l = k.l, h.l.ma = k, h.l.width = k.c, h.l.height = k.i, h.a = 0, Ee(h.m, P, j, re), !Yr(k.c, k.i, 1, h, null) || (h.ab == 1 && h.gc[0].hc == 3 && Lr(h.s) ? (k.ic = 1, P = h.c * h.i, h.Ta = null, h.Ua = 0, h.V = a(P), h.Ba = 0, h.V == null ? (h.a = 1, h = 0) : h = 1) : (k.ic = 0, h = aa(h, k.c)), !h)) break t;
                h = 1;
                break e;
              }
              k.mc = null, h = 0;
            }
            else h = re >= k.c * k.i;
            k = !h;
          }
          if (k) return null;
          l.ga.Lc != 1 ? l.Ga = 0 : y = S - b;
        }
        t(l.ga != null), t(b + y <= S);
        e: {
          if (h = (P = l.ga).c, S = P.l.o, P.$a == 0) {
            if (j = l.rc, re = l.Vc, oe = l.Fa, O = l.P + 1 + b * h, H = l.mb, ne = l.nb + b * h, t(O <= l.P + l.qc), P.Z != 0) for (t(Ui[P.Z] != null), k = 0; k < y; ++k) Ui[P.Z](j, re, oe, O, H, ne, h), j = H, re = ne, ne += h, O += h;
            else for (k = 0; k < y; ++k) r(H, ne, oe, O, h), j = H, re = ne, ne += h, O += h;
            l.rc = j, l.Vc = re;
          } else {
            if (t(P.mc != null), h = b + y, t((k = P.mc) != null), t(h <= k.i), k.C >= h) h = 1;
            else if (P.ic || Pr(), P.ic) {
              P = k.V, j = k.Ba, re = k.c;
              var Te = k.i, de = (oe = 1, O = k.$ / re, H = k.$ % re, ne = k.m, pe = k.s, k.$), _e = re * Te, Ne = re * h, Pe = pe.wc, Le = de < Ne ? Cn(pe, H, O) : null;
              t(de <= _e), t(h <= Te), t(Lr(pe));
              t: for (; ; ) {
                for (; !ne.h && de < Ne; ) {
                  if (H & Pe || (Le = Cn(pe, H, O)), t(Le != null), le(ne), 256 > (Te = nn(Le.G[0], Le.H[0], ne))) P[j + de] = Te, ++de, ++H >= re && (H = 0, ++O <= h && !(O % 16) && kr(k, O));
                  else {
                    if (!(280 > Te)) {
                      oe = 0;
                      break t;
                    }
                    Te = gr(Te - 256, ne);
                    var Ze, We = nn(Le.G[4], Le.H[4], ne);
                    if (le(ne), !(de >= (We = br(re, We = gr(We, ne))) && _e - de >= Te)) {
                      oe = 0;
                      break t;
                    }
                    for (Ze = 0; Ze < Te; ++Ze) P[j + de + Ze] = P[j + de + Ze - We];
                    for (de += Te, H += Te; H >= re; ) H -= re, ++O <= h && !(O % 16) && kr(k, O);
                    de < Ne && H & Pe && (Le = Cn(pe, H, O));
                  }
                  t(ne.h == ee(ne));
                }
                kr(k, O > h ? h : O);
                break t;
              }
              !oe || ne.h && de < _e ? (oe = 0, k.a = ne.h ? 5 : 3) : k.$ = de, h = oe;
            } else h = Cr(k, k.V, k.Ba, k.c, k.i, h, Oa);
            if (!h) {
              y = 0;
              break e;
            }
          }
          b + y >= S && (l.Cc = 1), y = 1;
        }
        if (!y) return null;
        if (l.Cc && ((y = l.ga) != null && (y.mc = null), l.ga = null, 0 < l.Ga)) return alert("todo:WebPDequantizeLevels"), null;
      }
      return l.nb + b * x;
    }
    function Tn(l, h, b, y, x, S) {
      for (; 0 < x--; ) {
        var k, P = l, O = h + (b ? 1 : 0), H = l, ne = h + (b ? 0 : 3);
        for (k = 0; k < y; ++k) {
          var pe = H[ne + 4 * k];
          pe != 255 && (pe *= 32897, P[O + 4 * k + 0] = P[O + 4 * k + 0] * pe >> 23, P[O + 4 * k + 1] = P[O + 4 * k + 1] * pe >> 23, P[O + 4 * k + 2] = P[O + 4 * k + 2] * pe >> 23);
        }
        h += S;
      }
    }
    function bn(l, h, b, y, x) {
      for (; 0 < y--; ) {
        var S;
        for (S = 0; S < b; ++S) {
          var k = l[h + 2 * S + 0], P = 15 & (H = l[h + 2 * S + 1]), O = 4369 * P, H = (240 & H | H >> 4) * O >> 16;
          l[h + 2 * S + 0] = (240 & k | k >> 4) * O >> 16 & 240 | (15 & k | k << 4) * O >> 16 >> 4 & 15, l[h + 2 * S + 1] = 240 & H | P;
        }
        h += x;
      }
    }
    function In(l, h, b, y, x, S, k, P) {
      var O, H, ne = 255;
      for (H = 0; H < x; ++H) {
        for (O = 0; O < y; ++O) {
          var pe = l[h + O];
          S[k + 4 * O] = pe, ne &= pe;
        }
        h += b, k += P;
      }
      return ne != 255;
    }
    function mi(l, h, b, y, x) {
      var S;
      for (S = 0; S < x; ++S) b[y + S] = l[h + S] >> 8;
    }
    function Pr() {
      Hs = Tn, Of = bn, Rf = In, Df = mi;
    }
    function gi(l, h, b) {
      z[l] = function(y, x, S, k, P, O, H, ne, pe, j, re, oe, Te, de, _e, Ne, Pe) {
        var Le, Ze = Pe - 1 >> 1, We = P[O + 0] | H[ne + 0] << 16, _t = pe[j + 0] | re[oe + 0] << 16;
        t(y != null);
        var $e = 3 * We + _t + 131074 >> 2;
        for (h(y[x + 0], 255 & $e, $e >> 16, Te, de), S != null && ($e = 3 * _t + We + 131074 >> 2, h(S[k + 0], 255 & $e, $e >> 16, _e, Ne)), Le = 1; Le <= Ze; ++Le) {
          var Ct = P[O + Le] | H[ne + Le] << 16, An = pe[j + Le] | re[oe + Le] << 16, At = We + Ct + _t + An + 524296, Xe = At + 2 * (Ct + _t) >> 3;
          $e = Xe + We >> 1, We = (At = At + 2 * (We + An) >> 3) + Ct >> 1, h(y[x + 2 * Le - 1], 255 & $e, $e >> 16, Te, de + (2 * Le - 1) * b), h(y[x + 2 * Le - 0], 255 & We, We >> 16, Te, de + (2 * Le - 0) * b), S != null && ($e = At + _t >> 1, We = Xe + An >> 1, h(S[k + 2 * Le - 1], 255 & $e, $e >> 16, _e, Ne + (2 * Le - 1) * b), h(S[k + 2 * Le + 0], 255 & We, We >> 16, _e, Ne + (2 * Le + 0) * b)), We = Ct, _t = An;
        }
        1 & Pe || ($e = 3 * We + _t + 131074 >> 2, h(y[x + Pe - 1], 255 & $e, $e >> 16, Te, de + (Pe - 1) * b), S != null && ($e = 3 * _t + We + 131074 >> 2, h(S[k + Pe - 1], 255 & $e, $e >> 16, _e, Ne + (Pe - 1) * b)));
      };
    }
    function ks() {
      xr[Vo] = Jp, xr[Go] = Vf, xr[jf] = Zp, xr[$o] = Gf, xr[Xo] = $f, xr[Tl] = Xf, xr[qf] = em, xr[_l] = Vf, xr[Al] = Gf, xr[Ko] = $f, xr[wl] = Xf;
    }
    function ja(l) {
      return l & -16384 ? 0 > l ? 0 : 255 : l >> tm;
    }
    function ki(l, h) {
      return ja((19077 * l >> 8) + (26149 * h >> 8) - 14234);
    }
    function fa(l, h, b) {
      return ja((19077 * l >> 8) - (6419 * h >> 8) - (13320 * b >> 8) + 8708);
    }
    function ha(l, h) {
      return ja((19077 * l >> 8) + (33050 * h >> 8) - 17685);
    }
    function Ci(l, h, b, y, x) {
      y[x + 0] = ki(l, b), y[x + 1] = fa(l, h, b), y[x + 2] = ha(l, h);
    }
    function Pn(l, h, b, y, x) {
      y[x + 0] = ha(l, h), y[x + 1] = fa(l, h, b), y[x + 2] = ki(l, b);
    }
    function da(l, h, b, y, x) {
      var S = fa(l, h, b);
      h = S << 3 & 224 | ha(l, h) >> 3, y[x + 0] = 248 & ki(l, b) | S >> 5, y[x + 1] = h;
    }
    function pa(l, h, b, y, x) {
      var S = 240 & ha(l, h) | 15;
      y[x + 0] = 240 & ki(l, b) | fa(l, h, b) >> 4, y[x + 1] = S;
    }
    function Cs(l, h, b, y, x) {
      y[x + 0] = 255, Ci(l, h, b, y, x + 1);
    }
    function Is(l, h, b, y, x) {
      Pn(l, h, b, y, x), y[x + 3] = 255;
    }
    function Wn(l, h, b, y, x) {
      Ci(l, h, b, y, x), y[x + 3] = 255;
    }
    function bi(l, h, b) {
      z[l] = function(y, x, S, k, P, O, H, ne, pe) {
        for (var j = ne + (-2 & pe) * b; ne != j; ) h(y[x + 0], S[k + 0], P[O + 0], H, ne), h(y[x + 1], S[k + 0], P[O + 0], H, ne + b), x += 2, ++k, ++O, ne += 2 * b;
        1 & pe && h(y[x + 0], S[k + 0], P[O + 0], H, ne);
      };
    }
    function qa(l, h, b) {
      return b == 0 ? l == 0 ? h == 0 ? 6 : 5 : h == 0 ? 4 : 0 : b;
    }
    function qo(l, h, b, y, x) {
      switch (l >>> 30) {
        case 3:
          Ea(h, b, y, x, 0);
          break;
        case 2:
          Ar(h, b, y, x);
          break;
        case 1:
          Ft(h, b, y, x);
      }
    }
    function _r(l, h) {
      var b, y, x = h.M, S = h.Nb, k = l.oc, P = l.pc + 40, O = l.oc, H = l.pc + 584, ne = l.oc, pe = l.pc + 600;
      for (b = 0; 16 > b; ++b) k[P + 32 * b - 1] = 129;
      for (b = 0; 8 > b; ++b) O[H + 32 * b - 1] = 129, ne[pe + 32 * b - 1] = 129;
      for (0 < x ? k[P - 1 - 32] = O[H - 1 - 32] = ne[pe - 1 - 32] = 129 : (i(k, P - 32 - 1, 127, 21), i(O, H - 32 - 1, 127, 9), i(ne, pe - 32 - 1, 127, 9)), y = 0; y < l.za; ++y) {
        var j = h.ya[h.aa + y];
        if (0 < y) {
          for (b = -1; 16 > b; ++b) r(k, P + 32 * b - 4, k, P + 32 * b + 12, 4);
          for (b = -1; 8 > b; ++b) r(O, H + 32 * b - 4, O, H + 32 * b + 4, 4), r(ne, pe + 32 * b - 4, ne, pe + 32 * b + 4, 4);
        }
        var re = l.Gd, oe = l.Hd + y, Te = j.ad, de = j.Hc;
        if (0 < x && (r(k, P - 32, re[oe].y, 0, 16), r(O, H - 32, re[oe].f, 0, 8), r(ne, pe - 32, re[oe].ea, 0, 8)), j.Za) {
          var _e = k, Ne = P - 32 + 16;
          for (0 < x && (y >= l.za - 1 ? i(_e, Ne, re[oe].y[15], 4) : r(_e, Ne, re[oe + 1].y, 0, 4)), b = 0; 4 > b; b++) _e[Ne + 128 + b] = _e[Ne + 256 + b] = _e[Ne + 384 + b] = _e[Ne + 0 + b];
          for (b = 0; 16 > b; ++b, de <<= 2) _e = k, Ne = P + Qf[b], Or[j.Ob[b]](_e, Ne), qo(de, Te, 16 * +b, _e, Ne);
        } else if (_e = qa(y, x, j.Ob[0]), Bi[_e](k, P), de != 0) for (b = 0; 16 > b; ++b, de <<= 2) qo(de, Te, 16 * +b, k, P + Qf[b]);
        for (b = j.Gc, _e = qa(y, x, j.Dd), Ti[_e](O, H), Ti[_e](ne, pe), de = Te, _e = O, Ne = H, 255 & (j = 0 | b) && (170 & j ? Kr(de, 256, _e, Ne) : zt(de, 256, _e, Ne)), j = ne, de = pe, 255 & (b >>= 8) && (170 & b ? Kr(Te, 320, j, de) : zt(Te, 320, j, de)), x < l.Ub - 1 && (r(re[oe].y, 0, k, P + 480, 16), r(re[oe].f, 0, O, H + 224, 8), r(re[oe].ea, 0, ne, pe + 224, 8)), b = 8 * S * l.B, re = l.sa, oe = l.ta + 16 * y + 16 * S * l.R, Te = l.qa, j = l.ra + 8 * y + b, de = l.Ha, _e = l.Ia + 8 * y + b, b = 0; 16 > b; ++b) r(re, oe + b * l.R, k, P + 32 * b, 16);
        for (b = 0; 8 > b; ++b) r(Te, j + b * l.B, O, H + 32 * b, 8), r(de, _e + b * l.B, ne, pe + 32 * b, 8);
      }
    }
    function ma(l, h, b, y, x, S, k, P, O) {
      var H = [0], ne = [0], pe = 0, j = O != null ? O.kd : 0, re = O ?? new Se();
      if (l == null || 12 > b) return 7;
      re.data = l, re.w = h, re.ha = b, h = [h], b = [b], re.gb = [re.gb];
      e: {
        var oe = h, Te = b, de = re.gb;
        if (t(l != null), t(Te != null), t(de != null), de[0] = 0, 12 <= Te[0] && !n(l, oe[0], "RIFF")) {
          if (n(l, oe[0] + 8, "WEBP")) {
            de = 3;
            break e;
          }
          var _e = tt(l, oe[0] + 4);
          if (12 > _e || 4294967286 < _e) {
            de = 3;
            break e;
          }
          if (j && _e > Te[0] - 8) {
            de = 7;
            break e;
          }
          de[0] = _e, oe[0] += 12, Te[0] -= 12;
        }
        de = 0;
      }
      if (de != 0) return de;
      for (_e = 0 < re.gb[0], b = b[0]; ; ) {
        e: {
          var Ne = l;
          Te = h, de = b;
          var Pe = H, Le = ne, Ze = oe = [0];
          if (($e = pe = [pe])[0] = 0, 8 > de[0]) de = 7;
          else {
            if (!n(Ne, Te[0], "VP8X")) {
              if (tt(Ne, Te[0] + 4) != 10) {
                de = 3;
                break e;
              }
              if (18 > de[0]) {
                de = 7;
                break e;
              }
              var We = tt(Ne, Te[0] + 8), _t = 1 + He(Ne, Te[0] + 12);
              if (2147483648 <= _t * (Ne = 1 + He(Ne, Te[0] + 15))) {
                de = 3;
                break e;
              }
              Ze != null && (Ze[0] = We), Pe != null && (Pe[0] = _t), Le != null && (Le[0] = Ne), Te[0] += 18, de[0] -= 18, $e[0] = 1;
            }
            de = 0;
          }
        }
        if (pe = pe[0], oe = oe[0], de != 0) return de;
        if (Te = !!(2 & oe), !_e && pe) return 3;
        if (S != null && (S[0] = !!(16 & oe)), k != null && (k[0] = Te), P != null && (P[0] = 0), k = H[0], oe = ne[0], pe && Te && O == null) {
          de = 0;
          break;
        }
        if (4 > b) {
          de = 7;
          break;
        }
        if (_e && pe || !_e && !pe && !n(l, h[0], "ALPH")) {
          b = [b], re.na = [re.na], re.P = [re.P], re.Sa = [re.Sa];
          e: {
            We = l, de = h, _e = b;
            var $e = re.gb;
            Pe = re.na, Le = re.P, Ze = re.Sa, _t = 22, t(We != null), t(_e != null), Ne = de[0];
            var Ct = _e[0];
            for (t(Pe != null), t(Ze != null), Pe[0] = null, Le[0] = null, Ze[0] = 0; ; ) {
              if (de[0] = Ne, _e[0] = Ct, 8 > Ct) {
                de = 7;
                break e;
              }
              var An = tt(We, Ne + 4);
              if (4294967286 < An) {
                de = 3;
                break e;
              }
              var At = 8 + An + 1 & -2;
              if (_t += At, 0 < $e && _t > $e) {
                de = 3;
                break e;
              }
              if (!n(We, Ne, "VP8 ") || !n(We, Ne, "VP8L")) {
                de = 0;
                break e;
              }
              if (Ct[0] < At) {
                de = 7;
                break e;
              }
              n(We, Ne, "ALPH") || (Pe[0] = We, Le[0] = Ne + 8, Ze[0] = An), Ne += At, Ct -= At;
            }
          }
          if (b = b[0], re.na = re.na[0], re.P = re.P[0], re.Sa = re.Sa[0], de != 0) break;
        }
        b = [b], re.Ja = [re.Ja], re.xa = [re.xa];
        e: if ($e = l, de = h, _e = b, Pe = re.gb[0], Le = re.Ja, Ze = re.xa, We = de[0], Ne = !n($e, We, "VP8 "), _t = !n($e, We, "VP8L"), t($e != null), t(_e != null), t(Le != null), t(Ze != null), 8 > _e[0]) de = 7;
        else {
          if (Ne || _t) {
            if ($e = tt($e, We + 4), 12 <= Pe && $e > Pe - 12) {
              de = 3;
              break e;
            }
            if (j && $e > _e[0] - 8) {
              de = 7;
              break e;
            }
            Le[0] = $e, de[0] += 8, _e[0] -= 8, Ze[0] = _t;
          } else Ze[0] = 5 <= _e[0] && $e[We + 0] == 47 && !($e[We + 4] >> 5), Le[0] = _e[0];
          de = 0;
        }
        if (b = b[0], re.Ja = re.Ja[0], re.xa = re.xa[0], h = h[0], de != 0) break;
        if (4294967286 < re.Ja) return 3;
        if (P == null || Te || (P[0] = re.xa ? 2 : 1), k = [k], oe = [oe], re.xa) {
          if (5 > b) {
            de = 7;
            break;
          }
          P = k, j = oe, Te = S, l == null || 5 > b ? l = 0 : 5 <= b && l[h + 0] == 47 && !(l[h + 4] >> 5) ? (_e = [0], $e = [0], Pe = [0], Ee(Le = new T(), l, h, b), oi(Le, _e, $e, Pe) ? (P != null && (P[0] = _e[0]), j != null && (j[0] = $e[0]), Te != null && (Te[0] = Pe[0]), l = 1) : l = 0) : l = 0;
        } else {
          if (10 > b) {
            de = 7;
            break;
          }
          P = oe, l == null || 10 > b || !Io(l, h + 3, b - 3) ? l = 0 : (j = l[h + 0] | l[h + 1] << 8 | l[h + 2] << 16, Te = 16383 & (l[h + 7] << 8 | l[h + 6]), l = 16383 & (l[h + 9] << 8 | l[h + 8]), 1 & j || 3 < (j >> 1 & 7) || !(j >> 4 & 1) || j >> 5 >= re.Ja || !Te || !l ? l = 0 : (k && (k[0] = Te), P && (P[0] = l), l = 1));
        }
        if (!l || (k = k[0], oe = oe[0], pe && (H[0] != k || ne[0] != oe))) return 3;
        O != null && (O[0] = re, O.offset = h - O.w, t(4294967286 > h - O.w), t(O.offset == O.ha - b));
        break;
      }
      return de == 0 || de == 7 && pe && O == null ? (S != null && (S[0] |= re.na != null && 0 < re.na.length), y != null && (y[0] = k), x != null && (x[0] = oe), 0) : de;
    }
    function Ps(l, h, b) {
      var y = h.width, x = h.height, S = 0, k = 0, P = y, O = x;
      if (h.Da = l != null && 0 < l.Da, h.Da && (P = l.cd, O = l.bd, S = l.v, k = l.j, 11 > b || (S &= -2, k &= -2), 0 > S || 0 > k || 0 >= P || 0 >= O || S + P > y || k + O > x)) return 0;
      if (h.v = S, h.j = k, h.va = S + P, h.o = k + O, h.U = P, h.T = O, h.da = l != null && 0 < l.da, h.da) {
        if (!at(P, O, b = [l.ib], S = [l.hb])) return 0;
        h.ib = b[0], h.hb = S[0];
      }
      return h.ob = l != null && l.ob, h.Kb = l == null || !l.Sd, h.da && (h.ob = h.ib < 3 * y / 4 && h.hb < 3 * x / 4, h.Kb = 0), 1;
    }
    function Os(l) {
      if (l == null) return 2;
      if (11 > l.S) {
        var h = l.f.RGBA;
        h.fb += (l.height - 1) * h.A, h.A = -h.A;
      } else h = l.f.kb, l = l.height, h.O += (l - 1) * h.fa, h.fa = -h.fa, h.N += (l - 1 >> 1) * h.Ab, h.Ab = -h.Ab, h.W += (l - 1 >> 1) * h.Db, h.Db = -h.Db, h.F != null && (h.J += (l - 1) * h.lb, h.lb = -h.lb);
      return 0;
    }
    function Ii(l, h, b, y) {
      if (y == null || 0 >= l || 0 >= h) return 2;
      if (b != null) {
        if (b.Da) {
          var x = b.cd, S = b.bd, k = -2 & b.v, P = -2 & b.j;
          if (0 > k || 0 > P || 0 >= x || 0 >= S || k + x > l || P + S > h) return 2;
          l = x, h = S;
        }
        if (b.da) {
          if (!at(l, h, x = [b.ib], S = [b.hb])) return 2;
          l = x[0], h = S[0];
        }
      }
      y.width = l, y.height = h;
      e: {
        var O = y.width, H = y.height;
        if (l = y.S, 0 >= O || 0 >= H || !(l >= Vo && 13 > l)) l = 2;
        else {
          if (0 >= y.Rd && y.sd == null) {
            k = S = x = h = 0;
            var ne = (P = O * Jf[l]) * H;
            if (11 > l || (S = (H + 1) / 2 * (h = (O + 1) / 2), l == 12 && (k = (x = O) * H)), (H = a(ne + 2 * S + k)) == null) {
              l = 1;
              break e;
            }
            y.sd = H, 11 > l ? ((O = y.f.RGBA).eb = H, O.fb = 0, O.A = P, O.size = ne) : ((O = y.f.kb).y = H, O.O = 0, O.fa = P, O.Fd = ne, O.f = H, O.N = 0 + ne, O.Ab = h, O.Cd = S, O.ea = H, O.W = 0 + ne + S, O.Db = h, O.Ed = S, l == 12 && (O.F = H, O.J = 0 + ne + 2 * S), O.Tc = k, O.lb = x);
          }
          if (h = 1, x = y.S, S = y.width, k = y.height, x >= Vo && 13 > x) if (11 > x) l = y.f.RGBA, h &= (P = Math.abs(l.A)) * (k - 1) + S <= l.size, h &= P >= S * Jf[x], h &= l.eb != null;
          else {
            l = y.f.kb, P = (S + 1) / 2, ne = (k + 1) / 2, O = Math.abs(l.fa), H = Math.abs(l.Ab);
            var pe = Math.abs(l.Db), j = Math.abs(l.lb), re = j * (k - 1) + S;
            h &= O * (k - 1) + S <= l.Fd, h &= H * (ne - 1) + P <= l.Cd, h = (h &= pe * (ne - 1) + P <= l.Ed) & O >= S & H >= P & pe >= P, h &= l.y != null, h &= l.f != null, h &= l.ea != null, x == 12 && (h &= j >= S, h &= re <= l.Tc, h &= l.F != null);
          }
          else h = 0;
          l = h ? 0 : 2;
        }
      }
      return l != 0 || b != null && b.fd && (l = Os(y)), l;
    }
    var ga = 64, rr = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215], ir = 24, Pi = 32, Ei = 8, Oi = [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7];
    Ye("Predictor0", "PredictorAdd0"), z.Predictor0 = function() {
      return 4278190080;
    }, z.Predictor1 = function(l) {
      return l;
    }, z.Predictor2 = function(l, h, b) {
      return h[b + 0];
    }, z.Predictor3 = function(l, h, b) {
      return h[b + 1];
    }, z.Predictor4 = function(l, h, b) {
      return h[b - 1];
    }, z.Predictor5 = function(l, h, b) {
      return nt(nt(l, h[b + 1]), h[b + 0]);
    }, z.Predictor6 = function(l, h, b) {
      return nt(l, h[b - 1]);
    }, z.Predictor7 = function(l, h, b) {
      return nt(l, h[b + 0]);
    }, z.Predictor8 = function(l, h, b) {
      return nt(h[b - 1], h[b + 0]);
    }, z.Predictor9 = function(l, h, b) {
      return nt(h[b + 0], h[b + 1]);
    }, z.Predictor10 = function(l, h, b) {
      return nt(nt(l, h[b - 1]), nt(h[b + 0], h[b + 1]));
    }, z.Predictor11 = function(l, h, b) {
      var y = h[b + 0];
      return 0 >= he(y >> 24 & 255, l >> 24 & 255, (h = h[b - 1]) >> 24 & 255) + he(y >> 16 & 255, l >> 16 & 255, h >> 16 & 255) + he(y >> 8 & 255, l >> 8 & 255, h >> 8 & 255) + he(255 & y, 255 & l, 255 & h) ? y : l;
    }, z.Predictor12 = function(l, h, b) {
      var y = h[b + 0];
      return (Dt((l >> 24 & 255) + (y >> 24 & 255) - ((h = h[b - 1]) >> 24 & 255)) << 24 | Dt((l >> 16 & 255) + (y >> 16 & 255) - (h >> 16 & 255)) << 16 | Dt((l >> 8 & 255) + (y >> 8 & 255) - (h >> 8 & 255)) << 8 | Dt((255 & l) + (255 & y) - (255 & h))) >>> 0;
    }, z.Predictor13 = function(l, h, b) {
      var y = h[b - 1];
      return (xt((l = nt(l, h[b + 0])) >> 24 & 255, y >> 24 & 255) << 24 | xt(l >> 16 & 255, y >> 16 & 255) << 16 | xt(l >> 8 & 255, y >> 8 & 255) << 8 | xt(255 & l, 255 & y)) >>> 0;
    };
    var Rs = z.PredictorAdd0;
    z.PredictorAdd1 = ve, Ye("Predictor2", "PredictorAdd2"), Ye("Predictor3", "PredictorAdd3"), Ye("Predictor4", "PredictorAdd4"), Ye("Predictor5", "PredictorAdd5"), Ye("Predictor6", "PredictorAdd6"), Ye("Predictor7", "PredictorAdd7"), Ye("Predictor8", "PredictorAdd8"), Ye("Predictor9", "PredictorAdd9"), Ye("Predictor10", "PredictorAdd10"), Ye("Predictor11", "PredictorAdd11"), Ye("Predictor12", "PredictorAdd12"), Ye("Predictor13", "PredictorAdd13");
    var za = z.PredictorAdd2;
    ze("ColorIndexInverseTransform", "MapARGB", "32b", function(l) {
      return l >> 8 & 255;
    }, function(l) {
      return l;
    }), ze("VP8LColorIndexInverseTransformAlpha", "MapAlpha", "8b", function(l) {
      return l;
    }, function(l) {
      return l >> 8 & 255;
    });
    var on, zo = z.ColorIndexInverseTransform, $r = z.MapARGB, Xr = z.VP8LColorIndexInverseTransformAlpha, Ds = z.MapAlpha, Ms = z.VP8LPredictorsAdd = [];
    Ms.length = 16, (z.VP8LPredictors = []).length = 16, (z.VP8LPredictorsAdd_C = []).length = 16, (z.VP8LPredictors_C = []).length = 16;
    var Fs, Bs, Ri, Di, Mi, ba, Fi, Ea, Ar, Kr, Ft, zt, un, _n, yi, Us, Ya, Yo, Sf, Lf, kf, Cf, If, Pf, Hs, Of, Rf, Df, Mf = a(511), Ff = a(2041), Bf = a(225), Uf = a(767), Hf = 0, yl = Ff, Wo = Bf, ar = Uf, wr = Mf, Vo = 0, Go = 1, jf = 2, $o = 3, Xo = 4, Tl = 5, qf = 6, _l = 7, Al = 8, Ko = 9, wl = 10, Bp = [2, 3, 7], Up = [3, 3, 11], zf = [280, 256, 256, 256, 40], Hp = [0, 1, 1, 1, 0], jp = [17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], qp = [24, 7, 23, 25, 40, 6, 39, 41, 22, 26, 38, 42, 56, 5, 55, 57, 21, 27, 54, 58, 37, 43, 72, 4, 71, 73, 20, 28, 53, 59, 70, 74, 36, 44, 88, 69, 75, 52, 60, 3, 87, 89, 19, 29, 86, 90, 35, 45, 68, 76, 85, 91, 51, 61, 104, 2, 103, 105, 18, 30, 102, 106, 34, 46, 84, 92, 67, 77, 101, 107, 50, 62, 120, 1, 119, 121, 83, 93, 17, 31, 100, 108, 66, 78, 118, 122, 33, 47, 117, 123, 49, 63, 99, 109, 82, 94, 0, 116, 124, 65, 79, 16, 32, 98, 110, 48, 115, 125, 81, 95, 64, 114, 126, 97, 111, 80, 113, 127, 96, 112], zp = [2954, 2956, 2958, 2962, 2970, 2986, 3018, 3082, 3212, 3468, 3980, 5004], Yp = 8, xl = [4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 91, 93, 95, 96, 98, 100, 101, 102, 104, 106, 108, 110, 112, 114, 116, 118, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 143, 145, 148, 151, 154, 157], Nl = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152, 155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284], js = null, Wp = [[173, 148, 140, 0], [176, 155, 140, 135, 0], [180, 157, 141, 134, 130, 0], [254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 0]], Vp = [0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15], Yf = [-0, 1, -1, 2, -2, 3, 4, 6, -3, 5, -4, -5, -6, 7, -7, 8, -8, -9], Gp = [[[[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]], [[253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128], [189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128], [106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128]], [[1, 98, 248, 255, 236, 226, 255, 255, 128, 128, 128], [181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128], [78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128]], [[1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128], [184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128], [77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128]], [[1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128], [170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128], [37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128]], [[1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128], [207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128], [102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128]], [[1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128], [177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128], [80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [246, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[198, 35, 237, 223, 193, 187, 162, 160, 145, 155, 62], [131, 45, 198, 221, 172, 176, 220, 157, 252, 221, 1], [68, 47, 146, 208, 149, 167, 221, 162, 255, 223, 128]], [[1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128], [184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128], [81, 99, 181, 242, 176, 190, 249, 202, 255, 255, 128]], [[1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128], [99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128], [23, 91, 163, 242, 170, 187, 247, 210, 255, 255, 128]], [[1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128], [109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128], [44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128]], [[1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128], [94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128], [22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128]], [[1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128], [124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128], [35, 77, 181, 251, 193, 211, 255, 205, 128, 128, 128]], [[1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128], [121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128], [45, 99, 188, 251, 195, 217, 255, 224, 128, 128, 128]], [[1, 1, 251, 255, 213, 255, 128, 128, 128, 128, 128], [203, 1, 248, 255, 255, 128, 128, 128, 128, 128, 128], [137, 1, 177, 255, 224, 255, 128, 128, 128, 128, 128]]], [[[253, 9, 248, 251, 207, 208, 255, 192, 128, 128, 128], [175, 13, 224, 243, 193, 185, 249, 198, 255, 255, 128], [73, 17, 171, 221, 161, 179, 236, 167, 255, 234, 128]], [[1, 95, 247, 253, 212, 183, 255, 255, 128, 128, 128], [239, 90, 244, 250, 211, 209, 255, 255, 128, 128, 128], [155, 77, 195, 248, 188, 195, 255, 255, 128, 128, 128]], [[1, 24, 239, 251, 218, 219, 255, 205, 128, 128, 128], [201, 51, 219, 255, 196, 186, 128, 128, 128, 128, 128], [69, 46, 190, 239, 201, 218, 255, 228, 128, 128, 128]], [[1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128], [223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128], [141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128]], [[1, 16, 248, 255, 255, 128, 128, 128, 128, 128, 128], [190, 36, 230, 255, 236, 255, 128, 128, 128, 128, 128], [149, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128], [247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128], [240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128], [213, 62, 250, 255, 255, 128, 128, 128, 128, 128, 128], [55, 93, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[202, 24, 213, 235, 186, 191, 220, 160, 240, 175, 255], [126, 38, 182, 232, 169, 184, 228, 174, 255, 187, 128], [61, 46, 138, 219, 151, 178, 240, 170, 255, 216, 128]], [[1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128], [166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128], [39, 77, 162, 232, 172, 180, 245, 178, 255, 255, 128]], [[1, 52, 220, 246, 198, 199, 249, 220, 255, 255, 128], [124, 74, 191, 243, 183, 193, 250, 221, 255, 255, 128], [24, 71, 130, 219, 154, 170, 243, 182, 255, 255, 128]], [[1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128], [149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128], [28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128]], [[1, 81, 230, 252, 204, 203, 255, 192, 128, 128, 128], [123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128], [20, 95, 153, 243, 164, 173, 255, 203, 128, 128, 128]], [[1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128], [168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128], [47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128]], [[1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128], [141, 84, 213, 252, 201, 202, 255, 219, 128, 128, 128], [42, 80, 160, 240, 162, 185, 255, 205, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [244, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [238, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]]]], $p = [[[231, 120, 48, 89, 115, 113, 120, 152, 112], [152, 179, 64, 126, 170, 118, 46, 70, 95], [175, 69, 143, 80, 85, 82, 72, 155, 103], [56, 58, 10, 171, 218, 189, 17, 13, 152], [114, 26, 17, 163, 44, 195, 21, 10, 173], [121, 24, 80, 195, 26, 62, 44, 64, 85], [144, 71, 10, 38, 171, 213, 144, 34, 26], [170, 46, 55, 19, 136, 160, 33, 206, 71], [63, 20, 8, 114, 114, 208, 12, 9, 226], [81, 40, 11, 96, 182, 84, 29, 16, 36]], [[134, 183, 89, 137, 98, 101, 106, 165, 148], [72, 187, 100, 130, 157, 111, 32, 75, 80], [66, 102, 167, 99, 74, 62, 40, 234, 128], [41, 53, 9, 178, 241, 141, 26, 8, 107], [74, 43, 26, 146, 73, 166, 49, 23, 157], [65, 38, 105, 160, 51, 52, 31, 115, 128], [104, 79, 12, 27, 217, 255, 87, 17, 7], [87, 68, 71, 44, 114, 51, 15, 186, 23], [47, 41, 14, 110, 182, 183, 21, 17, 194], [66, 45, 25, 102, 197, 189, 23, 18, 22]], [[88, 88, 147, 150, 42, 46, 45, 196, 205], [43, 97, 183, 117, 85, 38, 35, 179, 61], [39, 53, 200, 87, 26, 21, 43, 232, 171], [56, 34, 51, 104, 114, 102, 29, 93, 77], [39, 28, 85, 171, 58, 165, 90, 98, 64], [34, 22, 116, 206, 23, 34, 43, 166, 73], [107, 54, 32, 26, 51, 1, 81, 43, 31], [68, 25, 106, 22, 64, 171, 36, 225, 114], [34, 19, 21, 102, 132, 188, 16, 76, 124], [62, 18, 78, 95, 85, 57, 50, 48, 51]], [[193, 101, 35, 159, 215, 111, 89, 46, 111], [60, 148, 31, 172, 219, 228, 21, 18, 111], [112, 113, 77, 85, 179, 255, 38, 120, 114], [40, 42, 1, 196, 245, 209, 10, 25, 109], [88, 43, 29, 140, 166, 213, 37, 43, 154], [61, 63, 30, 155, 67, 45, 68, 1, 209], [100, 80, 8, 43, 154, 1, 51, 26, 71], [142, 78, 78, 16, 255, 128, 34, 197, 171], [41, 40, 5, 102, 211, 183, 4, 1, 221], [51, 50, 17, 168, 209, 192, 23, 25, 82]], [[138, 31, 36, 171, 27, 166, 38, 44, 229], [67, 87, 58, 169, 82, 115, 26, 59, 179], [63, 59, 90, 180, 59, 166, 93, 73, 154], [40, 40, 21, 116, 143, 209, 34, 39, 175], [47, 15, 16, 183, 34, 223, 49, 45, 183], [46, 17, 33, 183, 6, 98, 15, 32, 183], [57, 46, 22, 24, 128, 1, 54, 17, 37], [65, 32, 73, 115, 28, 128, 23, 128, 205], [40, 3, 9, 115, 51, 192, 18, 6, 223], [87, 37, 9, 115, 59, 77, 64, 21, 47]], [[104, 55, 44, 218, 9, 54, 53, 130, 226], [64, 90, 70, 205, 40, 41, 23, 26, 57], [54, 57, 112, 184, 5, 41, 38, 166, 213], [30, 34, 26, 133, 152, 116, 10, 32, 134], [39, 19, 53, 221, 26, 114, 32, 73, 255], [31, 9, 65, 234, 2, 15, 1, 118, 73], [75, 32, 12, 51, 192, 255, 160, 43, 51], [88, 31, 35, 67, 102, 85, 55, 186, 85], [56, 21, 23, 111, 59, 205, 45, 37, 192], [55, 38, 70, 124, 73, 102, 1, 34, 98]], [[125, 98, 42, 88, 104, 85, 117, 175, 82], [95, 84, 53, 89, 128, 100, 113, 101, 45], [75, 79, 123, 47, 51, 128, 81, 171, 1], [57, 17, 5, 71, 102, 57, 53, 41, 49], [38, 33, 13, 121, 57, 73, 26, 1, 85], [41, 10, 67, 138, 77, 110, 90, 47, 114], [115, 21, 2, 10, 102, 255, 166, 23, 6], [101, 29, 16, 10, 85, 128, 101, 196, 26], [57, 18, 10, 102, 102, 213, 34, 20, 43], [117, 20, 15, 36, 163, 128, 68, 1, 26]], [[102, 61, 71, 37, 34, 53, 31, 243, 192], [69, 60, 71, 38, 73, 119, 28, 222, 37], [68, 45, 128, 34, 1, 47, 11, 245, 171], [62, 17, 19, 70, 146, 85, 55, 62, 70], [37, 43, 37, 154, 100, 163, 85, 160, 1], [63, 9, 92, 136, 28, 64, 32, 201, 85], [75, 15, 9, 9, 64, 255, 184, 119, 16], [86, 6, 28, 5, 64, 255, 25, 248, 1], [56, 8, 17, 132, 137, 255, 55, 116, 128], [58, 15, 20, 82, 135, 57, 26, 121, 40]], [[164, 50, 31, 137, 154, 133, 25, 35, 218], [51, 103, 44, 131, 131, 123, 31, 6, 158], [86, 40, 64, 135, 148, 224, 45, 183, 128], [22, 26, 17, 131, 240, 154, 14, 1, 209], [45, 16, 21, 91, 64, 222, 7, 1, 197], [56, 21, 39, 155, 60, 138, 23, 102, 213], [83, 12, 13, 54, 192, 255, 68, 47, 28], [85, 26, 85, 85, 128, 128, 32, 146, 171], [18, 11, 7, 63, 144, 171, 4, 4, 246], [35, 27, 10, 146, 174, 171, 12, 26, 128]], [[190, 80, 35, 99, 180, 80, 126, 54, 45], [85, 126, 47, 87, 176, 51, 41, 20, 32], [101, 75, 128, 139, 118, 146, 116, 128, 85], [56, 41, 15, 176, 236, 85, 37, 9, 62], [71, 30, 17, 119, 118, 255, 17, 18, 138], [101, 38, 60, 138, 55, 70, 43, 26, 142], [146, 36, 19, 30, 171, 255, 97, 27, 20], [138, 45, 61, 62, 219, 1, 81, 188, 64], [32, 41, 20, 117, 151, 142, 20, 21, 163], [112, 19, 12, 61, 195, 128, 48, 4, 24]]], Xp = [[[[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255], [249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255], [234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255], [239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255], [250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255], [234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255], [247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255], [234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255], [251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255], [248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255], [248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255], [249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]]], Kp = [0, 1, 2, 3, 6, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 0], Bi = [], Or = [], Ti = [], Qp = 1, Wf = 2, Ui = [], xr = [];
    gi("UpsampleRgbLinePair", Ci, 3), gi("UpsampleBgrLinePair", Pn, 3), gi("UpsampleRgbaLinePair", Wn, 4), gi("UpsampleBgraLinePair", Is, 4), gi("UpsampleArgbLinePair", Cs, 4), gi("UpsampleRgba4444LinePair", pa, 2), gi("UpsampleRgb565LinePair", da, 2);
    var Jp = z.UpsampleRgbLinePair, Zp = z.UpsampleBgrLinePair, Vf = z.UpsampleRgbaLinePair, Gf = z.UpsampleBgraLinePair, $f = z.UpsampleArgbLinePair, Xf = z.UpsampleRgba4444LinePair, em = z.UpsampleRgb565LinePair, Qo = 16, Jo = 1 << Qo - 1, qs = -227, vl = 482, tm = 6, Kf = 0, nm = a(256), rm = a(256), im = a(256), am = a(256), sm = a(vl - qs), om = a(vl - qs);
    bi("YuvToRgbRow", Ci, 3), bi("YuvToBgrRow", Pn, 3), bi("YuvToRgbaRow", Wn, 4), bi("YuvToBgraRow", Is, 4), bi("YuvToArgbRow", Cs, 4), bi("YuvToRgba4444Row", pa, 2), bi("YuvToRgb565Row", da, 2);
    var Qf = [0, 4, 8, 12, 128, 132, 136, 140, 256, 260, 264, 268, 384, 388, 392, 396], Zo = [0, 2, 8], um = [8, 7, 6, 4, 4, 2, 2, 2, 1, 1, 1, 1], lm = 1;
    this.WebPDecodeRGBA = function(l, h, b, y, x) {
      var S = Go, k = new we(), P = new vt();
      k.ba = P, P.S = S, P.width = [P.width], P.height = [P.height];
      var O = P.width, H = P.height, ne = new ot();
      if (ne == null || l == null) var pe = 2;
      else t(ne != null), pe = ma(l, h, b, ne.width, ne.height, ne.Pd, ne.Qd, ne.format, null);
      if (pe != 0 ? O = 0 : (O != null && (O[0] = ne.width[0]), H != null && (H[0] = ne.height[0]), O = 1), O) {
        P.width = P.width[0], P.height = P.height[0], y != null && (y[0] = P.width), x != null && (x[0] = P.height);
        e: {
          if (y = new Ma(), (x = new Se()).data = l, x.w = h, x.ha = b, x.kd = 1, h = [0], t(x != null), ((l = ma(x.data, x.w, x.ha, null, null, null, h, null, x)) == 0 || l == 7) && h[0] && (l = 4), (h = l) == 0) {
            if (t(k != null), y.data = x.data, y.w = x.w + x.offset, y.ha = x.ha - x.offset, y.put = ut, y.ac = qr, y.bc = si, y.ma = k, x.xa) {
              if ((l = ia()) == null) {
                k = 1;
                break e;
              }
              if ((function(j, re) {
                var oe = [0], Te = [0], de = [0];
                t: for (; ; ) {
                  if (j == null) return 0;
                  if (re == null) return j.a = 2, 0;
                  if (j.l = re, j.a = 0, Ee(j.m, re.data, re.w, re.ha), !oi(j.m, oe, Te, de)) {
                    j.a = 3;
                    break t;
                  }
                  if (j.xb = Wf, re.width = oe[0], re.height = Te[0], !Yr(oe[0], Te[0], 1, j, null)) break t;
                  return 1;
                }
                return t(j.a != 0), 0;
              })(l, y)) {
                if (y = (h = Ii(y.width, y.height, k.Oa, k.ba)) == 0) {
                  t: {
                    y = l;
                    n: for (; ; ) {
                      if (y == null) {
                        y = 0;
                        break t;
                      }
                      if (t(y.s.yc != null), t(y.s.Ya != null), t(0 < y.s.Wb), t((b = y.l) != null), t((x = b.ma) != null), y.xb != 0) {
                        if (y.ca = x.ba, y.tb = x.tb, t(y.ca != null), !Ps(x.Oa, b, $o)) {
                          y.a = 2;
                          break n;
                        }
                        if (!aa(y, b.width) || b.da) break n;
                        if ((b.da || lt(y.ca.S)) && Pr(), 11 > y.ca.S || (alert("todo:WebPInitConvertARGBToYUV"), y.ca.f.kb.F != null && Pr()), y.Pb && 0 < y.s.ua && y.s.vb.X == null && !F(y.s.vb, y.s.Wa.Xa)) {
                          y.a = 1;
                          break n;
                        }
                        y.xb = 0;
                      }
                      if (!Cr(y, y.V, y.Ba, y.c, y.i, b.o, Li)) break n;
                      x.Dc = y.Ma, y = 1;
                      break t;
                    }
                    t(y.a != 0), y = 0;
                  }
                  y = !y;
                }
                y && (h = l.a);
              } else h = l.a;
            } else {
              if ((l = new il()) == null) {
                k = 1;
                break e;
              }
              if (l.Fa = x.na, l.P = x.P, l.qc = x.Sa, Vr(l, y)) {
                if ((h = Ii(y.width, y.height, k.Oa, k.ba)) == 0) {
                  if (l.Aa = 0, b = k.Oa, t((x = l) != null), b != null) {
                    if (0 < (O = 0 > (O = b.Md) ? 0 : 100 < O ? 255 : 255 * O / 100)) {
                      for (H = ne = 0; 4 > H; ++H) 12 > (pe = x.pb[H]).lc && (pe.ia = O * um[0 > pe.lc ? 0 : pe.lc] >> 3), ne |= pe.ia;
                      ne && (alert("todo:VP8InitRandom"), x.ia = 1);
                    }
                    x.Ga = b.Id, 100 < x.Ga ? x.Ga = 100 : 0 > x.Ga && (x.Ga = 0);
                  }
                  (function(j, re) {
                    if (j == null) return 0;
                    if (re == null) return mn(j, 2, "NULL VP8Io parameter in VP8Decode().");
                    if (!j.cb && !Vr(j, re)) return 0;
                    if (t(j.cb), re.ac == null || re.ac(re)) {
                      re.ob && (j.L = 0);
                      var oe = Zo[j.L];
                      if (j.L == 2 ? (j.yb = 0, j.zb = 0) : (j.yb = re.v - oe >> 4, j.zb = re.j - oe >> 4, 0 > j.yb && (j.yb = 0), 0 > j.zb && (j.zb = 0)), j.Va = re.o + 15 + oe >> 4, j.Hb = re.va + 15 + oe >> 4, j.Hb > j.za && (j.Hb = j.za), j.Va > j.Ub && (j.Va = j.Ub), 0 < j.L) {
                        var Te = j.ed;
                        for (oe = 0; 4 > oe; ++oe) {
                          var de;
                          if (j.Qa.Cb) {
                            var _e = j.Qa.Lb[oe];
                            j.Qa.Fb || (_e += Te.Tb);
                          } else _e = Te.Tb;
                          for (de = 0; 1 >= de; ++de) {
                            var Ne = j.gd[oe][de], Pe = _e;
                            if (Te.Pc && (Pe += Te.vd[0], de && (Pe += Te.od[0])), 0 < (Pe = 0 > Pe ? 0 : 63 < Pe ? 63 : Pe)) {
                              var Le = Pe;
                              0 < Te.wb && (Le = 4 < Te.wb ? Le >> 2 : Le >> 1) > 9 - Te.wb && (Le = 9 - Te.wb), 1 > Le && (Le = 1), Ne.dd = Le, Ne.tc = 2 * Pe + Le, Ne.ld = 40 <= Pe ? 2 : 15 <= Pe ? 1 : 0;
                            } else Ne.tc = 0;
                            Ne.La = de;
                          }
                        }
                      }
                      oe = 0;
                    } else mn(j, 6, "Frame setup failed"), oe = j.a;
                    if (oe = oe == 0) {
                      if (oe) {
                        j.$c = 0, 0 < j.Aa || (j.Ic = lm);
                        t: {
                          oe = j.Ic, Te = 4 * (Le = j.za);
                          var Ze = 32 * Le, We = Le + 1, _t = 0 < j.L ? Le * (0 < j.Aa ? 2 : 1) : 0, $e = (j.Aa == 2 ? 2 : 1) * Le;
                          if ((Ne = Te + 832 + (de = 3 * (16 * oe + Zo[j.L]) / 2 * Ze) + (_e = j.Fa != null && 0 < j.Fa.length ? j.Kc.c * j.Kc.i : 0)) != Ne) oe = 0;
                          else {
                            if (Ne > j.Vb) {
                              if (j.Vb = 0, j.Ec = a(Ne), j.Fc = 0, j.Ec == null) {
                                oe = mn(j, 1, "no memory during frame initialization.");
                                break t;
                              }
                              j.Vb = Ne;
                            }
                            Ne = j.Ec, Pe = j.Fc, j.Ac = Ne, j.Bc = Pe, Pe += Te, j.Gd = s(Ze, ko), j.Hd = 0, j.rb = s(We + 1, ys), j.sb = 1, j.wa = _t ? s(_t, yr) : null, j.Y = 0, j.D.Nb = 0, j.D.wa = j.wa, j.D.Y = j.Y, 0 < j.Aa && (j.D.Y += Le), t(!0), j.oc = Ne, j.pc = Pe, Pe += 832, j.ya = s($e, Ts), j.aa = 0, j.D.ya = j.ya, j.D.aa = j.aa, j.Aa == 2 && (j.D.aa += Le), j.R = 16 * Le, j.B = 8 * Le, Le = (Ze = Zo[j.L]) * j.R, Ze = Ze / 2 * j.B, j.sa = Ne, j.ta = Pe + Le, j.qa = j.sa, j.ra = j.ta + 16 * oe * j.R + Ze, j.Ha = j.qa, j.Ia = j.ra + 8 * oe * j.B + Ze, j.$c = 0, Pe += de, j.mb = _e ? Ne : null, j.nb = _e ? Pe : null, t(Pe + _e <= j.Fc + j.Vb), Po(j), i(j.Ac, j.Bc, 0, Te), oe = 1;
                          }
                        }
                        if (oe) {
                          if (re.ka = 0, re.y = j.sa, re.O = j.ta, re.f = j.qa, re.N = j.ra, re.ea = j.Ha, re.Vd = j.Ia, re.fa = j.R, re.Rc = j.B, re.F = null, re.J = 0, !Hf) {
                            for (oe = -255; 255 >= oe; ++oe) Mf[255 + oe] = 0 > oe ? -oe : oe;
                            for (oe = -1020; 1020 >= oe; ++oe) Ff[1020 + oe] = -128 > oe ? -128 : 127 < oe ? 127 : oe;
                            for (oe = -112; 112 >= oe; ++oe) Bf[112 + oe] = -16 > oe ? -16 : 15 < oe ? 15 : oe;
                            for (oe = -255; 510 >= oe; ++oe) Uf[255 + oe] = 0 > oe ? 0 : 255 < oe ? 255 : oe;
                            Hf = 1;
                          }
                          Fi = Ba, Ea = sl, Kr = Gr, Ft = Ro, zt = Do, Ar = al, un = Ho, _n = ca, yi = w, Us = q, Ya = jo, Yo = g, Sf = Q, Lf = ae, kf = la, Cf = Ls, If = Bo, Pf = Uo, Or[0] = pl, Or[1] = ol, Or[2] = hl, Or[3] = dl, Or[4] = li, Or[5] = ml, Or[6] = ci, Or[7] = gl, Or[8] = ws, Or[9] = Ua, Bi[0] = cl, Bi[1] = ll, Bi[2] = _s, Bi[3] = Mo, Bi[4] = oa, Bi[5] = As, Bi[6] = fl, Ti[0] = El, Ti[1] = ul, Ti[2] = ua, Ti[3] = bl, Ti[4] = Ns, Ti[5] = xs, Ti[6] = Fo, oe = 1;
                        } else oe = 0;
                      }
                      oe && (oe = (function(Ct, An) {
                        for (Ct.M = 0; Ct.M < Ct.Va; ++Ct.M) {
                          var At, Xe = Ct.Jc[Ct.M & Ct.Xb], Be = Ct.m, ln = Ct;
                          for (At = 0; At < ln.za; ++At) {
                            var yt = Be, It = ln, Kt = It.Ac, On = It.Bc + 4 * At, Vn = It.zc, rn = It.ya[It.aa + At];
                            if (It.Qa.Bb ? rn.$b = Ae(yt, It.Pa.jb[0]) ? 2 + Ae(yt, It.Pa.jb[2]) : Ae(yt, It.Pa.jb[1]) : rn.$b = 0, It.kc && (rn.Ad = Ae(yt, It.Bd)), rn.Za = !Ae(yt, 145) + 0, rn.Za) {
                              var Fn = rn.Ob, Gn = 0;
                              for (It = 0; 4 > It; ++It) {
                                var wn, Rt = Vn[0 + It];
                                for (wn = 0; 4 > wn; ++wn) {
                                  Rt = $p[Kt[On + wn]][Rt];
                                  for (var Ut = Yf[Ae(yt, Rt[0])]; 0 < Ut; ) Ut = Yf[2 * Ut + Ae(yt, Rt[Ut])];
                                  Rt = -Ut, Kt[On + wn] = Rt;
                                }
                                r(Fn, Gn, Kt, On, 4), Gn += 4, Vn[0 + It] = Rt;
                              }
                            } else Rt = Ae(yt, 156) ? Ae(yt, 128) ? 1 : 3 : Ae(yt, 163) ? 2 : 0, rn.Ob[0] = Rt, i(Kt, On, Rt, 4), i(Vn, 0, Rt, 4);
                            rn.Dd = Ae(yt, 142) ? Ae(yt, 114) ? Ae(yt, 183) ? 1 : 3 : 2 : 0;
                          }
                          if (ln.m.Ka) return mn(Ct, 7, "Premature end-of-partition0 encountered.");
                          for (; Ct.ja < Ct.za; ++Ct.ja) {
                            if (ln = Xe, yt = (Be = Ct).rb[Be.sb - 1], Kt = Be.rb[Be.sb + Be.ja], At = Be.ya[Be.aa + Be.ja], On = Be.kc ? At.Ad : 0) yt.la = Kt.la = 0, At.Za || (yt.Na = Kt.Na = 0), At.Hc = 0, At.Gc = 0, At.ia = 0;
                            else {
                              var an, Ht;
                              if (yt = Kt, Kt = ln, On = Be.Pa.Xc, Vn = Be.ya[Be.aa + Be.ja], rn = Be.pb[Vn.$b], It = Vn.ad, Fn = 0, Gn = Be.rb[Be.sb - 1], Rt = wn = 0, i(It, Fn, 0, 384), Vn.Za) var Rn = 0, Rr = On[3];
                              else {
                                Ut = a(16);
                                var cn = yt.Na + Gn.Na;
                                if (cn = js(Kt, On[1], cn, rn.Eb, 0, Ut, 0), yt.Na = Gn.Na = (0 < cn) + 0, 1 < cn) Fi(Ut, 0, It, Fn);
                                else {
                                  var Kn = Ut[0] + 3 >> 3;
                                  for (Ut = 0; 256 > Ut; Ut += 16) It[Fn + Ut] = Kn;
                                }
                                Rn = 1, Rr = On[0];
                              }
                              var Yt = 15 & yt.la, xn = 15 & Gn.la;
                              for (Ut = 0; 4 > Ut; ++Ut) {
                                var sr = 1 & xn;
                                for (Kn = Ht = 0; 4 > Kn; ++Kn) Yt = Yt >> 1 | (sr = (cn = js(Kt, Rr, cn = sr + (1 & Yt), rn.Sc, Rn, It, Fn)) > Rn) << 7, Ht = Ht << 2 | (3 < cn ? 3 : 1 < cn ? 2 : It[Fn + 0] != 0), Fn += 16;
                                Yt >>= 4, xn = xn >> 1 | sr << 7, wn = (wn << 8 | Ht) >>> 0;
                              }
                              for (Rr = Yt, Rn = xn >> 4, an = 0; 4 > an; an += 2) {
                                for (Ht = 0, Yt = yt.la >> 4 + an, xn = Gn.la >> 4 + an, Ut = 0; 2 > Ut; ++Ut) {
                                  for (sr = 1 & xn, Kn = 0; 2 > Kn; ++Kn) cn = sr + (1 & Yt), Yt = Yt >> 1 | (sr = 0 < (cn = js(Kt, On[2], cn, rn.Qc, 0, It, Fn))) << 3, Ht = Ht << 2 | (3 < cn ? 3 : 1 < cn ? 2 : It[Fn + 0] != 0), Fn += 16;
                                  Yt >>= 2, xn = xn >> 1 | sr << 5;
                                }
                                Rt |= Ht << 4 * an, Rr |= Yt << 4 << an, Rn |= (240 & xn) << an;
                              }
                              yt.la = Rr, Gn.la = Rn, Vn.Hc = wn, Vn.Gc = Rt, Vn.ia = 43690 & Rt ? 0 : rn.ia, On = !(wn | Rt);
                            }
                            if (0 < Be.L && (Be.wa[Be.Y + Be.ja] = Be.gd[At.$b][At.Za], Be.wa[Be.Y + Be.ja].La |= !On), ln.Ka) return mn(Ct, 7, "Premature end-of-file encountered.");
                          }
                          if (Po(Ct), Be = An, ln = 1, At = (Xe = Ct).D, yt = 0 < Xe.L && Xe.M >= Xe.zb && Xe.M <= Xe.Va, Xe.Aa == 0) t: {
                            if (At.M = Xe.M, At.uc = yt, _r(Xe, At), ln = 1, At = (Ht = Xe.D).Nb, yt = (Rt = Zo[Xe.L]) * Xe.R, Kt = Rt / 2 * Xe.B, Ut = 16 * At * Xe.R, Kn = 8 * At * Xe.B, On = Xe.sa, Vn = Xe.ta - yt + Ut, rn = Xe.qa, It = Xe.ra - Kt + Kn, Fn = Xe.Ha, Gn = Xe.Ia - Kt + Kn, xn = (Yt = Ht.M) == 0, wn = Yt >= Xe.Va - 1, Xe.Aa == 2 && _r(Xe, Ht), Ht.uc) for (sr = (cn = Xe).D.M, t(cn.D.uc), Ht = cn.yb; Ht < cn.Hb; ++Ht) {
                              Rn = Ht, Rr = sr;
                              var $n = (or = (Dn = cn).D).Nb;
                              an = Dn.R;
                              var or = or.wa[or.Y + Rn], ur = Dn.sa, Qn = Dn.ta + 16 * $n * an + 16 * Rn, lr = or.dd, $t = or.tc;
                              if ($t != 0) if (t(3 <= $t), Dn.L == 1) 0 < Rn && Cf(ur, Qn, an, $t + 4), or.La && Pf(ur, Qn, an, $t), 0 < Rr && kf(ur, Qn, an, $t + 4), or.La && If(ur, Qn, an, $t);
                              else {
                                var cr = Dn.B, Dr = Dn.qa, ya = Dn.ra + 8 * $n * cr + 8 * Rn, _i = Dn.Ha, Dn = Dn.Ia + 8 * $n * cr + 8 * Rn;
                                $n = or.ld, 0 < Rn && (_n(ur, Qn, an, $t + 4, lr, $n), Us(Dr, ya, _i, Dn, cr, $t + 4, lr, $n)), or.La && (Yo(ur, Qn, an, $t, lr, $n), Lf(Dr, ya, _i, Dn, cr, $t, lr, $n)), 0 < Rr && (un(ur, Qn, an, $t + 4, lr, $n), yi(Dr, ya, _i, Dn, cr, $t + 4, lr, $n)), or.La && (Ya(ur, Qn, an, $t, lr, $n), Sf(Dr, ya, _i, Dn, cr, $t, lr, $n));
                              }
                            }
                            if (Xe.ia && alert("todo:DitherRow"), Be.put != null) {
                              if (Ht = 16 * Yt, Yt = 16 * (Yt + 1), xn ? (Be.y = Xe.sa, Be.O = Xe.ta + Ut, Be.f = Xe.qa, Be.N = Xe.ra + Kn, Be.ea = Xe.Ha, Be.W = Xe.Ia + Kn) : (Ht -= Rt, Be.y = On, Be.O = Vn, Be.f = rn, Be.N = It, Be.ea = Fn, Be.W = Gn), wn || (Yt -= Rt), Yt > Be.o && (Yt = Be.o), Be.F = null, Be.J = null, Xe.Fa != null && 0 < Xe.Fa.length && Ht < Yt && (Be.J = Gt(Xe, Be, Ht, Yt - Ht), Be.F = Xe.mb, Be.F == null && Be.F.length == 0)) {
                                ln = mn(Xe, 3, "Could not decode alpha data.");
                                break t;
                              }
                              Ht < Be.j && (Rt = Be.j - Ht, Ht = Be.j, t(!(1 & Rt)), Be.O += Xe.R * Rt, Be.N += Xe.B * (Rt >> 1), Be.W += Xe.B * (Rt >> 1), Be.F != null && (Be.J += Be.width * Rt)), Ht < Yt && (Be.O += Be.v, Be.N += Be.v >> 1, Be.W += Be.v >> 1, Be.F != null && (Be.J += Be.v), Be.ka = Ht - Be.j, Be.U = Be.va - Be.v, Be.T = Yt - Ht, ln = Be.put(Be));
                            }
                            At + 1 != Xe.Ic || wn || (r(Xe.sa, Xe.ta - yt, On, Vn + 16 * Xe.R, yt), r(Xe.qa, Xe.ra - Kt, rn, It + 8 * Xe.B, Kt), r(Xe.Ha, Xe.Ia - Kt, Fn, Gn + 8 * Xe.B, Kt));
                          }
                          if (!ln) return mn(Ct, 6, "Output aborted.");
                        }
                        return 1;
                      })(j, re)), re.bc != null && re.bc(re), oe &= 1;
                    }
                    return oe ? (j.cb = 0, oe) : 0;
                  })(l, y) || (h = l.a);
                }
              } else h = l.a;
            }
            h == 0 && k.Oa != null && k.Oa.fd && (h = Os(k.ba));
          }
          k = h;
        }
        S = k != 0 ? null : 11 > S ? P.f.RGBA.eb : P.f.kb.y;
      } else S = null;
      return S;
    };
    var Jf = [3, 4, 3, 4, 4, 2, 2, 4, 4, 4, 2, 1, 1];
  };
  function c(z, D) {
    for (var N = "", I = 0; I < 4; I++) N += String.fromCharCode(z[D++]);
    return N;
  }
  function f(z, D) {
    return z[D + 0] | z[D + 1] << 8;
  }
  function p(z, D) {
    return (z[D + 0] | z[D + 1] << 8 | z[D + 2] << 16) >>> 0;
  }
  function E(z, D) {
    return (z[D + 0] | z[D + 1] << 8 | z[D + 2] << 16 | z[D + 3] << 24) >>> 0;
  }
  new u();
  var d = [0], A = [0], v = [], C = new u(), _ = e, U = (function(z, D) {
    var N = {}, I = 0, $ = !1, Y = 0, J = 0;
    if (N.frames = [], !/** @license
       * Copyright (c) 2017 Dominik Homberger
      Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
      The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
      https://webpjs.appspot.com
      WebPRiffParser dominikhlbg@gmail.com
      */
    (function(L, T) {
      for (var G = 0; G < 4; G++) if (L[T + G] != "RIFF".charCodeAt(G)) return !0;
      return !1;
    })(z, D)) {
      for (E(z, D += 4), D += 8; D < z.length; ) {
        var ue = c(z, D), me = E(z, D += 4);
        D += 4;
        var se = me + (1 & me);
        switch (ue) {
          case "VP8 ":
          case "VP8L":
            N.frames[I] === void 0 && (N.frames[I] = {}), (xe = N.frames[I]).src_off = $ ? J : D - 8, xe.src_size = Y + me + 8, I++, $ && ($ = !1, Y = 0, J = 0);
            break;
          case "VP8X":
            (xe = N.header = {}).feature_flags = z[D];
            var Ee = D + 4;
            xe.canvas_width = 1 + p(z, Ee), Ee += 3, xe.canvas_height = 1 + p(z, Ee), Ee += 3;
            break;
          case "ALPH":
            $ = !0, Y = se + 8, J = D - 8;
            break;
          case "ANIM":
            (xe = N.header).bgcolor = E(z, D), Ee = D + 4, xe.loop_count = f(z, Ee), Ee += 2;
            break;
          case "ANMF":
            var M, xe;
            (xe = N.frames[I] = {}).offset_x = 2 * p(z, D), D += 3, xe.offset_y = 2 * p(z, D), D += 3, xe.width = 1 + p(z, D), D += 3, xe.height = 1 + p(z, D), D += 3, xe.duration = p(z, D), D += 3, M = z[D++], xe.dispose = 1 & M, xe.blend = M >> 1 & 1;
        }
        ue != "ANMF" && (D += se);
      }
      return N;
    }
  })(_, 0);
  U.response = _, U.rgbaoutput = !0, U.dataurl = !1;
  var B = U.header ? U.header : null, V = U.frames ? U.frames : null;
  if (B) {
    B.loop_counter = B.loop_count, d = [B.canvas_height], A = [B.canvas_width];
    for (var ie = 0; ie < V.length && V[ie].blend != 0; ie++) ;
  }
  var K = V[0], fe = C.WebPDecodeRGBA(_, K.src_off, K.src_size, A, d);
  K.rgba = fe, K.imgwidth = A[0], K.imgheight = d[0];
  for (var Z = 0; Z < A[0] * d[0] * 4; Z++) v[Z] = fe[Z];
  return this.width = A, this.height = d, this.data = v, this;
}
(function(e) {
  var t, n, r, i, a, s, o, u, c, f = function(L) {
    return L = L || {}, this.isStrokeTransparent = L.isStrokeTransparent || !1, this.strokeOpacity = L.strokeOpacity || 1, this.strokeStyle = L.strokeStyle || "#000000", this.fillStyle = L.fillStyle || "#000000", this.isFillTransparent = L.isFillTransparent || !1, this.fillOpacity = L.fillOpacity || 1, this.font = L.font || "10px sans-serif", this.textBaseline = L.textBaseline || "alphabetic", this.textAlign = L.textAlign || "left", this.lineWidth = L.lineWidth || 1, this.lineJoin = L.lineJoin || "miter", this.lineCap = L.lineCap || "butt", this.path = L.path || [], this.transform = L.transform !== void 0 ? L.transform.clone() : new u(), this.globalCompositeOperation = L.globalCompositeOperation || "normal", this.globalAlpha = L.globalAlpha || 1, this.clip_path = L.clip_path || [], this.currentPoint = L.currentPoint || new s(), this.miterLimit = L.miterLimit || 10, this.lastPoint = L.lastPoint || new s(), this.lineDashOffset = L.lineDashOffset || 0, this.lineDash = L.lineDash || [], this.margin = L.margin || [0, 0, 0, 0], this.prevPageLastElemOffset = L.prevPageLastElemOffset || 0, this.ignoreClearRect = typeof L.ignoreClearRect != "boolean" || L.ignoreClearRect, this;
  };
  e.events.push(["initialized", function() {
    this.context2d = new p(this), t = this.internal.f2, n = this.internal.getCoordinateString, r = this.internal.getVerticalCoordinateString, i = this.internal.getHorizontalCoordinate, a = this.internal.getVerticalCoordinate, s = this.internal.Point, o = this.internal.Rectangle, u = this.internal.Matrix, c = new f();
  }]);
  var p = function(L) {
    Object.defineProperty(this, "canvas", { get: function() {
      return { parentNode: !1, style: !1 };
    } });
    var T = L;
    Object.defineProperty(this, "pdf", { get: function() {
      return T;
    } });
    var G = !1;
    Object.defineProperty(this, "pageWrapXEnabled", { get: function() {
      return G;
    }, set: function(F) {
      G = !!F;
    } });
    var ee = !1;
    Object.defineProperty(this, "pageWrapYEnabled", { get: function() {
      return ee;
    }, set: function(F) {
      ee = !!F;
    } });
    var te = 0;
    Object.defineProperty(this, "posX", { get: function() {
      return te;
    }, set: function(F) {
      isNaN(F) || (te = F);
    } });
    var le = 0;
    Object.defineProperty(this, "posY", { get: function() {
      return le;
    }, set: function(F) {
      isNaN(F) || (le = F);
    } }), Object.defineProperty(this, "margin", { get: function() {
      return c.margin;
    }, set: function(F) {
      var Ue;
      typeof F == "number" ? Ue = [F, F, F, F] : ((Ue = new Array(4))[0] = F[0], Ue[1] = F.length >= 2 ? F[1] : Ue[0], Ue[2] = F.length >= 3 ? F[2] : Ue[0], Ue[3] = F.length >= 4 ? F[3] : Ue[1]), c.margin = Ue;
    } });
    var ge = !1;
    Object.defineProperty(this, "autoPaging", { get: function() {
      return ge;
    }, set: function(F) {
      ge = F;
    } });
    var be = 0;
    Object.defineProperty(this, "lastBreak", { get: function() {
      return be;
    }, set: function(F) {
      be = F;
    } });
    var Ae = [];
    Object.defineProperty(this, "pageBreaks", { get: function() {
      return Ae;
    }, set: function(F) {
      Ae = F;
    } }), Object.defineProperty(this, "ctx", { get: function() {
      return c;
    }, set: function(F) {
      F instanceof f && (c = F);
    } }), Object.defineProperty(this, "path", { get: function() {
      return c.path;
    }, set: function(F) {
      c.path = F;
    } });
    var Ie = [];
    Object.defineProperty(this, "ctxStack", { get: function() {
      return Ie;
    }, set: function(F) {
      Ie = F;
    } }), Object.defineProperty(this, "fillStyle", { get: function() {
      return this.ctx.fillStyle;
    }, set: function(F) {
      var Ue;
      Ue = E(F), this.ctx.fillStyle = Ue.style, this.ctx.isFillTransparent = Ue.a === 0, this.ctx.fillOpacity = Ue.a, this.pdf.setFillColor(Ue.r, Ue.g, Ue.b, { a: Ue.a }), this.pdf.setTextColor(Ue.r, Ue.g, Ue.b, { a: Ue.a });
    } }), Object.defineProperty(this, "strokeStyle", { get: function() {
      return this.ctx.strokeStyle;
    }, set: function(F) {
      var Ue = E(F);
      this.ctx.strokeStyle = Ue.style, this.ctx.isStrokeTransparent = Ue.a === 0, this.ctx.strokeOpacity = Ue.a, Ue.a === 0 ? this.pdf.setDrawColor(255, 255, 255) : (Ue.a, this.pdf.setDrawColor(Ue.r, Ue.g, Ue.b));
    } }), Object.defineProperty(this, "lineCap", { get: function() {
      return this.ctx.lineCap;
    }, set: function(F) {
      ["butt", "round", "square"].indexOf(F) !== -1 && (this.ctx.lineCap = F, this.pdf.setLineCap(F));
    } }), Object.defineProperty(this, "lineWidth", { get: function() {
      return this.ctx.lineWidth;
    }, set: function(F) {
      isNaN(F) || (this.ctx.lineWidth = F, this.pdf.setLineWidth(F));
    } }), Object.defineProperty(this, "lineJoin", { get: function() {
      return this.ctx.lineJoin;
    }, set: function(F) {
      ["bevel", "round", "miter"].indexOf(F) !== -1 && (this.ctx.lineJoin = F, this.pdf.setLineJoin(F));
    } }), Object.defineProperty(this, "miterLimit", { get: function() {
      return this.ctx.miterLimit;
    }, set: function(F) {
      isNaN(F) || (this.ctx.miterLimit = F, this.pdf.setMiterLimit(F));
    } }), Object.defineProperty(this, "textBaseline", { get: function() {
      return this.ctx.textBaseline;
    }, set: function(F) {
      this.ctx.textBaseline = F;
    } }), Object.defineProperty(this, "textAlign", { get: function() {
      return this.ctx.textAlign;
    }, set: function(F) {
      ["right", "end", "center", "left", "start"].indexOf(F) !== -1 && (this.ctx.textAlign = F);
    } });
    var je = null, He = null, tt = null;
    Object.defineProperty(this, "fontFaces", { get: function() {
      return tt;
    }, set: function(F) {
      je = null, He = null, tt = F;
    } }), Object.defineProperty(this, "font", { get: function() {
      return this.ctx.font;
    }, set: function(F) {
      var Ue;
      if (this.ctx.font = F, (Ue = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-_,\"\'\sa-z0-9]+?)\s*$/i.exec(F)) !== null) {
        var gt = Ue[1];
        Ue[2];
        var at = Ue[3], ke = Ue[4];
        Ue[5];
        var rt = Ue[6], Ye = /^([.\d]+)((?:%|in|[cem]m|ex|p[ctx]))$/i.exec(ke)[2];
        ke = Math.floor(Ye === "px" ? parseFloat(ke) * this.pdf.internal.scaleFactor : Ye === "em" ? parseFloat(ke) * this.pdf.getFontSize() : parseFloat(ke) * this.pdf.internal.scaleFactor), this.pdf.setFontSize(ke);
        var it = (function(ze) {
          var Bt, bt, ht = [], dt = ze.trim();
          if (dt === "") return yc;
          if (dt in Ld) return [Ld[dt]];
          for (; dt !== ""; ) {
            switch (bt = null, Bt = (dt = Cd(dt)).charAt(0)) {
              case '"':
              case "'":
                bt = a8(dt.substring(1), Bt);
                break;
              default:
                bt = s8(dt);
            }
            if (bt === null || (ht.push(bt[0]), (dt = Cd(bt[1])) !== "" && dt.charAt(0) !== ",")) return yc;
            dt = dt.replace(/^,/, "");
          }
          return ht;
        })(rt);
        if (this.fontFaces) {
          var nt = (function(ze, Bt) {
            var bt = ze.getFontList(), ht = JSON.stringify(bt);
            if (je === null || He !== ht) {
              var dt = (function(Nt) {
                var Qe = [];
                return Object.keys(Nt).forEach(function(kt) {
                  Nt[kt].forEach(function(lt) {
                    var Et = null;
                    switch (lt) {
                      case "bold":
                        Et = { family: kt, weight: "bold" };
                        break;
                      case "italic":
                        Et = { family: kt, style: "italic" };
                        break;
                      case "bolditalic":
                        Et = { family: kt, weight: "bold", style: "italic" };
                        break;
                      case "":
                      case "normal":
                        Et = { family: kt };
                    }
                    Et !== null && (Et.ref = { name: kt, style: lt }, Qe.push(Et));
                  });
                }), Qe;
              })(bt);
              je = (function(Nt) {
                for (var Qe = {}, kt = 0; kt < Nt.length; ++kt) {
                  var lt = Ec(Nt[kt]), Et = lt.family, Jt = lt.stretch, vt = lt.style, ot = lt.weight;
                  Qe[Et] = Qe[Et] || {}, Qe[Et][Jt] = Qe[Et][Jt] || {}, Qe[Et][Jt][vt] = Qe[Et][Jt][vt] || {}, Qe[Et][Jt][vt][ot] = lt;
                }
                return Qe;
              })(dt.concat(Bt)), He = ht;
            }
            return je;
          })(this.pdf, this.fontFaces), Dt = it.map(function(ze) {
            return { family: ze, stretch: "normal", weight: at, style: gt };
          }), xt = (function(ze, Bt, bt) {
            for (var ht = (bt = bt || {}).defaultFontFamily || "times", dt = Object.assign({}, i8, bt.genericFontFamilies || {}), Nt = null, Qe = null, kt = 0; kt < Bt.length; ++kt) if (dt[(Nt = Ec(Bt[kt])).family] && (Nt.family = dt[Nt.family]), ze.hasOwnProperty(Nt.family)) {
              Qe = ze[Nt.family];
              break;
            }
            if (!(Qe = Qe || ze[ht])) throw new Error("Could not find a font-family for the rule '" + kd(Nt) + "' and default family '" + ht + "'.");
            if (Qe = (function(lt, Et) {
              if (Et[lt]) return Et[lt];
              var Jt = Xc[lt], vt = Jt <= Xc.normal ? -1 : 1, ot = Sd(Et, Op, Jt, vt);
              if (!ot) throw new Error("Could not find a matching font-stretch value for " + lt);
              return ot;
            })(Nt.stretch, Qe), Qe = (function(lt, Et) {
              if (Et[lt]) return Et[lt];
              for (var Jt = Pp[lt], vt = 0; vt < Jt.length; ++vt) if (Et[Jt[vt]]) return Et[Jt[vt]];
              throw new Error("Could not find a matching font-style for " + lt);
            })(Nt.style, Qe), !(Qe = (function(lt, Et) {
              if (Et[lt]) return Et[lt];
              if (lt === 400 && Et[500]) return Et[500];
              if (lt === 500 && Et[400]) return Et[400];
              var Jt = r8[lt], vt = Sd(Et, Rp, Jt, lt < 400 ? -1 : 1);
              if (!vt) throw new Error("Could not find a matching font-weight for value " + lt);
              return vt;
            })(Nt.weight, Qe))) throw new Error("Failed to resolve a font for the rule '" + kd(Nt) + "'.");
            return Qe;
          })(nt, Dt);
          this.pdf.setFont(xt.ref.name, xt.ref.style);
        } else {
          var he = "";
          (at === "bold" || parseInt(at, 10) >= 700 || gt === "bold") && (he = "bold"), gt === "italic" && (he += "italic"), he.length === 0 && (he = "normal");
          for (var ve = "", Fe = { arial: "Helvetica", Arial: "Helvetica", verdana: "Helvetica", Verdana: "Helvetica", helvetica: "Helvetica", Helvetica: "Helvetica", "sans-serif": "Helvetica", fixed: "Courier", monospace: "Courier", terminal: "Courier", cursive: "Times", fantasy: "Times", serif: "Times" }, Re = 0; Re < it.length; Re++) {
            if (this.pdf.internal.getFont(it[Re], he, { noFallback: !0, disableWarning: !0 }) !== void 0) {
              ve = it[Re];
              break;
            }
            if (he === "bolditalic" && this.pdf.internal.getFont(it[Re], "bold", { noFallback: !0, disableWarning: !0 }) !== void 0) ve = it[Re], he = "bold";
            else if (this.pdf.internal.getFont(it[Re], "normal", { noFallback: !0, disableWarning: !0 }) !== void 0) {
              ve = it[Re], he = "normal";
              break;
            }
          }
          if (ve === "") {
            for (var qe = 0; qe < it.length; qe++) if (Fe[it[qe]]) {
              ve = Fe[it[qe]];
              break;
            }
          }
          ve = ve === "" ? "Times" : ve, this.pdf.setFont(ve, he);
        }
      }
    } }), Object.defineProperty(this, "globalCompositeOperation", { get: function() {
      return this.ctx.globalCompositeOperation;
    }, set: function(F) {
      this.ctx.globalCompositeOperation = F;
    } }), Object.defineProperty(this, "globalAlpha", { get: function() {
      return this.ctx.globalAlpha;
    }, set: function(F) {
      this.ctx.globalAlpha = F;
    } }), Object.defineProperty(this, "lineDashOffset", { get: function() {
      return this.ctx.lineDashOffset;
    }, set: function(F) {
      this.ctx.lineDashOffset = F, xe.call(this);
    } }), Object.defineProperty(this, "lineDash", { get: function() {
      return this.ctx.lineDash;
    }, set: function(F) {
      this.ctx.lineDash = F, xe.call(this);
    } }), Object.defineProperty(this, "ignoreClearRect", { get: function() {
      return this.ctx.ignoreClearRect;
    }, set: function(F) {
      this.ctx.ignoreClearRect = !!F;
    } });
  };
  p.prototype.setLineDash = function(L) {
    this.lineDash = L;
  }, p.prototype.getLineDash = function() {
    return this.lineDash.length % 2 ? this.lineDash.concat(this.lineDash) : this.lineDash.slice();
  }, p.prototype.fill = function() {
    V.call(this, "fill", !1);
  }, p.prototype.stroke = function() {
    V.call(this, "stroke", !1);
  }, p.prototype.beginPath = function() {
    this.path = [{ type: "begin" }];
  }, p.prototype.moveTo = function(L, T) {
    if (isNaN(L) || isNaN(T)) throw Wt.error("jsPDF.context2d.moveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.moveTo");
    var G = this.ctx.transform.applyToPoint(new s(L, T));
    this.path.push({ type: "mt", x: G.x, y: G.y }), this.ctx.lastPoint = new s(L, T);
  }, p.prototype.closePath = function() {
    var L = new s(0, 0), T = 0;
    for (T = this.path.length - 1; T !== -1; T--) if (this.path[T].type === "begin" && qt(this.path[T + 1]) === "object" && typeof this.path[T + 1].x == "number") {
      L = new s(this.path[T + 1].x, this.path[T + 1].y);
      break;
    }
    this.path.push({ type: "close" }), this.ctx.lastPoint = new s(L.x, L.y);
  }, p.prototype.lineTo = function(L, T) {
    if (isNaN(L) || isNaN(T)) throw Wt.error("jsPDF.context2d.lineTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.lineTo");
    var G = this.ctx.transform.applyToPoint(new s(L, T));
    this.path.push({ type: "lt", x: G.x, y: G.y }), this.ctx.lastPoint = new s(G.x, G.y);
  }, p.prototype.clip = function() {
    this.ctx.clip_path = JSON.parse(JSON.stringify(this.path)), V.call(this, null, !0);
  }, p.prototype.quadraticCurveTo = function(L, T, G, ee) {
    if (isNaN(G) || isNaN(ee) || isNaN(L) || isNaN(T)) throw Wt.error("jsPDF.context2d.quadraticCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.quadraticCurveTo");
    var te = this.ctx.transform.applyToPoint(new s(G, ee)), le = this.ctx.transform.applyToPoint(new s(L, T));
    this.path.push({ type: "qct", x1: le.x, y1: le.y, x: te.x, y: te.y }), this.ctx.lastPoint = new s(te.x, te.y);
  }, p.prototype.bezierCurveTo = function(L, T, G, ee, te, le) {
    if (isNaN(te) || isNaN(le) || isNaN(L) || isNaN(T) || isNaN(G) || isNaN(ee)) throw Wt.error("jsPDF.context2d.bezierCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.bezierCurveTo");
    var ge = this.ctx.transform.applyToPoint(new s(te, le)), be = this.ctx.transform.applyToPoint(new s(L, T)), Ae = this.ctx.transform.applyToPoint(new s(G, ee));
    this.path.push({ type: "bct", x1: be.x, y1: be.y, x2: Ae.x, y2: Ae.y, x: ge.x, y: ge.y }), this.ctx.lastPoint = new s(ge.x, ge.y);
  }, p.prototype.arc = function(L, T, G, ee, te, le) {
    if (isNaN(L) || isNaN(T) || isNaN(G) || isNaN(ee) || isNaN(te)) throw Wt.error("jsPDF.context2d.arc: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.arc");
    if (le = !!le, !this.ctx.transform.isIdentity) {
      var ge = this.ctx.transform.applyToPoint(new s(L, T));
      L = ge.x, T = ge.y;
      var be = this.ctx.transform.applyToPoint(new s(0, G)), Ae = this.ctx.transform.applyToPoint(new s(0, 0));
      G = Math.sqrt(Math.pow(be.x - Ae.x, 2) + Math.pow(be.y - Ae.y, 2));
    }
    Math.abs(te - ee) >= 2 * Math.PI && (ee = 0, te = 2 * Math.PI), this.path.push({ type: "arc", x: L, y: T, radius: G, startAngle: ee, endAngle: te, counterclockwise: le });
  }, p.prototype.arcTo = function(L, T, G, ee, te) {
    throw new Error("arcTo not implemented.");
  }, p.prototype.rect = function(L, T, G, ee) {
    if (isNaN(L) || isNaN(T) || isNaN(G) || isNaN(ee)) throw Wt.error("jsPDF.context2d.rect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rect");
    this.moveTo(L, T), this.lineTo(L + G, T), this.lineTo(L + G, T + ee), this.lineTo(L, T + ee), this.lineTo(L, T), this.lineTo(L + G, T), this.lineTo(L, T);
  }, p.prototype.fillRect = function(L, T, G, ee) {
    if (isNaN(L) || isNaN(T) || isNaN(G) || isNaN(ee)) throw Wt.error("jsPDF.context2d.fillRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillRect");
    if (!d.call(this)) {
      var te = {};
      this.lineCap !== "butt" && (te.lineCap = this.lineCap, this.lineCap = "butt"), this.lineJoin !== "miter" && (te.lineJoin = this.lineJoin, this.lineJoin = "miter"), this.beginPath(), this.rect(L, T, G, ee), this.fill(), te.hasOwnProperty("lineCap") && (this.lineCap = te.lineCap), te.hasOwnProperty("lineJoin") && (this.lineJoin = te.lineJoin);
    }
  }, p.prototype.strokeRect = function(L, T, G, ee) {
    if (isNaN(L) || isNaN(T) || isNaN(G) || isNaN(ee)) throw Wt.error("jsPDF.context2d.strokeRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeRect");
    A.call(this) || (this.beginPath(), this.rect(L, T, G, ee), this.stroke());
  }, p.prototype.clearRect = function(L, T, G, ee) {
    if (isNaN(L) || isNaN(T) || isNaN(G) || isNaN(ee)) throw Wt.error("jsPDF.context2d.clearRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.clearRect");
    this.ignoreClearRect || (this.fillStyle = "#ffffff", this.fillRect(L, T, G, ee));
  }, p.prototype.save = function(L) {
    L = typeof L != "boolean" || L;
    for (var T = this.pdf.internal.getCurrentPageInfo().pageNumber, G = 0; G < this.pdf.internal.getNumberOfPages(); G++) this.pdf.setPage(G + 1), this.pdf.internal.out("q");
    if (this.pdf.setPage(T), L) {
      this.ctx.fontSize = this.pdf.internal.getFontSize();
      var ee = new f(this.ctx);
      this.ctxStack.push(this.ctx), this.ctx = ee;
    }
  }, p.prototype.restore = function(L) {
    L = typeof L != "boolean" || L;
    for (var T = this.pdf.internal.getCurrentPageInfo().pageNumber, G = 0; G < this.pdf.internal.getNumberOfPages(); G++) this.pdf.setPage(G + 1), this.pdf.internal.out("Q");
    this.pdf.setPage(T), L && this.ctxStack.length !== 0 && (this.ctx = this.ctxStack.pop(), this.fillStyle = this.ctx.fillStyle, this.strokeStyle = this.ctx.strokeStyle, this.font = this.ctx.font, this.lineCap = this.ctx.lineCap, this.lineWidth = this.ctx.lineWidth, this.lineJoin = this.ctx.lineJoin, this.lineDash = this.ctx.lineDash, this.lineDashOffset = this.ctx.lineDashOffset);
  }, p.prototype.toDataURL = function() {
    throw new Error("toDataUrl not implemented.");
  };
  var E = function(L) {
    var T, G, ee, te;
    if (L.isCanvasGradient === !0 && (L = L.getColor()), !L) return { r: 0, g: 0, b: 0, a: 0, style: L };
    if (/transparent|rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*0+\s*\)/.test(L)) T = 0, G = 0, ee = 0, te = 0;
    else {
      var le = /rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/.exec(L);
      if (le !== null) T = parseInt(le[1]), G = parseInt(le[2]), ee = parseInt(le[3]), te = 1;
      else if ((le = /rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d.]+)\s*\)/.exec(L)) !== null) T = parseInt(le[1]), G = parseInt(le[2]), ee = parseInt(le[3]), te = parseFloat(le[4]);
      else {
        if (te = 1, typeof L == "string" && L.charAt(0) !== "#") {
          var ge = new Np(L);
          L = ge.ok ? ge.toHex() : "#000000";
        }
        L.length === 4 ? (T = L.substring(1, 2), T += T, G = L.substring(2, 3), G += G, ee = L.substring(3, 4), ee += ee) : (T = L.substring(1, 3), G = L.substring(3, 5), ee = L.substring(5, 7)), T = parseInt(T, 16), G = parseInt(G, 16), ee = parseInt(ee, 16);
      }
    }
    return { r: T, g: G, b: ee, a: te, style: L };
  }, d = function() {
    return this.ctx.isFillTransparent || this.globalAlpha == 0;
  }, A = function() {
    return !!(this.ctx.isStrokeTransparent || this.globalAlpha == 0);
  };
  p.prototype.fillText = function(L, T, G, ee) {
    if (isNaN(T) || isNaN(G) || typeof L != "string") throw Wt.error("jsPDF.context2d.fillText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillText");
    if (ee = isNaN(ee) ? void 0 : ee, !d.call(this)) {
      var te = se(this.ctx.transform.rotation), le = this.ctx.transform.scaleX;
      I.call(this, { text: L, x: T, y: G, scale: le, angle: te, align: this.textAlign, maxWidth: ee });
    }
  }, p.prototype.strokeText = function(L, T, G, ee) {
    if (isNaN(T) || isNaN(G) || typeof L != "string") throw Wt.error("jsPDF.context2d.strokeText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeText");
    if (!A.call(this)) {
      ee = isNaN(ee) ? void 0 : ee;
      var te = se(this.ctx.transform.rotation), le = this.ctx.transform.scaleX;
      I.call(this, { text: L, x: T, y: G, scale: le, renderingMode: "stroke", angle: te, align: this.textAlign, maxWidth: ee });
    }
  }, p.prototype.measureText = function(L) {
    if (typeof L != "string") throw Wt.error("jsPDF.context2d.measureText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.measureText");
    var T = this.pdf, G = this.pdf.internal.scaleFactor, ee = T.internal.getFontSize(), te = T.getStringUnitWidth(L) * ee / T.internal.scaleFactor;
    return new function(le) {
      var ge = (le = le || {}).width || 0;
      return Object.defineProperty(this, "width", { get: function() {
        return ge;
      } }), this;
    }({ width: te *= Math.round(96 * G / 72 * 1e4) / 1e4 });
  }, p.prototype.scale = function(L, T) {
    if (isNaN(L) || isNaN(T)) throw Wt.error("jsPDF.context2d.scale: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.scale");
    var G = new u(L, 0, 0, T, 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(G);
  }, p.prototype.rotate = function(L) {
    if (isNaN(L)) throw Wt.error("jsPDF.context2d.rotate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rotate");
    var T = new u(Math.cos(L), Math.sin(L), -Math.sin(L), Math.cos(L), 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(T);
  }, p.prototype.translate = function(L, T) {
    if (isNaN(L) || isNaN(T)) throw Wt.error("jsPDF.context2d.translate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.translate");
    var G = new u(1, 0, 0, 1, L, T);
    this.ctx.transform = this.ctx.transform.multiply(G);
  }, p.prototype.transform = function(L, T, G, ee, te, le) {
    if (isNaN(L) || isNaN(T) || isNaN(G) || isNaN(ee) || isNaN(te) || isNaN(le)) throw Wt.error("jsPDF.context2d.transform: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.transform");
    var ge = new u(L, T, G, ee, te, le);
    this.ctx.transform = this.ctx.transform.multiply(ge);
  }, p.prototype.setTransform = function(L, T, G, ee, te, le) {
    L = isNaN(L) ? 1 : L, T = isNaN(T) ? 0 : T, G = isNaN(G) ? 0 : G, ee = isNaN(ee) ? 1 : ee, te = isNaN(te) ? 0 : te, le = isNaN(le) ? 0 : le, this.ctx.transform = new u(L, T, G, ee, te, le);
  };
  var v = function() {
    return this.margin[0] > 0 || this.margin[1] > 0 || this.margin[2] > 0 || this.margin[3] > 0;
  };
  p.prototype.drawImage = function(L, T, G, ee, te, le, ge, be, Ae) {
    var Ie = this.pdf.getImageProperties(L), je = 1, He = 1, tt = 1, F = 1;
    ee !== void 0 && be !== void 0 && (tt = be / ee, F = Ae / te, je = Ie.width / ee * be / ee, He = Ie.height / te * Ae / te), le === void 0 && (le = T, ge = G, T = 0, G = 0), ee !== void 0 && be === void 0 && (be = ee, Ae = te), ee === void 0 && be === void 0 && (be = Ie.width, Ae = Ie.height);
    var Ue = this.ctx.transform.decompose(), gt = se(Ue.rotate.shx), at = new u(), ke = (at = (at = (at = at.multiply(Ue.translate)).multiply(Ue.skew)).multiply(Ue.scale)).applyToRectangle(new o(le - T * tt, ge - G * F, ee * je, te * He));
    if (this.autoPaging) {
      for (var rt, Ye = C.call(this, ke), it = [], nt = 0; nt < Ye.length; nt += 1) it.indexOf(Ye[nt]) === -1 && it.push(Ye[nt]);
      B(it);
      for (var Dt = it[0], xt = it[it.length - 1], he = Dt; he < xt + 1; he++) {
        this.pdf.setPage(he);
        var ve = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], Fe = he === 1 ? this.posY + this.margin[0] : this.margin[0], Re = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], qe = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], ze = he === 1 ? 0 : Re + (he - 2) * qe;
        if (this.ctx.clip_path.length !== 0) {
          var Bt = this.path;
          rt = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = U(rt, this.posX + this.margin[3], -ze + Fe + this.ctx.prevPageLastElemOffset), ie.call(this, "fill", !0), this.path = Bt;
        }
        var bt = JSON.parse(JSON.stringify(ke));
        bt = U([bt], this.posX + this.margin[3], -ze + Fe + this.ctx.prevPageLastElemOffset)[0];
        var ht = (he > Dt || he < xt) && v.call(this);
        ht && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], ve, qe, null).clip().discardPath()), this.pdf.addImage(L, "JPEG", bt.x, bt.y, bt.w, bt.h, null, null, gt), ht && this.pdf.restoreGraphicsState();
      }
    } else this.pdf.addImage(L, "JPEG", ke.x, ke.y, ke.w, ke.h, null, null, gt);
  };
  var C = function(L, T, G) {
    var ee = [];
    T = T || this.pdf.internal.pageSize.width, G = G || this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2];
    var te = this.posY + this.ctx.prevPageLastElemOffset;
    switch (L.type) {
      default:
      case "mt":
      case "lt":
        ee.push(Math.floor((L.y + te) / G) + 1);
        break;
      case "arc":
        ee.push(Math.floor((L.y + te - L.radius) / G) + 1), ee.push(Math.floor((L.y + te + L.radius) / G) + 1);
        break;
      case "qct":
        var le = Ee(this.ctx.lastPoint.x, this.ctx.lastPoint.y, L.x1, L.y1, L.x, L.y);
        ee.push(Math.floor((le.y + te) / G) + 1), ee.push(Math.floor((le.y + le.h + te) / G) + 1);
        break;
      case "bct":
        var ge = M(this.ctx.lastPoint.x, this.ctx.lastPoint.y, L.x1, L.y1, L.x2, L.y2, L.x, L.y);
        ee.push(Math.floor((ge.y + te) / G) + 1), ee.push(Math.floor((ge.y + ge.h + te) / G) + 1);
        break;
      case "rect":
        ee.push(Math.floor((L.y + te) / G) + 1), ee.push(Math.floor((L.y + L.h + te) / G) + 1);
    }
    for (var be = 0; be < ee.length; be += 1) for (; this.pdf.internal.getNumberOfPages() < ee[be]; ) _.call(this);
    return ee;
  }, _ = function() {
    var L = this.fillStyle, T = this.strokeStyle, G = this.font, ee = this.lineCap, te = this.lineWidth, le = this.lineJoin;
    this.pdf.addPage(), this.fillStyle = L, this.strokeStyle = T, this.font = G, this.lineCap = ee, this.lineWidth = te, this.lineJoin = le;
  }, U = function(L, T, G) {
    for (var ee = 0; ee < L.length; ee++) switch (L[ee].type) {
      case "bct":
        L[ee].x2 += T, L[ee].y2 += G;
      case "qct":
        L[ee].x1 += T, L[ee].y1 += G;
      default:
        L[ee].x += T, L[ee].y += G;
    }
    return L;
  }, B = function(L) {
    return L.sort(function(T, G) {
      return T - G;
    });
  }, V = function(L, T) {
    var G = this.fillStyle, ee = this.strokeStyle, te = this.lineCap, le = this.lineWidth, ge = Math.abs(le * this.ctx.transform.scaleX), be = this.lineJoin;
    if (this.autoPaging) {
      for (var Ae, Ie, je = JSON.parse(JSON.stringify(this.path)), He = JSON.parse(JSON.stringify(this.path)), tt = [], F = 0; F < He.length; F++) if (He[F].x !== void 0) for (var Ue = C.call(this, He[F]), gt = 0; gt < Ue.length; gt += 1) tt.indexOf(Ue[gt]) === -1 && tt.push(Ue[gt]);
      for (var at = 0; at < tt.length; at++) for (; this.pdf.internal.getNumberOfPages() < tt[at]; ) _.call(this);
      B(tt);
      for (var ke = tt[0], rt = tt[tt.length - 1], Ye = ke; Ye < rt + 1; Ye++) {
        this.pdf.setPage(Ye), this.fillStyle = G, this.strokeStyle = ee, this.lineCap = te, this.lineWidth = ge, this.lineJoin = be;
        var it = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], nt = Ye === 1 ? this.posY + this.margin[0] : this.margin[0], Dt = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], xt = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], he = Ye === 1 ? 0 : Dt + (Ye - 2) * xt;
        if (this.ctx.clip_path.length !== 0) {
          var ve = this.path;
          Ae = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = U(Ae, this.posX + this.margin[3], -he + nt + this.ctx.prevPageLastElemOffset), ie.call(this, L, !0), this.path = ve;
        }
        if (Ie = JSON.parse(JSON.stringify(je)), this.path = U(Ie, this.posX + this.margin[3], -he + nt + this.ctx.prevPageLastElemOffset), T === !1 || Ye === 0) {
          var Fe = (Ye > ke || Ye < rt) && v.call(this);
          Fe && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], it, xt, null).clip().discardPath()), ie.call(this, L, T), Fe && this.pdf.restoreGraphicsState();
        }
        this.lineWidth = le;
      }
      this.path = je;
    } else this.lineWidth = ge, ie.call(this, L, T), this.lineWidth = le;
  }, ie = function(L, T) {
    if ((L !== "stroke" || T || !A.call(this)) && (L === "stroke" || T || !d.call(this))) {
      for (var G, ee, te = [], le = this.path, ge = 0; ge < le.length; ge++) {
        var be = le[ge];
        switch (be.type) {
          case "begin":
            te.push({ begin: !0 });
            break;
          case "close":
            te.push({ close: !0 });
            break;
          case "mt":
            te.push({ start: be, deltas: [], abs: [] });
            break;
          case "lt":
            var Ae = te.length;
            if (le[ge - 1] && !isNaN(le[ge - 1].x) && (G = [be.x - le[ge - 1].x, be.y - le[ge - 1].y], Ae > 0)) {
              for (; Ae >= 0; Ae--) if (te[Ae - 1].close !== !0 && te[Ae - 1].begin !== !0) {
                te[Ae - 1].deltas.push(G), te[Ae - 1].abs.push(be);
                break;
              }
            }
            break;
          case "bct":
            G = [be.x1 - le[ge - 1].x, be.y1 - le[ge - 1].y, be.x2 - le[ge - 1].x, be.y2 - le[ge - 1].y, be.x - le[ge - 1].x, be.y - le[ge - 1].y], te[te.length - 1].deltas.push(G);
            break;
          case "qct":
            var Ie = le[ge - 1].x + 2 / 3 * (be.x1 - le[ge - 1].x), je = le[ge - 1].y + 2 / 3 * (be.y1 - le[ge - 1].y), He = be.x + 2 / 3 * (be.x1 - be.x), tt = be.y + 2 / 3 * (be.y1 - be.y), F = be.x, Ue = be.y;
            G = [Ie - le[ge - 1].x, je - le[ge - 1].y, He - le[ge - 1].x, tt - le[ge - 1].y, F - le[ge - 1].x, Ue - le[ge - 1].y], te[te.length - 1].deltas.push(G);
            break;
          case "arc":
            te.push({ deltas: [], abs: [], arc: !0 }), Array.isArray(te[te.length - 1].abs) && te[te.length - 1].abs.push(be);
        }
      }
      ee = T ? null : L === "stroke" ? "stroke" : "fill";
      for (var gt = !1, at = 0; at < te.length; at++) if (te[at].arc) for (var ke = te[at].abs, rt = 0; rt < ke.length; rt++) {
        var Ye = ke[rt];
        Ye.type === "arc" ? Z.call(this, Ye.x, Ye.y, Ye.radius, Ye.startAngle, Ye.endAngle, Ye.counterclockwise, void 0, T, !gt) : $.call(this, Ye.x, Ye.y), gt = !0;
      }
      else if (te[at].close === !0) this.pdf.internal.out("h"), gt = !1;
      else if (te[at].begin !== !0) {
        var it = te[at].start.x, nt = te[at].start.y;
        Y.call(this, te[at].deltas, it, nt), gt = !0;
      }
      ee && z.call(this, ee), T && D.call(this);
    }
  }, K = function(L) {
    var T = this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor, G = T * (this.pdf.internal.getLineHeightFactor() - 1);
    switch (this.ctx.textBaseline) {
      case "bottom":
        return L - G;
      case "top":
        return L + T - G;
      case "hanging":
        return L + T - 2 * G;
      case "middle":
        return L + T / 2 - G;
      default:
        return L;
    }
  }, fe = function(L) {
    return L + this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor * (this.pdf.internal.getLineHeightFactor() - 1);
  };
  p.prototype.createLinearGradient = function() {
    var L = function() {
    };
    return L.colorStops = [], L.addColorStop = function(T, G) {
      this.colorStops.push([T, G]);
    }, L.getColor = function() {
      return this.colorStops.length === 0 ? "#000000" : this.colorStops[0][1];
    }, L.isCanvasGradient = !0, L;
  }, p.prototype.createPattern = function() {
    return this.createLinearGradient();
  }, p.prototype.createRadialGradient = function() {
    return this.createLinearGradient();
  };
  var Z = function(L, T, G, ee, te, le, ge, be, Ae) {
    for (var Ie = ue.call(this, G, ee, te, le), je = 0; je < Ie.length; je++) {
      var He = Ie[je];
      je === 0 && (Ae ? N.call(this, He.x1 + L, He.y1 + T) : $.call(this, He.x1 + L, He.y1 + T)), J.call(this, L, T, He.x2, He.y2, He.x3, He.y3, He.x4, He.y4);
    }
    be ? D.call(this) : z.call(this, ge);
  }, z = function(L) {
    switch (L) {
      case "stroke":
        this.pdf.internal.out("S");
        break;
      case "fill":
        this.pdf.internal.out("f");
    }
  }, D = function() {
    this.pdf.clip(), this.pdf.discardPath();
  }, N = function(L, T) {
    this.pdf.internal.out(n(L) + " " + r(T) + " m");
  }, I = function(L) {
    var T;
    switch (L.align) {
      case "right":
      case "end":
        T = "right";
        break;
      case "center":
        T = "center";
        break;
      default:
        T = "left";
    }
    var G, ee, te, le = this.pdf.getTextDimensions(L.text), ge = K.call(this, L.y), be = fe.call(this, ge) - le.h, Ae = this.ctx.transform.applyToPoint(new s(L.x, ge));
    if (this.autoPaging) {
      var Ie = this.ctx.transform.decompose(), je = new u();
      je = (je = (je = je.multiply(Ie.translate)).multiply(Ie.skew)).multiply(Ie.scale);
      for (var He = this.ctx.transform.applyToRectangle(new o(L.x, ge, le.w, le.h)), tt = je.applyToRectangle(new o(L.x, be, le.w, le.h)), F = C.call(this, tt), Ue = [], gt = 0; gt < F.length; gt += 1) Ue.indexOf(F[gt]) === -1 && Ue.push(F[gt]);
      B(Ue);
      for (var at = Ue[0], ke = Ue[Ue.length - 1], rt = at; rt < ke + 1; rt++) {
        this.pdf.setPage(rt);
        var Ye = rt === 1 ? this.posY + this.margin[0] : this.margin[0], it = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], nt = this.pdf.internal.pageSize.height - this.margin[2], Dt = nt - this.margin[0], xt = this.pdf.internal.pageSize.width - this.margin[1], he = xt - this.margin[3], ve = rt === 1 ? 0 : it + (rt - 2) * Dt;
        if (this.ctx.clip_path.length !== 0) {
          var Fe = this.path;
          G = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = U(G, this.posX + this.margin[3], -1 * ve + Ye), ie.call(this, "fill", !0), this.path = Fe;
        }
        var Re = U([JSON.parse(JSON.stringify(tt))], this.posX + this.margin[3], -ve + Ye + this.ctx.prevPageLastElemOffset)[0];
        L.scale >= 0.01 && (ee = this.pdf.internal.getFontSize(), this.pdf.setFontSize(ee * L.scale), te = this.lineWidth, this.lineWidth = te * L.scale);
        var qe = this.autoPaging !== "text";
        if (qe || Re.y + Re.h <= nt) {
          if (qe || Re.y >= Ye && Re.x <= xt) {
            var ze = qe ? L.text : this.pdf.splitTextToSize(L.text, L.maxWidth || xt - Re.x)[0], Bt = U([JSON.parse(JSON.stringify(He))], this.posX + this.margin[3], -ve + Ye + this.ctx.prevPageLastElemOffset)[0], bt = qe && (rt > at || rt < ke) && v.call(this);
            bt && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], he, Dt, null).clip().discardPath()), this.pdf.text(ze, Bt.x, Bt.y, { angle: L.angle, align: T, renderingMode: L.renderingMode }), bt && this.pdf.restoreGraphicsState();
          }
        } else Re.y < nt && (this.ctx.prevPageLastElemOffset += nt - Re.y);
        L.scale >= 0.01 && (this.pdf.setFontSize(ee), this.lineWidth = te);
      }
    } else L.scale >= 0.01 && (ee = this.pdf.internal.getFontSize(), this.pdf.setFontSize(ee * L.scale), te = this.lineWidth, this.lineWidth = te * L.scale), this.pdf.text(L.text, Ae.x + this.posX, Ae.y + this.posY, { angle: L.angle, align: T, renderingMode: L.renderingMode, maxWidth: L.maxWidth }), L.scale >= 0.01 && (this.pdf.setFontSize(ee), this.lineWidth = te);
  }, $ = function(L, T, G, ee) {
    G = G || 0, ee = ee || 0, this.pdf.internal.out(n(L + G) + " " + r(T + ee) + " l");
  }, Y = function(L, T, G) {
    return this.pdf.lines(L, T, G, null, null);
  }, J = function(L, T, G, ee, te, le, ge, be) {
    this.pdf.internal.out([t(i(G + L)), t(a(ee + T)), t(i(te + L)), t(a(le + T)), t(i(ge + L)), t(a(be + T)), "c"].join(" "));
  }, ue = function(L, T, G, ee) {
    for (var te = 2 * Math.PI, le = Math.PI / 2; T > G; ) T -= te;
    var ge = Math.abs(G - T);
    ge < te && ee && (ge = te - ge);
    for (var be = [], Ae = ee ? -1 : 1, Ie = T; ge > 1e-5; ) {
      var je = Ie + Ae * Math.min(ge, le);
      be.push(me.call(this, L, Ie, je)), ge -= Math.abs(je - Ie), Ie = je;
    }
    return be;
  }, me = function(L, T, G) {
    var ee = (G - T) / 2, te = L * Math.cos(ee), le = L * Math.sin(ee), ge = te, be = -le, Ae = ge * ge + be * be, Ie = Ae + ge * te + be * le, je = 4 / 3 * (Math.sqrt(2 * Ae * Ie) - Ie) / (ge * le - be * te), He = ge - je * be, tt = be + je * ge, F = He, Ue = -tt, gt = ee + T, at = Math.cos(gt), ke = Math.sin(gt);
    return { x1: L * Math.cos(T), y1: L * Math.sin(T), x2: He * at - tt * ke, y2: He * ke + tt * at, x3: F * at - Ue * ke, y3: F * ke + Ue * at, x4: L * Math.cos(G), y4: L * Math.sin(G) };
  }, se = function(L) {
    return 180 * L / Math.PI;
  }, Ee = function(L, T, G, ee, te, le) {
    var ge = L + 0.5 * (G - L), be = T + 0.5 * (ee - T), Ae = te + 0.5 * (G - te), Ie = le + 0.5 * (ee - le), je = Math.min(L, te, ge, Ae), He = Math.max(L, te, ge, Ae), tt = Math.min(T, le, be, Ie), F = Math.max(T, le, be, Ie);
    return new o(je, tt, He - je, F - tt);
  }, M = function(L, T, G, ee, te, le, ge, be) {
    var Ae, Ie, je, He, tt, F, Ue, gt, at, ke, rt, Ye, it, nt, Dt = G - L, xt = ee - T, he = te - G, ve = le - ee, Fe = ge - te, Re = be - le;
    for (Ie = 0; Ie < 41; Ie++) at = (Ue = (je = L + (Ae = Ie / 40) * Dt) + Ae * ((tt = G + Ae * he) - je)) + Ae * (tt + Ae * (te + Ae * Fe - tt) - Ue), ke = (gt = (He = T + Ae * xt) + Ae * ((F = ee + Ae * ve) - He)) + Ae * (F + Ae * (le + Ae * Re - F) - gt), Ie == 0 ? (rt = at, Ye = ke, it = at, nt = ke) : (rt = Math.min(rt, at), Ye = Math.min(Ye, ke), it = Math.max(it, at), nt = Math.max(nt, ke));
    return new o(Math.round(rt), Math.round(Ye), Math.round(it - rt), Math.round(nt - Ye));
  }, xe = function() {
    if (this.prevLineDash || this.ctx.lineDash.length || this.ctx.lineDashOffset) {
      var L, T, G = (L = this.ctx.lineDash, T = this.ctx.lineDashOffset, JSON.stringify({ lineDash: L, lineDashOffset: T }));
      this.prevLineDash !== G && (this.pdf.setLineDash(this.ctx.lineDash, this.ctx.lineDashOffset), this.prevLineDash = G);
    }
  };
})(et.API), /**
 * @license
 * jsPDF filters PlugIn
 * Copyright (c) 2014 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
(function(e) {
  var t = function(s) {
    var o, u, c, f, p, E, d, A, v, C;
    for (u = [], c = 0, f = (s += o = "\0\0\0\0".slice(s.length % 4 || 4)).length; f > c; c += 4) (p = (s.charCodeAt(c) << 24) + (s.charCodeAt(c + 1) << 16) + (s.charCodeAt(c + 2) << 8) + s.charCodeAt(c + 3)) !== 0 ? (E = (p = ((p = ((p = ((p = (p - (C = p % 85)) / 85) - (v = p % 85)) / 85) - (A = p % 85)) / 85) - (d = p % 85)) / 85) % 85, u.push(E + 33, d + 33, A + 33, v + 33, C + 33)) : u.push(122);
    return (function(_, U) {
      for (var B = U; B > 0; B--) _.pop();
    })(u, o.length), String.fromCharCode.apply(String, u) + "~>";
  }, n = function(s) {
    var o, u, c, f, p, E = String, d = "length", A = 255, v = "charCodeAt", C = "slice", _ = "replace";
    for (s[C](-2), s = s[C](0, -2)[_](/\s/g, "")[_]("z", "!!!!!"), c = [], f = 0, p = (s += o = "uuuuu"[C](s[d] % 5 || 5))[d]; p > f; f += 5) u = 52200625 * (s[v](f) - 33) + 614125 * (s[v](f + 1) - 33) + 7225 * (s[v](f + 2) - 33) + 85 * (s[v](f + 3) - 33) + (s[v](f + 4) - 33), c.push(A & u >> 24, A & u >> 16, A & u >> 8, A & u);
    return (function(U, B) {
      for (var V = B; V > 0; V--) U.pop();
    })(c, o[d]), E.fromCharCode.apply(E, c);
  }, r = function(s) {
    return s.split("").map(function(o) {
      return ("0" + o.charCodeAt().toString(16)).slice(-2);
    }).join("") + ">";
  }, i = function(s) {
    var o = new RegExp(/^([0-9A-Fa-f]{2})+$/);
    if ((s = s.replace(/\s/g, "")).indexOf(">") !== -1 && (s = s.substr(0, s.indexOf(">"))), s.length % 2 && (s += "0"), o.test(s) === !1) return "";
    for (var u = "", c = 0; c < s.length; c += 2) u += String.fromCharCode("0x" + (s[c] + s[c + 1]));
    return u;
  }, a = function(s) {
    for (var o = new Uint8Array(s.length), u = s.length; u--; ) o[u] = s.charCodeAt(u);
    return (o = qc(o)).reduce(function(c, f) {
      return c + String.fromCharCode(f);
    }, "");
  };
  e.processDataByFilters = function(s, o) {
    var u = 0, c = s || "", f = [];
    for (typeof (o = o || []) == "string" && (o = [o]), u = 0; u < o.length; u += 1) switch (o[u]) {
      case "ASCII85Decode":
      case "/ASCII85Decode":
        c = n(c), f.push("/ASCII85Encode");
        break;
      case "ASCII85Encode":
      case "/ASCII85Encode":
        c = t(c), f.push("/ASCII85Decode");
        break;
      case "ASCIIHexDecode":
      case "/ASCIIHexDecode":
        c = i(c), f.push("/ASCIIHexEncode");
        break;
      case "ASCIIHexEncode":
      case "/ASCIIHexEncode":
        c = r(c), f.push("/ASCIIHexDecode");
        break;
      case "FlateEncode":
      case "/FlateEncode":
        c = a(c), f.push("/FlateDecode");
        break;
      default:
        throw new Error('The filter: "' + o[u] + '" is not implemented');
    }
    return { data: c, reverseChain: f.reverse().join(" ") };
  };
})(et.API), /**
 * @license
 * jsPDF fileloading PlugIn
 * Copyright (c) 2018 Aras Abbasi (aras.abbasi@gmail.com)
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
(function(e) {
  e.loadFile = function(t, n, r) {
    return (function(i, a, s) {
      a = a !== !1, s = typeof s == "function" ? s : function() {
      };
      var o = void 0;
      try {
        o = (function(u, c, f) {
          var p = new XMLHttpRequest(), E = 0, d = function(A) {
            var v = A.length, C = [], _ = String.fromCharCode;
            for (E = 0; E < v; E += 1) C.push(_(255 & A.charCodeAt(E)));
            return C.join("");
          };
          if (p.open("GET", u, !c), p.overrideMimeType("text/plain; charset=x-user-defined"), c === !1 && (p.onload = function() {
            p.status === 200 ? f(d(this.responseText)) : f(void 0);
          }), p.send(null), c && p.status === 200) return d(p.responseText);
        })(i, a, s);
      } catch {
      }
      return o;
    })(t, n, r);
  }, e.allowFsRead = void 0, e.loadImageFile = e.loadFile;
})(et.API), (function(e) {
  function t() {
    return (ct.html2canvas ? Promise.resolve(ct.html2canvas) : import("./html2canvas.esm-dgT_1dIT.js")).catch(function(o) {
      return Promise.reject(new Error("Could not load html2canvas: " + o));
    }).then(function(o) {
      return o.default ? o.default : o;
    });
  }
  function n() {
    return (ct.DOMPurify ? Promise.resolve(ct.DOMPurify) : import("./purify.es-BpFm6ZGf.js")).catch(function(o) {
      return Promise.reject(new Error("Could not load dompurify: " + o));
    }).then(function(o) {
      return o.default ? o.default : o;
    });
  }
  var r = function(o) {
    var u = qt(o);
    return u === "undefined" ? "undefined" : u === "string" || o instanceof String ? "string" : u === "number" || o instanceof Number ? "number" : u === "function" || o instanceof Function ? "function" : o && o.constructor === Array ? "array" : o && o.nodeType === 1 ? "element" : u === "object" ? "object" : "unknown";
  }, i = function(o, u) {
    var c = document.createElement(o);
    for (var f in u.className && (c.className = u.className), u.innerHTML && u.dompurify && (c.innerHTML = u.dompurify.sanitize(u.innerHTML)), u.style) c.style[f] = u.style[f];
    return c;
  }, a = function o(u, c) {
    for (var f = u.nodeType === 3 ? document.createTextNode(u.nodeValue) : u.cloneNode(!1), p = u.firstChild; p; p = p.nextSibling) c !== !0 && p.nodeType === 1 && p.nodeName === "SCRIPT" || f.appendChild(o(p, c));
    return u.nodeType === 1 && (u.nodeName === "CANVAS" ? (f.width = u.width, f.height = u.height, f.getContext("2d").drawImage(u, 0, 0)) : u.nodeName !== "TEXTAREA" && u.nodeName !== "SELECT" || (f.value = u.value), f.addEventListener("load", function() {
      f.scrollTop = u.scrollTop, f.scrollLeft = u.scrollLeft;
    }, !0)), f;
  }, s = function o(u) {
    var c = Object.assign(o.convert(Promise.resolve()), JSON.parse(JSON.stringify(o.template))), f = o.convert(Promise.resolve(), c);
    return (f = f.setProgress(1, o, 1, [o])).set(u);
  };
  (s.prototype = Object.create(Promise.prototype)).constructor = s, s.convert = function(o, u) {
    return o.__proto__ = u || s.prototype, o;
  }, s.template = { prop: { src: null, container: null, overlay: null, canvas: null, img: null, pdf: null, pageSize: null, callback: function() {
  } }, progress: { val: 0, state: null, n: 0, stack: [] }, opt: { filename: "file.pdf", margin: [0, 0, 0, 0], enableLinks: !0, x: 0, y: 0, html2canvas: {}, jsPDF: {}, backgroundColor: "transparent" } }, s.prototype.from = function(o, u) {
    return this.then(function() {
      switch (u = u || (function(c) {
        switch (r(c)) {
          case "string":
            return "string";
          case "element":
            return c.nodeName.toLowerCase() === "canvas" ? "canvas" : "element";
          default:
            return "unknown";
        }
      })(o), u) {
        case "string":
          return this.then(n).then(function(c) {
            return this.set({ src: i("div", { innerHTML: o, dompurify: c }) });
          });
        case "element":
          return this.set({ src: o });
        case "canvas":
          return this.set({ canvas: o });
        case "img":
          return this.set({ img: o });
        default:
          return this.error("Unknown source type.");
      }
    });
  }, s.prototype.to = function(o) {
    switch (o) {
      case "container":
        return this.toContainer();
      case "canvas":
        return this.toCanvas();
      case "img":
        return this.toImg();
      case "pdf":
        return this.toPdf();
      default:
        return this.error("Invalid target.");
    }
  }, s.prototype.toContainer = function() {
    return this.thenList([function() {
      return this.prop.src || this.error("Cannot duplicate - no source HTML.");
    }, function() {
      return this.prop.pageSize || this.setPageSize();
    }]).then(function() {
      var o = { position: "relative", display: "inline-block", width: (typeof this.opt.width != "number" || isNaN(this.opt.width) || typeof this.opt.windowWidth != "number" || isNaN(this.opt.windowWidth) ? Math.max(this.prop.src.clientWidth, this.prop.src.scrollWidth, this.prop.src.offsetWidth) : this.opt.windowWidth) + "px", left: 0, right: 0, top: 0, margin: "auto", backgroundColor: this.opt.backgroundColor }, u = a(this.prop.src, this.opt.html2canvas.javascriptEnabled);
      u.tagName === "BODY" && (o.height = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) + "px"), this.prop.overlay = i("div", { className: "html2pdf__overlay", style: { position: "fixed", overflow: "hidden", zIndex: 1e3, left: "-100000px", right: 0, bottom: 0, top: 0 } }), this.prop.container = i("div", { className: "html2pdf__container", style: o }), this.prop.container.appendChild(u), this.prop.container.firstChild.appendChild(i("div", { style: { clear: "both", border: "0 none transparent", margin: 0, padding: 0, height: 0 } })), this.prop.container.style.float = "none", this.prop.overlay.appendChild(this.prop.container), document.body.appendChild(this.prop.overlay), this.prop.container.firstChild.style.position = "relative", this.prop.container.height = Math.max(this.prop.container.firstChild.clientHeight, this.prop.container.firstChild.scrollHeight, this.prop.container.firstChild.offsetHeight) + "px";
    });
  }, s.prototype.toCanvas = function() {
    var o = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(o).then(t).then(function(u) {
      var c = Object.assign({}, this.opt.html2canvas);
      return delete c.onrendered, u(this.prop.container, c);
    }).then(function(u) {
      (this.opt.html2canvas.onrendered || function() {
      })(u), this.prop.canvas = u, document.body.removeChild(this.prop.overlay);
    });
  }, s.prototype.toContext2d = function() {
    var o = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(o).then(t).then(function(u) {
      var c = this.opt.jsPDF, f = this.opt.fontFaces, p = typeof this.opt.width != "number" || isNaN(this.opt.width) || typeof this.opt.windowWidth != "number" || isNaN(this.opt.windowWidth) ? 1 : this.opt.width / this.opt.windowWidth, E = Object.assign({ async: !0, allowTaint: !0, scale: p, scrollX: this.opt.scrollX || 0, scrollY: this.opt.scrollY || 0, backgroundColor: "#ffffff", imageTimeout: 15e3, logging: !0, proxy: null, removeContainer: !0, foreignObjectRendering: !1, useCORS: !1 }, this.opt.html2canvas);
      if (delete E.onrendered, c.context2d.autoPaging = this.opt.autoPaging === void 0 || this.opt.autoPaging, c.context2d.posX = this.opt.x, c.context2d.posY = this.opt.y, c.context2d.margin = this.opt.margin, c.context2d.fontFaces = f, f) for (var d = 0; d < f.length; ++d) {
        var A = f[d], v = A.src.find(function(C) {
          return C.format === "truetype";
        });
        v && c.addFont(v.url, A.ref.name, A.ref.style);
      }
      return E.windowHeight = E.windowHeight || 0, E.windowHeight = E.windowHeight == 0 ? Math.max(this.prop.container.clientHeight, this.prop.container.scrollHeight, this.prop.container.offsetHeight) : E.windowHeight, c.context2d.save(!0), u(this.prop.container, E);
    }).then(function(u) {
      this.opt.jsPDF.context2d.restore(!0), (this.opt.html2canvas.onrendered || function() {
      })(u), this.prop.canvas = u, document.body.removeChild(this.prop.overlay);
    });
  }, s.prototype.toImg = function() {
    return this.thenList([function() {
      return this.prop.canvas || this.toCanvas();
    }]).then(function() {
      var o = this.prop.canvas.toDataURL("image/" + this.opt.image.type, this.opt.image.quality);
      this.prop.img = document.createElement("img"), this.prop.img.src = o;
    });
  }, s.prototype.toPdf = function() {
    return this.thenList([function() {
      return this.toContext2d();
    }]).then(function() {
      this.prop.pdf = this.prop.pdf || this.opt.jsPDF;
    });
  }, s.prototype.output = function(o, u, c) {
    return (c = c || "pdf").toLowerCase() === "img" || c.toLowerCase() === "image" ? this.outputImg(o, u) : this.outputPdf(o, u);
  }, s.prototype.outputPdf = function(o, u) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      return this.prop.pdf.output(o, u);
    });
  }, s.prototype.outputImg = function(o) {
    return this.thenList([function() {
      return this.prop.img || this.toImg();
    }]).then(function() {
      switch (o) {
        case void 0:
        case "img":
          return this.prop.img;
        case "datauristring":
        case "dataurlstring":
          return this.prop.img.src;
        case "datauri":
        case "dataurl":
          return document.location.href = this.prop.img.src;
        default:
          throw 'Image output type "' + o + '" is not supported.';
      }
    });
  }, s.prototype.save = function(o) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).set(o ? { filename: o } : null).then(function() {
      this.prop.pdf.save(this.opt.filename);
    });
  }, s.prototype.doCallback = function() {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      this.prop.callback(this.prop.pdf);
    });
  }, s.prototype.set = function(o) {
    if (r(o) !== "object") return this;
    var u = Object.keys(o || {}).map(function(c) {
      if (c in s.template.prop) return function() {
        this.prop[c] = o[c];
      };
      switch (c) {
        case "margin":
          return this.setMargin.bind(this, o.margin);
        case "jsPDF":
          return function() {
            return this.opt.jsPDF = o.jsPDF, this.setPageSize();
          };
        case "pageSize":
          return this.setPageSize.bind(this, o.pageSize);
        default:
          return function() {
            this.opt[c] = o[c];
          };
      }
    }, this);
    return this.then(function() {
      return this.thenList(u);
    });
  }, s.prototype.get = function(o, u) {
    return this.then(function() {
      var c = o in s.template.prop ? this.prop[o] : this.opt[o];
      return u ? u(c) : c;
    });
  }, s.prototype.setMargin = function(o) {
    return this.then(function() {
      switch (r(o)) {
        case "number":
          o = [o, o, o, o];
        case "array":
          if (o.length === 2 && (o = [o[0], o[1], o[0], o[1]]), o.length === 4) break;
        default:
          return this.error("Invalid margin array.");
      }
      this.opt.margin = o;
    }).then(this.setPageSize);
  }, s.prototype.setPageSize = function(o) {
    function u(c, f) {
      return Math.floor(c * f / 72 * 96);
    }
    return this.then(function() {
      (o = o || et.getPageSize(this.opt.jsPDF)).hasOwnProperty("inner") || (o.inner = { width: o.width - this.opt.margin[1] - this.opt.margin[3], height: o.height - this.opt.margin[0] - this.opt.margin[2] }, o.inner.px = { width: u(o.inner.width, o.k), height: u(o.inner.height, o.k) }, o.inner.ratio = o.inner.height / o.inner.width), this.prop.pageSize = o;
    });
  }, s.prototype.setProgress = function(o, u, c, f) {
    return o != null && (this.progress.val = o), u != null && (this.progress.state = u), c != null && (this.progress.n = c), f != null && (this.progress.stack = f), this.progress.ratio = this.progress.val / this.progress.state, this;
  }, s.prototype.updateProgress = function(o, u, c, f) {
    return this.setProgress(o ? this.progress.val + o : null, u || null, c ? this.progress.n + c : null, f ? this.progress.stack.concat(f) : null);
  }, s.prototype.then = function(o, u) {
    var c = this;
    return this.thenCore(o, u, function(f, p) {
      return c.updateProgress(null, null, 1, [f]), Promise.prototype.then.call(this, function(E) {
        return c.updateProgress(null, f), E;
      }).then(f, p).then(function(E) {
        return c.updateProgress(1), E;
      });
    });
  }, s.prototype.thenCore = function(o, u, c) {
    c = c || Promise.prototype.then;
    var f = this;
    o && (o = o.bind(f)), u && (u = u.bind(f));
    var p = Promise.toString().indexOf("[native code]") !== -1 && Promise.name === "Promise" ? f : s.convert(Object.assign({}, f), Promise.prototype), E = c.call(p, o, u);
    return s.convert(E, f.__proto__);
  }, s.prototype.thenExternal = function(o, u) {
    return Promise.prototype.then.call(this, o, u);
  }, s.prototype.thenList = function(o) {
    var u = this;
    return o.forEach(function(c) {
      u = u.thenCore(c);
    }), u;
  }, s.prototype.catch = function(o) {
    o && (o = o.bind(this));
    var u = Promise.prototype.catch.call(this, o);
    return s.convert(u, this);
  }, s.prototype.catchExternal = function(o) {
    return Promise.prototype.catch.call(this, o);
  }, s.prototype.error = function(o) {
    return this.then(function() {
      throw new Error(o);
    });
  }, s.prototype.using = s.prototype.set, s.prototype.saveAs = s.prototype.save, s.prototype.export = s.prototype.output, s.prototype.run = s.prototype.then, et.getPageSize = function(o, u, c) {
    if (qt(o) === "object") {
      var f = o;
      o = f.orientation, u = f.unit || u, c = f.format || c;
    }
    u = u || "mm", c = c || "a4", o = ("" + (o || "P")).toLowerCase();
    var p, E = ("" + c).toLowerCase(), d = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
    switch (u) {
      case "pt":
        p = 1;
        break;
      case "mm":
        p = 72 / 25.4;
        break;
      case "cm":
        p = 72 / 2.54;
        break;
      case "in":
        p = 72;
        break;
      case "px":
        p = 0.75;
        break;
      case "pc":
      case "em":
        p = 12;
        break;
      case "ex":
        p = 6;
        break;
      default:
        throw "Invalid unit: " + u;
    }
    var A, v = 0, C = 0;
    if (d.hasOwnProperty(E)) v = d[E][1] / p, C = d[E][0] / p;
    else try {
      v = c[1], C = c[0];
    } catch {
      throw new Error("Invalid format: " + c);
    }
    if (o === "p" || o === "portrait") o = "p", C > v && (A = C, C = v, v = A);
    else {
      if (o !== "l" && o !== "landscape") throw "Invalid orientation: " + o;
      o = "l", v > C && (A = C, C = v, v = A);
    }
    return { width: C, height: v, unit: u, k: p, orientation: o };
  }, e.html = function(o, u) {
    (u = u || {}).callback = u.callback || function() {
    }, u.html2canvas = u.html2canvas || {}, u.html2canvas.canvas = u.html2canvas.canvas || this.canvas, u.jsPDF = u.jsPDF || this, u.fontFaces = u.fontFaces ? u.fontFaces.map(Ec) : null;
    var c = new s(u);
    return u.worker ? c : c.from(o).doCallback();
  };
})(et.API), et.API.addJS = function(e) {
  return Pd = e, this.internal.events.subscribe("postPutResources", function() {
    yu = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/Names [(EmbeddedJS) " + (yu + 1) + " 0 R]"), this.internal.out(">>"), this.internal.out("endobj"), Id = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /JavaScript"), this.internal.out("/JS (" + Pd + ")"), this.internal.out(">>"), this.internal.out("endobj");
  }), this.internal.events.subscribe("putCatalog", function() {
    yu !== void 0 && Id !== void 0 && this.internal.out("/Names <</JavaScript " + yu + " 0 R>>");
  }), this;
}, /**
 * @license
 * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
(function(e) {
  var t;
  e.events.push(["postPutResources", function() {
    var n = this, r = /^(\d+) 0 obj$/;
    if (this.outline.root.children.length > 0) for (var i = n.outline.render().split(/\r\n/), a = 0; a < i.length; a++) {
      var s = i[a], o = r.exec(s);
      if (o != null) {
        var u = o[1];
        n.internal.newObjectDeferredBegin(u, !1);
      }
      n.internal.write(s);
    }
    if (this.outline.createNamedDestinations) {
      var c = this.internal.pages.length, f = [];
      for (a = 0; a < c; a++) {
        var p = n.internal.newObject();
        f.push(p);
        var E = n.internal.getPageInfo(a + 1);
        n.internal.write("<< /D[" + E.objId + " 0 R /XYZ null null null]>> endobj");
      }
      var d = n.internal.newObject();
      for (n.internal.write("<< /Names [ "), a = 0; a < f.length; a++) n.internal.write("(page_" + (a + 1) + ")" + f[a] + " 0 R");
      n.internal.write(" ] >>", "endobj"), t = n.internal.newObject(), n.internal.write("<< /Dests " + d + " 0 R"), n.internal.write(">>", "endobj");
    }
  }]), e.events.push(["putCatalog", function() {
    var n = this;
    n.outline.root.children.length > 0 && (n.internal.write("/Outlines", this.outline.makeRef(this.outline.root)), this.outline.createNamedDestinations && n.internal.write("/Names " + t + " 0 R"));
  }]), e.events.push(["initialized", function() {
    var n = this;
    n.outline = { createNamedDestinations: !1, root: { children: [] } }, n.outline.add = function(r, i, a) {
      var s = { title: i, options: a, children: [] };
      return r == null && (r = this.root), r.children.push(s), s;
    }, n.outline.render = function() {
      return this.ctx = {}, this.ctx.val = "", this.ctx.pdf = n, this.genIds_r(this.root), this.renderRoot(this.root), this.renderItems(this.root), this.ctx.val;
    }, n.outline.genIds_r = function(r) {
      r.id = n.internal.newObjectDeferred();
      for (var i = 0; i < r.children.length; i++) this.genIds_r(r.children[i]);
    }, n.outline.renderRoot = function(r) {
      this.objStart(r), this.line("/Type /Outlines"), r.children.length > 0 && (this.line("/First " + this.makeRef(r.children[0])), this.line("/Last " + this.makeRef(r.children[r.children.length - 1]))), this.line("/Count " + this.count_r({ count: 0 }, r)), this.objEnd();
    }, n.outline.renderItems = function(r) {
      for (var i = this.ctx.pdf.internal.getVerticalCoordinateString, a = 0; a < r.children.length; a++) {
        var s = r.children[a];
        this.objStart(s), this.line("/Title " + this.makeString(s.title)), this.line("/Parent " + this.makeRef(r)), a > 0 && this.line("/Prev " + this.makeRef(r.children[a - 1])), a < r.children.length - 1 && this.line("/Next " + this.makeRef(r.children[a + 1])), s.children.length > 0 && (this.line("/First " + this.makeRef(s.children[0])), this.line("/Last " + this.makeRef(s.children[s.children.length - 1])));
        var o = this.count = this.count_r({ count: 0 }, s);
        if (o > 0 && this.line("/Count " + o), s.options && s.options.pageNumber) {
          var u = n.internal.getPageInfo(s.options.pageNumber);
          this.line("/Dest [" + u.objId + " 0 R /XYZ 0 " + i(0) + " 0]");
        }
        this.objEnd();
      }
      for (var c = 0; c < r.children.length; c++) this.renderItems(r.children[c]);
    }, n.outline.line = function(r) {
      this.ctx.val += r + `\r
`;
    }, n.outline.makeRef = function(r) {
      return r.id + " 0 R";
    }, n.outline.makeString = function(r) {
      return "(" + n.internal.pdfEscape(r) + ")";
    }, n.outline.objStart = function(r) {
      this.ctx.val += `\r
` + r.id + ` 0 obj\r
<<\r
`;
    }, n.outline.objEnd = function() {
      this.ctx.val += `>> \r
endobj\r
`;
    }, n.outline.count_r = function(r, i) {
      for (var a = 0; a < i.children.length; a++) r.count++, this.count_r(r, i.children[a]);
      return r.count;
    };
  }]);
})(et.API), /**
 * @license
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
(function(e) {
  var t = [192, 193, 194, 195, 196, 197, 198, 199];
  e.processJPEG = function(n, r, i, a, s, o) {
    var u, c = this.decode.DCT_DECODE, f = null;
    if (typeof n == "string" || this.__addimage__.isArrayBuffer(n) || this.__addimage__.isArrayBufferView(n)) {
      switch (n = s || n, n = this.__addimage__.isArrayBuffer(n) ? new Uint8Array(n) : n, u = (function(p) {
        for (var E, d = 256 * p.charCodeAt(4) + p.charCodeAt(5), A = p.length, v = { width: 0, height: 0, numcomponents: 1 }, C = 4; C < A; C += 2) {
          if (C += d, t.indexOf(p.charCodeAt(C + 1)) !== -1) {
            E = 256 * p.charCodeAt(C + 5) + p.charCodeAt(C + 6), v = { width: 256 * p.charCodeAt(C + 7) + p.charCodeAt(C + 8), height: E, numcomponents: p.charCodeAt(C + 9) };
            break;
          }
          d = 256 * p.charCodeAt(C + 2) + p.charCodeAt(C + 3);
        }
        return v;
      })(n = this.__addimage__.isArrayBufferView(n) ? this.__addimage__.arrayBufferToBinaryString(n) : n), u.numcomponents) {
        case 1:
          o = this.color_spaces.DEVICE_GRAY;
          break;
        case 4:
          o = this.color_spaces.DEVICE_CMYK;
          break;
        case 3:
          o = this.color_spaces.DEVICE_RGB;
      }
      f = { data: n, width: u.width, height: u.height, colorSpace: o, bitsPerComponent: 8, filter: c, index: r, alias: i };
    }
    return f;
  };
})(et.API), et.API.processPNG = function(e, t, n, r) {
  if (this.__addimage__.isArrayBuffer(e) && (e = new Uint8Array(e)), this.__addimage__.isArrayBufferView(e)) {
    var i, a = zx(e, { checkCrc: !0 }), s = a.width, o = a.height, u = a.channels, c = a.palette, f = a.depth;
    i = c && u === 1 ? (function(Z) {
      for (var z = Z.width, D = Z.height, N = Z.data, I = Z.palette, $ = Z.depth, Y = !1, J = [], ue = [], me = void 0, se = !1, Ee = 0, M = 0; M < I.length; M++) {
        var xe = M0(I[M], 4), L = xe[0], T = xe[1], G = xe[2], ee = xe[3];
        J.push(L, T, G), ee != null && (ee === 0 ? (Ee++, ue.length < 1 && ue.push(M)) : ee < 255 && (se = !0));
      }
      if (se || Ee > 1) {
        Y = !0, ue = void 0;
        var te = z * D;
        me = new Uint8Array(te);
        for (var le = new DataView(N.buffer), ge = 0; ge < te; ge++) {
          var be = Tc(le, ge, $), Ae = M0(I[be], 4)[3];
          me[ge] = Ae;
        }
      } else Ee === 0 && (ue = void 0);
      return { colorSpace: "Indexed", colorsPerPixel: 1, sMaskBitsPerComponent: Y ? 8 : void 0, colorBytes: N, alphaBytes: me, needSMask: Y, palette: J, mask: ue };
    })(a) : u === 2 || u === 4 ? (function(Z) {
      for (var z = Z.data, D = Z.width, N = Z.height, I = Z.channels, $ = Z.depth, Y = I === 2 ? "DeviceGray" : "DeviceRGB", J = I - 1, ue = D * N, me = J, se = ue * me, Ee = 1 * ue, M = Math.ceil(se * $ / 8), xe = Math.ceil(Ee * $ / 8), L = new Uint8Array(M), T = new Uint8Array(xe), G = new DataView(z.buffer), ee = new DataView(L.buffer), te = new DataView(T.buffer), le = !1, ge = 0; ge < ue; ge++) {
        for (var be = ge * I, Ae = 0; Ae < me; Ae++) jd(ee, Tc(G, be + Ae, $), ge * me + Ae, $);
        var Ie = Tc(G, be + me, $);
        Ie < (1 << $) - 1 && (le = !0), jd(te, Ie, 1 * ge, $);
      }
      return { colorSpace: Y, colorsPerPixel: J, sMaskBitsPerComponent: le ? $ : void 0, colorBytes: L, alphaBytes: T, needSMask: le };
    })(a) : (function(Z) {
      var z = Z.data, D = Z.channels === 1 ? "DeviceGray" : "DeviceRGB";
      return { colorSpace: D, colorsPerPixel: D === "DeviceGray" ? 1 : 3, colorBytes: z instanceof Uint16Array ? (function(N) {
        for (var I = N.length, $ = new Uint8Array(2 * I), Y = new DataView($.buffer, $.byteOffset, $.byteLength), J = 0; J < I; J++) Y.setUint16(2 * J, N[J], !1);
        return $;
      })(z) : z, needSMask: !1 };
    })(a);
    var p, E, d, A = i, v = A.colorSpace, C = A.colorsPerPixel, _ = A.sMaskBitsPerComponent, U = A.colorBytes, B = A.alphaBytes, V = A.needSMask, ie = A.palette, K = A.mask, fe = null;
    return r !== et.API.image_compression.NONE && typeof qc == "function" ? (fe = (function(Z) {
      var z;
      switch (Z) {
        case et.API.image_compression.FAST:
          z = 11;
          break;
        case et.API.image_compression.MEDIUM:
          z = 13;
          break;
        case et.API.image_compression.SLOW:
          z = 14;
          break;
        default:
          z = 12;
      }
      return z;
    })(r), p = this.decode.FLATE_DECODE, E = "/Predictor ".concat(fe, " /Colors ").concat(C, " /BitsPerComponent ").concat(f, " /Columns ").concat(s), e = Md(U, Math.ceil(s * C * f / 8), C, f, r), V && (d = Md(B, Math.ceil(s * _ / 8), 1, _, r))) : (p = void 0, E = void 0, e = U, V && (d = B)), (this.__addimage__.isArrayBuffer(e) || this.__addimage__.isArrayBufferView(e)) && (e = this.__addimage__.arrayBufferToBinaryString(e)), (d && this.__addimage__.isArrayBuffer(d) || this.__addimage__.isArrayBufferView(d)) && (d = this.__addimage__.arrayBufferToBinaryString(d)), { alias: n, data: e, index: t, filter: p, decodeParameters: E, transparency: K, palette: ie, sMask: d, predictor: fe, width: s, height: o, bitsPerComponent: f, sMaskBitsPerComponent: _, colorSpace: v };
  }
}, (function(e) {
  e.processGIF89A = function(t, n, r, i) {
    var a = new c8(t), s = a.width, o = a.height, u = [];
    a.decodeAndBlitFrameRGBA(0, u);
    var c = { data: u, width: s, height: o }, f = new _c(100).encode(c, 100);
    return e.processJPEG.call(this, f, n, r, i);
  }, e.processGIF87A = e.processGIF89A;
})(et.API), Mr.prototype.parseHeader = function() {
  if (this.fileSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.reserved = this.datav.getUint32(this.pos, !0), this.pos += 4, this.offset = this.datav.getUint32(this.pos, !0), this.pos += 4, this.headerSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.width = this.datav.getUint32(this.pos, !0), this.pos += 4, this.height = this.datav.getInt32(this.pos, !0), this.pos += 4, this.planes = this.datav.getUint16(this.pos, !0), this.pos += 2, this.bitPP = this.datav.getUint16(this.pos, !0), this.pos += 2, this.compress = this.datav.getUint32(this.pos, !0), this.pos += 4, this.rawSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.hr = this.datav.getUint32(this.pos, !0), this.pos += 4, this.vr = this.datav.getUint32(this.pos, !0), this.pos += 4, this.colors = this.datav.getUint32(this.pos, !0), this.pos += 4, this.importantColors = this.datav.getUint32(this.pos, !0), this.pos += 4, this.bitPP === 16 && this.is_with_alpha && (this.bitPP = 15), this.bitPP < 15) {
    var e = this.colors === 0 ? 1 << this.bitPP : this.colors;
    this.palette = new Array(e);
    for (var t = 0; t < e; t++) {
      var n = this.datav.getUint8(this.pos++, !0), r = this.datav.getUint8(this.pos++, !0), i = this.datav.getUint8(this.pos++, !0), a = this.datav.getUint8(this.pos++, !0);
      this.palette[t] = { red: i, green: r, blue: n, quad: a };
    }
  }
  this.height < 0 && (this.height *= -1, this.bottom_up = !1);
}, Mr.prototype.parseBGR = function() {
  this.pos = this.offset;
  try {
    var e = "bit" + this.bitPP, t = this.width * this.height * 4;
    this.data = new Uint8Array(t), this[e]();
  } catch (n) {
    Wt.log("bit decode error:" + n);
  }
}, Mr.prototype.bit1 = function() {
  var e, t = Math.ceil(this.width / 8), n = t % 4;
  for (e = this.height - 1; e >= 0; e--) {
    for (var r = this.bottom_up ? e : this.height - 1 - e, i = 0; i < t; i++) for (var a = this.datav.getUint8(this.pos++, !0), s = r * this.width * 4 + 8 * i * 4, o = 0; o < 8 && 8 * i + o < this.width; o++) {
      var u = this.palette[a >> 7 - o & 1];
      this.data[s + 4 * o] = u.blue, this.data[s + 4 * o + 1] = u.green, this.data[s + 4 * o + 2] = u.red, this.data[s + 4 * o + 3] = 255;
    }
    n !== 0 && (this.pos += 4 - n);
  }
}, Mr.prototype.bit4 = function() {
  for (var e = Math.ceil(this.width / 2), t = e % 4, n = this.height - 1; n >= 0; n--) {
    for (var r = this.bottom_up ? n : this.height - 1 - n, i = 0; i < e; i++) {
      var a = this.datav.getUint8(this.pos++, !0), s = r * this.width * 4 + 2 * i * 4, o = a >> 4, u = 15 & a, c = this.palette[o];
      if (this.data[s] = c.blue, this.data[s + 1] = c.green, this.data[s + 2] = c.red, this.data[s + 3] = 255, 2 * i + 1 >= this.width) break;
      c = this.palette[u], this.data[s + 4] = c.blue, this.data[s + 4 + 1] = c.green, this.data[s + 4 + 2] = c.red, this.data[s + 4 + 3] = 255;
    }
    t !== 0 && (this.pos += 4 - t);
  }
}, Mr.prototype.bit8 = function() {
  for (var e = this.width % 4, t = this.height - 1; t >= 0; t--) {
    for (var n = this.bottom_up ? t : this.height - 1 - t, r = 0; r < this.width; r++) {
      var i = this.datav.getUint8(this.pos++, !0), a = n * this.width * 4 + 4 * r;
      if (i < this.palette.length) {
        var s = this.palette[i];
        this.data[a] = s.red, this.data[a + 1] = s.green, this.data[a + 2] = s.blue, this.data[a + 3] = 255;
      } else this.data[a] = 255, this.data[a + 1] = 255, this.data[a + 2] = 255, this.data[a + 3] = 255;
    }
    e !== 0 && (this.pos += 4 - e);
  }
}, Mr.prototype.bit15 = function() {
  for (var e = this.width % 3, t = parseInt("11111", 2), n = this.height - 1; n >= 0; n--) {
    for (var r = this.bottom_up ? n : this.height - 1 - n, i = 0; i < this.width; i++) {
      var a = this.datav.getUint16(this.pos, !0);
      this.pos += 2;
      var s = (a & t) / t * 255 | 0, o = (a >> 5 & t) / t * 255 | 0, u = (a >> 10 & t) / t * 255 | 0, c = a >> 15 ? 255 : 0, f = r * this.width * 4 + 4 * i;
      this.data[f] = u, this.data[f + 1] = o, this.data[f + 2] = s, this.data[f + 3] = c;
    }
    this.pos += e;
  }
}, Mr.prototype.bit16 = function() {
  for (var e = this.width % 3, t = parseInt("11111", 2), n = parseInt("111111", 2), r = this.height - 1; r >= 0; r--) {
    for (var i = this.bottom_up ? r : this.height - 1 - r, a = 0; a < this.width; a++) {
      var s = this.datav.getUint16(this.pos, !0);
      this.pos += 2;
      var o = (s & t) / t * 255 | 0, u = (s >> 5 & n) / n * 255 | 0, c = (s >> 11) / t * 255 | 0, f = i * this.width * 4 + 4 * a;
      this.data[f] = c, this.data[f + 1] = u, this.data[f + 2] = o, this.data[f + 3] = 255;
    }
    this.pos += e;
  }
}, Mr.prototype.bit24 = function() {
  for (var e = this.height - 1; e >= 0; e--) {
    for (var t = this.bottom_up ? e : this.height - 1 - e, n = 0; n < this.width; n++) {
      var r = this.datav.getUint8(this.pos++, !0), i = this.datav.getUint8(this.pos++, !0), a = this.datav.getUint8(this.pos++, !0), s = t * this.width * 4 + 4 * n;
      this.data[s] = a, this.data[s + 1] = i, this.data[s + 2] = r, this.data[s + 3] = 255;
    }
    this.pos += this.width % 4;
  }
}, Mr.prototype.bit32 = function() {
  for (var e = this.height - 1; e >= 0; e--) for (var t = this.bottom_up ? e : this.height - 1 - e, n = 0; n < this.width; n++) {
    var r = this.datav.getUint8(this.pos++, !0), i = this.datav.getUint8(this.pos++, !0), a = this.datav.getUint8(this.pos++, !0), s = this.datav.getUint8(this.pos++, !0), o = t * this.width * 4 + 4 * n;
    this.data[o] = a, this.data[o + 1] = i, this.data[o + 2] = r, this.data[o + 3] = s;
  }
}, Mr.prototype.getData = function() {
  return this.data;
}, /**
 * @license
 * Copyright (c) 2018 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
(function(e) {
  e.processBMP = function(t, n, r, i) {
    var a = new Mr(t, !1), s = a.width, o = a.height, u = { data: a.getData(), width: s, height: o }, c = new _c(100).encode(u, 100);
    return e.processJPEG.call(this, c, n, r, i);
  };
})(et.API), zd.prototype.getData = function() {
  return this.data;
}, /**
 * @license
 * Copyright (c) 2019 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
(function(e) {
  e.processWEBP = function(t, n, r, i) {
    var a = new zd(t), s = a.width, o = a.height, u = { data: a.getData(), width: s, height: o }, c = new _c(100).encode(u, 100);
    return e.processJPEG.call(this, c, n, r, i);
  };
})(et.API), et.API.processRGBA = function(e, t, n) {
  for (var r = e.data, i = r.length, a = new Uint8Array(i / 4 * 3), s = new Uint8Array(i / 4), o = 0, u = 0, c = 0; c < i; c += 4) {
    var f = r[c], p = r[c + 1], E = r[c + 2], d = r[c + 3];
    a[o++] = f, a[o++] = p, a[o++] = E, s[u++] = d;
  }
  var A = this.__addimage__.arrayBufferToBinaryString(a);
  return { alpha: this.__addimage__.arrayBufferToBinaryString(s), data: A, index: t, alias: n, colorSpace: "DeviceRGB", bitsPerComponent: 8, width: e.width, height: e.height };
}, et.API.setLanguage = function(e) {
  return this.internal.languageSettings === void 0 && (this.internal.languageSettings = {}, this.internal.languageSettings.isSubscribed = !1), { af: "Afrikaans", sq: "Albanian", ar: "Arabic (Standard)", "ar-DZ": "Arabic (Algeria)", "ar-BH": "Arabic (Bahrain)", "ar-EG": "Arabic (Egypt)", "ar-IQ": "Arabic (Iraq)", "ar-JO": "Arabic (Jordan)", "ar-KW": "Arabic (Kuwait)", "ar-LB": "Arabic (Lebanon)", "ar-LY": "Arabic (Libya)", "ar-MA": "Arabic (Morocco)", "ar-OM": "Arabic (Oman)", "ar-QA": "Arabic (Qatar)", "ar-SA": "Arabic (Saudi Arabia)", "ar-SY": "Arabic (Syria)", "ar-TN": "Arabic (Tunisia)", "ar-AE": "Arabic (U.A.E.)", "ar-YE": "Arabic (Yemen)", an: "Aragonese", hy: "Armenian", as: "Assamese", ast: "Asturian", az: "Azerbaijani", eu: "Basque", be: "Belarusian", bn: "Bengali", bs: "Bosnian", br: "Breton", bg: "Bulgarian", my: "Burmese", ca: "Catalan", ch: "Chamorro", ce: "Chechen", zh: "Chinese", "zh-HK": "Chinese (Hong Kong)", "zh-CN": "Chinese (PRC)", "zh-SG": "Chinese (Singapore)", "zh-TW": "Chinese (Taiwan)", cv: "Chuvash", co: "Corsican", cr: "Cree", hr: "Croatian", cs: "Czech", da: "Danish", nl: "Dutch (Standard)", "nl-BE": "Dutch (Belgian)", en: "English", "en-AU": "English (Australia)", "en-BZ": "English (Belize)", "en-CA": "English (Canada)", "en-IE": "English (Ireland)", "en-JM": "English (Jamaica)", "en-NZ": "English (New Zealand)", "en-PH": "English (Philippines)", "en-ZA": "English (South Africa)", "en-TT": "English (Trinidad & Tobago)", "en-GB": "English (United Kingdom)", "en-US": "English (United States)", "en-ZW": "English (Zimbabwe)", eo: "Esperanto", et: "Estonian", fo: "Faeroese", fj: "Fijian", fi: "Finnish", fr: "French (Standard)", "fr-BE": "French (Belgium)", "fr-CA": "French (Canada)", "fr-FR": "French (France)", "fr-LU": "French (Luxembourg)", "fr-MC": "French (Monaco)", "fr-CH": "French (Switzerland)", fy: "Frisian", fur: "Friulian", gd: "Gaelic (Scots)", "gd-IE": "Gaelic (Irish)", gl: "Galacian", ka: "Georgian", de: "German (Standard)", "de-AT": "German (Austria)", "de-DE": "German (Germany)", "de-LI": "German (Liechtenstein)", "de-LU": "German (Luxembourg)", "de-CH": "German (Switzerland)", el: "Greek", gu: "Gujurati", ht: "Haitian", he: "Hebrew", hi: "Hindi", hu: "Hungarian", is: "Icelandic", id: "Indonesian", iu: "Inuktitut", ga: "Irish", it: "Italian (Standard)", "it-CH": "Italian (Switzerland)", ja: "Japanese", kn: "Kannada", ks: "Kashmiri", kk: "Kazakh", km: "Khmer", ky: "Kirghiz", tlh: "Klingon", ko: "Korean", "ko-KP": "Korean (North Korea)", "ko-KR": "Korean (South Korea)", la: "Latin", lv: "Latvian", lt: "Lithuanian", lb: "Luxembourgish", mk: "North Macedonia", ms: "Malay", ml: "Malayalam", mt: "Maltese", mi: "Maori", mr: "Marathi", mo: "Moldavian", nv: "Navajo", ng: "Ndonga", ne: "Nepali", no: "Norwegian", nb: "Norwegian (Bokmal)", nn: "Norwegian (Nynorsk)", oc: "Occitan", or: "Oriya", om: "Oromo", fa: "Persian", "fa-IR": "Persian/Iran", pl: "Polish", pt: "Portuguese", "pt-BR": "Portuguese (Brazil)", pa: "Punjabi", "pa-IN": "Punjabi (India)", "pa-PK": "Punjabi (Pakistan)", qu: "Quechua", rm: "Rhaeto-Romanic", ro: "Romanian", "ro-MO": "Romanian (Moldavia)", ru: "Russian", "ru-MO": "Russian (Moldavia)", sz: "Sami (Lappish)", sg: "Sango", sa: "Sanskrit", sc: "Sardinian", sd: "Sindhi", si: "Singhalese", sr: "Serbian", sk: "Slovak", sl: "Slovenian", so: "Somani", sb: "Sorbian", es: "Spanish", "es-AR": "Spanish (Argentina)", "es-BO": "Spanish (Bolivia)", "es-CL": "Spanish (Chile)", "es-CO": "Spanish (Colombia)", "es-CR": "Spanish (Costa Rica)", "es-DO": "Spanish (Dominican Republic)", "es-EC": "Spanish (Ecuador)", "es-SV": "Spanish (El Salvador)", "es-GT": "Spanish (Guatemala)", "es-HN": "Spanish (Honduras)", "es-MX": "Spanish (Mexico)", "es-NI": "Spanish (Nicaragua)", "es-PA": "Spanish (Panama)", "es-PY": "Spanish (Paraguay)", "es-PE": "Spanish (Peru)", "es-PR": "Spanish (Puerto Rico)", "es-ES": "Spanish (Spain)", "es-UY": "Spanish (Uruguay)", "es-VE": "Spanish (Venezuela)", sx: "Sutu", sw: "Swahili", sv: "Swedish", "sv-FI": "Swedish (Finland)", "sv-SV": "Swedish (Sweden)", ta: "Tamil", tt: "Tatar", te: "Teluga", th: "Thai", tig: "Tigre", ts: "Tsonga", tn: "Tswana", tr: "Turkish", tk: "Turkmen", uk: "Ukrainian", hsb: "Upper Sorbian", ur: "Urdu", ve: "Venda", vi: "Vietnamese", vo: "Volapuk", wa: "Walloon", cy: "Welsh", xh: "Xhosa", ji: "Yiddish", zu: "Zulu" }[e] !== void 0 && (this.internal.languageSettings.languageCode = e, this.internal.languageSettings.isSubscribed === !1 && (this.internal.events.subscribe("putCatalog", function() {
    this.internal.write("/Lang (" + this.internal.languageSettings.languageCode + ")");
  }), this.internal.languageSettings.isSubscribed = !0)), this;
}, Ja = et.API, Tu = Ja.getCharWidthsArray = function(e, t) {
  var n, r, i = (t = t || {}).font || this.internal.getFont(), a = t.fontSize || this.internal.getFontSize(), s = t.charSpace || this.internal.getCharSpace(), o = t.widths ? t.widths : i.metadata.Unicode.widths, u = o.fof ? o.fof : 1, c = t.kerning ? t.kerning : i.metadata.Unicode.kerning, f = c.fof ? c.fof : 1, p = t.doKerning !== !1, E = 0, d = e.length, A = 0, v = o[0] || u, C = [];
  for (n = 0; n < d; n++) r = e.charCodeAt(n), typeof i.metadata.widthOfString == "function" ? C.push((i.metadata.widthOfGlyph(i.metadata.characterToGlyph(r)) + s * (1e3 / a) || 0) / 1e3) : (E = p && qt(c[r]) === "object" && !isNaN(parseInt(c[r][A], 10)) ? c[r][A] / f : 0, C.push((o[r] || v) / u + E)), A = r;
  return C;
}, Od = Ja.getStringUnitWidth = function(e, t) {
  var n = (t = t || {}).fontSize || this.internal.getFontSize(), r = t.font || this.internal.getFont(), i = t.charSpace || this.internal.getCharSpace();
  return Ja.processArabic && (e = Ja.processArabic(e)), typeof r.metadata.widthOfString == "function" ? r.metadata.widthOfString(e, n, i) / n : Tu.apply(this, arguments).reduce(function(a, s) {
    return a + s;
  }, 0);
}, Rd = function(e, t, n, r) {
  for (var i = [], a = 0, s = e.length, o = 0; a !== s && o + t[a] < n; ) o += t[a], a++;
  i.push(e.slice(0, a));
  var u = a;
  for (o = 0; a !== s; ) o + t[a] > r && (i.push(e.slice(u, a)), o = 0, u = a), o += t[a], a++;
  return u !== a && i.push(e.slice(u, a)), i;
}, Dd = function(e, t, n) {
  n || (n = {});
  var r, i, a, s, o, u, c, f = [], p = [f], E = n.textIndent || 0, d = 0, A = 0, v = e.split(" "), C = Tu.apply(this, [" ", n])[0];
  if (u = n.lineIndent === -1 ? v[0].length + 2 : n.lineIndent || 0) {
    var _ = Array(u).join(" "), U = [];
    v.map(function(V) {
      (V = V.split(/\s*\n/)).length > 1 ? U = U.concat(V.map(function(ie, K) {
        return (K && ie.length ? `
` : "") + ie;
      })) : U.push(V[0]);
    }), v = U, u = Od.apply(this, [_, n]);
  }
  for (a = 0, s = v.length; a < s; a++) {
    var B = 0;
    if (r = v[a], u && r[0] == `
` && (r = r.substr(1), B = 1), E + d + (A = (i = Tu.apply(this, [r, n])).reduce(function(V, ie) {
      return V + ie;
    }, 0)) > t || B) {
      if (A > t) {
        for (o = Rd.apply(this, [r, i, t - (E + d), t]), f.push(o.shift()), f = [o.pop()]; o.length; ) p.push([o.shift()]);
        A = i.slice(r.length - (f[0] ? f[0].length : 0)).reduce(function(V, ie) {
          return V + ie;
        }, 0);
      } else f = [r];
      p.push(f), E = A + u, d = C;
    } else f.push(r), E += d + A, d = C;
  }
  return c = u ? function(V, ie) {
    return (ie ? _ : "") + V.join(" ");
  } : function(V) {
    return V.join(" ");
  }, p.map(c);
}, Ja.splitTextToSize = function(e, t, n) {
  var r, i = (n = n || {}).fontSize || this.internal.getFontSize(), a = (function(f) {
    if (f.widths && f.kerning) return { widths: f.widths, kerning: f.kerning };
    var p = this.internal.getFont(f.fontName, f.fontStyle), E = "Unicode";
    return p.metadata[E] ? { widths: p.metadata[E].widths || { 0: 1 }, kerning: p.metadata[E].kerning || {} } : { font: p.metadata, fontSize: this.internal.getFontSize(), charSpace: this.internal.getCharSpace() };
  }).call(this, n);
  r = Array.isArray(e) ? e : String(e).split(/\r?\n/);
  var s = 1 * this.internal.scaleFactor * t / i;
  a.textIndent = n.textIndent ? 1 * n.textIndent * this.internal.scaleFactor / i : 0, a.lineIndent = n.lineIndent;
  var o, u, c = [];
  for (o = 0, u = r.length; o < u; o++) c = c.concat(Dd.apply(this, [r[o], s, a]));
  return c;
}, (function(e) {
  e.__fontmetrics__ = e.__fontmetrics__ || {};
  for (var t = "0123456789abcdef", n = "klmnopqrstuvwxyz", r = {}, i = {}, a = 0; a < 16; a++) r[n[a]] = t[a], i[t[a]] = n[a];
  var s = function(E) {
    return "0x" + parseInt(E, 10).toString(16);
  }, o = e.__fontmetrics__.compress = function(E) {
    var d, A, v, C, _ = ["{"];
    for (var U in E) {
      if (d = E[U], isNaN(parseInt(U, 10)) ? A = "'" + U + "'" : (U = parseInt(U, 10), A = (A = s(U).slice(2)).slice(0, -1) + i[A.slice(-1)]), typeof d == "number") d < 0 ? (v = s(d).slice(3), C = "-") : (v = s(d).slice(2), C = ""), v = C + v.slice(0, -1) + i[v.slice(-1)];
      else {
        if (qt(d) !== "object") throw new Error("Don't know what to do with value type " + qt(d) + ".");
        v = o(d);
      }
      _.push(A + v);
    }
    return _.push("}"), _.join("");
  }, u = e.__fontmetrics__.uncompress = function(E) {
    if (typeof E != "string") throw new Error("Invalid argument passed to uncompress.");
    for (var d, A, v, C, _ = {}, U = 1, B = _, V = [], ie = "", K = "", fe = E.length - 1, Z = 1; Z < fe; Z += 1) (C = E[Z]) == "'" ? d ? (v = d.join(""), d = void 0) : d = [] : d ? d.push(C) : C == "{" ? (V.push([B, v]), B = {}, v = void 0) : C == "}" ? ((A = V.pop())[0][A[1]] = B, v = void 0, B = A[0]) : C == "-" ? U = -1 : v === void 0 ? r.hasOwnProperty(C) ? (ie += r[C], v = parseInt(ie, 16) * U, U = 1, ie = "") : ie += C : r.hasOwnProperty(C) ? (K += r[C], B[v] = parseInt(K, 16) * U, U = 1, v = void 0, K = "") : K += C;
    return _;
  }, c = { codePages: ["WinAnsiEncoding"], WinAnsiEncoding: u("{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}") }, f = { Unicode: { Courier: c, "Courier-Bold": c, "Courier-BoldOblique": c, "Courier-Oblique": c, Helvetica: c, "Helvetica-Bold": c, "Helvetica-BoldOblique": c, "Helvetica-Oblique": c, "Times-Roman": c, "Times-Bold": c, "Times-BoldItalic": c, "Times-Italic": c } }, p = { Unicode: { "Courier-Oblique": u("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-BoldItalic": u("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}"), "Helvetica-Bold": u("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), Courier: u("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-BoldOblique": u("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Bold": u("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}"), Symbol: u("{'widths'{k3uaw4r19m3m2k1t2l2l202m2y2n3m2p5n202q6o3k3m2s2l2t2l2v3r2w1t3m3m2y1t2z1wbk2sbl3r'fof'6o3n3m3o3m3p3m3q3m3r3m3s3m3t3m3u1w3v1w3w3r3x3r3y3r3z2wbp3t3l3m5v2l5x2l5z3m2q4yfr3r7v3k7w1o7x3k}'kerning'{'fof'-6o}}"), Helvetica: u("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}"), "Helvetica-BoldOblique": u("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), ZapfDingbats: u("{'widths'{k4u2k1w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-Bold": u("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Italic": u("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}"), "Times-Roman": u("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}"), "Helvetica-Oblique": u("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}") } };
  e.events.push(["addFont", function(E) {
    var d = E.font, A = p.Unicode[d.postScriptName];
    A && (d.metadata.Unicode = {}, d.metadata.Unicode.widths = A.widths, d.metadata.Unicode.kerning = A.kerning);
    var v = f.Unicode[d.postScriptName];
    v && (d.metadata.Unicode.encoding = v, d.encoding = v.codePages[0]);
  }]);
})(et.API), /**
 * @license
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
(function(e) {
  var t = function(n) {
    for (var r = n.length, i = new Uint8Array(r), a = 0; a < r; a++) i[a] = n.charCodeAt(a);
    return i;
  };
  e.API.events.push(["addFont", function(n) {
    var r = void 0, i = n.font, a = n.instance;
    if (!i.isStandardFont) {
      if (a === void 0) throw new Error("Font does not exist in vFS, import fonts or remove declaration doc.addFont('" + i.postScriptName + "').");
      if (typeof (r = a.existsFileInVFS(i.postScriptName) === !1 ? a.loadFile(i.postScriptName) : a.getFileFromVFS(i.postScriptName)) != "string") throw new Error("Font is not stored as string-data in vFS, import fonts or remove declaration doc.addFont('" + i.postScriptName + "').");
      (function(s, o) {
        o = /^\x00\x01\x00\x00/.test(o) ? t(o) : t(Nu(o)), s.metadata = e.API.TTFFont.open(o), s.metadata.Unicode = s.metadata.Unicode || { encoding: {}, kerning: {}, widths: [] }, s.metadata.glyIdsUsed = [0];
      })(i, r);
    }
  }]);
})(et), et.API.addSvgAsImage = function(e, t, n, r, i, a, s, o) {
  if (isNaN(t) || isNaN(n)) throw Wt.error("jsPDF.addSvgAsImage: Invalid coordinates", arguments), new Error("Invalid coordinates passed to jsPDF.addSvgAsImage");
  if (isNaN(r) || isNaN(i)) throw Wt.error("jsPDF.addSvgAsImage: Invalid measurements", arguments), new Error("Invalid measurements (width and/or height) passed to jsPDF.addSvgAsImage");
  var u = document.createElement("canvas");
  u.width = r, u.height = i;
  var c = u.getContext("2d");
  c.fillStyle = "#fff", c.fillRect(0, 0, u.width, u.height);
  var f = { ignoreMouse: !0, ignoreAnimation: !0, ignoreDimensions: !0 }, p = this;
  return (ct.canvg ? Promise.resolve(ct.canvg) : import("./index.es-BX0Z1NAz.js")).catch(function(E) {
    return Promise.reject(new Error("Could not load canvg: " + E));
  }).then(function(E) {
    return E.default ? E.default : E;
  }).then(function(E) {
    return E.fromString(c, e, f);
  }, function() {
    return Promise.reject(new Error("Could not load canvg."));
  }).then(function(E) {
    return E.render(f);
  }).then(function() {
    p.addImage(u.toDataURL("image/jpeg", 1), t, n, r, i, s, o);
  });
}, et.API.putTotalPages = function(e) {
  var t, n = 0;
  parseInt(this.internal.getFont().id.substr(1), 10) < 15 ? (t = new RegExp(e, "g"), n = this.internal.getNumberOfPages()) : (t = new RegExp(this.pdfEscape16(e, this.internal.getFont()), "g"), n = this.pdfEscape16(this.internal.getNumberOfPages() + "", this.internal.getFont()));
  for (var r = 1; r <= this.internal.getNumberOfPages(); r++) for (var i = 0; i < this.internal.pages[r].length; i++) this.internal.pages[r][i] = this.internal.pages[r][i].replace(t, n);
  return this;
}, et.API.viewerPreferences = function(e, t) {
  var n;
  e = e || {}, t = t || !1;
  var r, i, a, s = { HideToolbar: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, HideMenubar: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, HideWindowUI: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, FitWindow: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, CenterWindow: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, DisplayDocTitle: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.4 }, NonFullScreenPageMode: { defaultValue: "UseNone", value: "UseNone", type: "name", explicitSet: !1, valueSet: ["UseNone", "UseOutlines", "UseThumbs", "UseOC"], pdfVersion: 1.3 }, Direction: { defaultValue: "L2R", value: "L2R", type: "name", explicitSet: !1, valueSet: ["L2R", "R2L"], pdfVersion: 1.3 }, ViewArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, ViewClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintScaling: { defaultValue: "AppDefault", value: "AppDefault", type: "name", explicitSet: !1, valueSet: ["AppDefault", "None"], pdfVersion: 1.6 }, Duplex: { defaultValue: "", value: "none", type: "name", explicitSet: !1, valueSet: ["Simplex", "DuplexFlipShortEdge", "DuplexFlipLongEdge", "none"], pdfVersion: 1.7 }, PickTrayByPDFSize: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.7 }, PrintPageRange: { defaultValue: "", value: "", type: "array", explicitSet: !1, valueSet: null, pdfVersion: 1.7 }, NumCopies: { defaultValue: 1, value: 1, type: "integer", explicitSet: !1, valueSet: null, pdfVersion: 1.7 } }, o = Object.keys(s), u = [], c = 0, f = 0, p = 0;
  function E(A, v) {
    var C, _ = !1;
    for (C = 0; C < A.length; C += 1) A[C] === v && (_ = !0);
    return _;
  }
  if (this.internal.viewerpreferences === void 0 && (this.internal.viewerpreferences = {}, this.internal.viewerpreferences.configuration = JSON.parse(JSON.stringify(s)), this.internal.viewerpreferences.isSubscribed = !1), n = this.internal.viewerpreferences.configuration, e === "reset" || t === !0) {
    var d = o.length;
    for (p = 0; p < d; p += 1) n[o[p]].value = n[o[p]].defaultValue, n[o[p]].explicitSet = !1;
  }
  if (qt(e) === "object") {
    for (i in e) if (a = e[i], E(o, i) && a !== void 0) {
      if (n[i].type === "boolean" && typeof a == "boolean") n[i].value = a;
      else if (n[i].type === "name" && E(n[i].valueSet, a)) n[i].value = a;
      else if (n[i].type === "integer" && Number.isInteger(a)) n[i].value = a;
      else if (n[i].type === "array") {
        for (c = 0; c < a.length; c += 1) if (r = !0, a[c].length === 1 && typeof a[c][0] == "number") u.push(String(a[c] - 1));
        else if (a[c].length > 1) {
          for (f = 0; f < a[c].length; f += 1) typeof a[c][f] != "number" && (r = !1);
          r === !0 && u.push([a[c][0] - 1, a[c][1] - 1].join(" "));
        }
        n[i].value = "[" + u.join(" ") + "]";
      } else n[i].value = n[i].defaultValue;
      n[i].explicitSet = !0;
    }
  }
  return this.internal.viewerpreferences.isSubscribed === !1 && (this.internal.events.subscribe("putCatalog", function() {
    var A, v = [];
    for (A in n) n[A].explicitSet === !0 && (n[A].type === "name" ? v.push("/" + A + " /" + n[A].value) : v.push("/" + A + " " + n[A].value));
    v.length !== 0 && this.internal.write(`/ViewerPreferences
<<
` + v.join(`
`) + `
>>`);
  }), this.internal.viewerpreferences.isSubscribed = !0), this.internal.viewerpreferences.configuration = n, this;
}, /** ====================================================================
 * @license
 * jsPDF XMP metadata plugin
 * Copyright (c) 2016 Jussi Utunen, u-jussi@suomi24.fi
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
(function(e) {
  var t = function() {
    var r = '<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><rdf:Description rdf:about="" xmlns:jspdf="' + this.internal.__metadata__.namespaceuri + '"><jspdf:metadata>', i = unescape(encodeURIComponent('<x:xmpmeta xmlns:x="adobe:ns:meta/">')), a = unescape(encodeURIComponent(r)), s = unescape(encodeURIComponent(this.internal.__metadata__.metadata)), o = unescape(encodeURIComponent("</jspdf:metadata></rdf:Description></rdf:RDF>")), u = unescape(encodeURIComponent("</x:xmpmeta>")), c = a.length + s.length + o.length + i.length + u.length;
    this.internal.__metadata__.metadata_object_number = this.internal.newObject(), this.internal.write("<< /Type /Metadata /Subtype /XML /Length " + c + " >>"), this.internal.write("stream"), this.internal.write(i + a + s + o + u), this.internal.write("endstream"), this.internal.write("endobj");
  }, n = function() {
    this.internal.__metadata__.metadata_object_number && this.internal.write("/Metadata " + this.internal.__metadata__.metadata_object_number + " 0 R");
  };
  e.addMetadata = function(r, i) {
    return this.internal.__metadata__ === void 0 && (this.internal.__metadata__ = { metadata: r, namespaceuri: i || "http://jspdf.default.namespaceuri/" }, this.internal.events.subscribe("putCatalog", n), this.internal.events.subscribe("postPutResources", t)), this;
  };
})(et.API), (function(e) {
  var t = e.API, n = t.pdfEscape16 = function(a, s) {
    for (var o, u = s.metadata.Unicode.widths, c = ["", "0", "00", "000", "0000"], f = [""], p = 0, E = a.length; p < E; ++p) {
      if (o = s.metadata.characterToGlyph(a.charCodeAt(p)), s.metadata.glyIdsUsed.push(o), s.metadata.toUnicode[o] = a.charCodeAt(p), u.indexOf(o) == -1 && (u.push(o), u.push([parseInt(s.metadata.widthOfGlyph(o), 10)])), o == "0") return f.join("");
      o = o.toString(16), f.push(c[4 - o.length], o);
    }
    return f.join("");
  }, r = function(a) {
    var s, o, u, c, f, p, E;
    for (f = `/CIDInit /ProcSet findresource begin
12 dict begin
begincmap
/CIDSystemInfo <<
  /Registry (Adobe)
  /Ordering (UCS)
  /Supplement 0
>> def
/CMapName /Adobe-Identity-UCS def
/CMapType 2 def
1 begincodespacerange
<0000><ffff>
endcodespacerange`, u = [], p = 0, E = (o = Object.keys(a).sort(function(d, A) {
      return d - A;
    })).length; p < E; p++) s = o[p], u.length >= 100 && (f += `
` + u.length + ` beginbfchar
` + u.join(`
`) + `
endbfchar`, u = []), a[s] !== void 0 && a[s] !== null && typeof a[s].toString == "function" && (c = ("0000" + a[s].toString(16)).slice(-4), s = ("0000" + (+s).toString(16)).slice(-4), u.push("<" + s + "><" + c + ">"));
    return u.length && (f += `
` + u.length + ` beginbfchar
` + u.join(`
`) + `
endbfchar
`), f + `endcmap
CMapName currentdict /CMap defineresource pop
end
end`;
  };
  t.events.push(["putFont", function(a) {
    (function(s) {
      var o = s.font, u = s.out, c = s.newObject, f = s.putStream;
      if (o.metadata instanceof e.API.TTFFont && o.encoding === "Identity-H") {
        for (var p = o.metadata.Unicode.widths, E = o.metadata.subset.encode(o.metadata.glyIdsUsed, 1), d = "", A = 0; A < E.length; A++) d += String.fromCharCode(E[A]);
        var v = c();
        f({ data: d, addLength1: !0, objectId: v }), u("endobj");
        var C = c();
        f({ data: r(o.metadata.toUnicode), addLength1: !0, objectId: C }), u("endobj");
        var _ = c();
        u("<<"), u("/Type /FontDescriptor"), u("/FontName /" + ts(o.fontName)), u("/FontFile2 " + v + " 0 R"), u("/FontBBox " + e.API.PDFObject.convert(o.metadata.bbox)), u("/Flags " + o.metadata.flags), u("/StemV " + o.metadata.stemV), u("/ItalicAngle " + o.metadata.italicAngle), u("/Ascent " + o.metadata.ascender), u("/Descent " + o.metadata.decender), u("/CapHeight " + o.metadata.capHeight), u(">>"), u("endobj");
        var U = c();
        u("<<"), u("/Type /Font"), u("/BaseFont /" + ts(o.fontName)), u("/FontDescriptor " + _ + " 0 R"), u("/W " + e.API.PDFObject.convert(p)), u("/CIDToGIDMap /Identity"), u("/DW 1000"), u("/Subtype /CIDFontType2"), u("/CIDSystemInfo"), u("<<"), u("/Supplement 0"), u("/Registry (Adobe)"), u("/Ordering (" + o.encoding + ")"), u(">>"), u(">>"), u("endobj"), o.objectNumber = c(), u("<<"), u("/Type /Font"), u("/Subtype /Type0"), u("/ToUnicode " + C + " 0 R"), u("/BaseFont /" + ts(o.fontName)), u("/Encoding /" + o.encoding), u("/DescendantFonts [" + U + " 0 R]"), u(">>"), u("endobj"), o.isAlreadyPutted = !0;
      }
    })(a);
  }]), t.events.push(["putFont", function(a) {
    (function(s) {
      var o = s.font, u = s.out, c = s.newObject, f = s.putStream;
      if (o.metadata instanceof e.API.TTFFont && o.encoding === "WinAnsiEncoding") {
        for (var p = o.metadata.rawData, E = "", d = 0; d < p.length; d++) E += String.fromCharCode(p[d]);
        var A = c();
        f({ data: E, addLength1: !0, objectId: A }), u("endobj");
        var v = c();
        f({ data: r(o.metadata.toUnicode), addLength1: !0, objectId: v }), u("endobj");
        var C = c();
        u("<<"), u("/Descent " + o.metadata.decender), u("/CapHeight " + o.metadata.capHeight), u("/StemV " + o.metadata.stemV), u("/Type /FontDescriptor"), u("/FontFile2 " + A + " 0 R"), u("/Flags 96"), u("/FontBBox " + e.API.PDFObject.convert(o.metadata.bbox)), u("/FontName /" + ts(o.fontName)), u("/ItalicAngle " + o.metadata.italicAngle), u("/Ascent " + o.metadata.ascender), u(">>"), u("endobj"), o.objectNumber = c();
        for (var _ = 0; _ < o.metadata.hmtx.widths.length; _++) o.metadata.hmtx.widths[_] = parseInt(o.metadata.hmtx.widths[_] * (1e3 / o.metadata.head.unitsPerEm));
        u("<</Subtype/TrueType/Type/Font/ToUnicode " + v + " 0 R/BaseFont/" + ts(o.fontName) + "/FontDescriptor " + C + " 0 R/Encoding/" + o.encoding + " /FirstChar 29 /LastChar 255 /Widths " + e.API.PDFObject.convert(o.metadata.hmtx.widths) + ">>"), u("endobj"), o.isAlreadyPutted = !0;
      }
    })(a);
  }]);
  var i = function(a) {
    var s, o = a.text || "", u = a.x, c = a.y, f = a.options || {}, p = a.mutex || {}, E = p.pdfEscape, d = p.activeFontKey, A = p.fonts, v = d, C = "", _ = 0, U = "", B = A[v].encoding;
    if (A[v].encoding !== "Identity-H") return { text: o, x: u, y: c, options: f, mutex: p };
    for (U = o, v = d, Array.isArray(o) && (U = o[0]), _ = 0; _ < U.length; _ += 1) A[v].metadata.hasOwnProperty("cmap") && (s = A[v].metadata.cmap.unicode.codeMap[U[_].charCodeAt(0)]), s || U[_].charCodeAt(0) < 256 && A[v].metadata.hasOwnProperty("Unicode") ? C += U[_] : C += "";
    var V = "";
    return parseInt(v.slice(1)) < 14 || B === "WinAnsiEncoding" ? V = E(C, v).split("").map(function(ie) {
      return ie.charCodeAt(0).toString(16);
    }).join("") : B === "Identity-H" && (V = n(C, A[v])), p.isHex = !0, { text: V, x: u, y: c, options: f, mutex: p };
  };
  t.events.push(["postProcessText", function(a) {
    var s = a.text || "", o = [], u = { text: s, x: a.x, y: a.y, options: a.options, mutex: a.mutex };
    if (Array.isArray(s)) {
      var c = 0;
      for (c = 0; c < s.length; c += 1) Array.isArray(s[c]) && s[c].length === 3 ? o.push([i(Object.assign({}, u, { text: s[c][0] })).text, s[c][1], s[c][2]]) : o.push(i(Object.assign({}, u, { text: s[c] })).text);
      a.text = o;
    } else a.text = i(Object.assign({}, u, { text: s })).text;
  }]);
})(et), /**
 * @license
 * jsPDF virtual FileSystem functionality
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
(function(e) {
  var t = function() {
    return this.internal.vFS === void 0 && (this.internal.vFS = {}), !0;
  };
  e.existsFileInVFS = function(n) {
    return t.call(this), this.internal.vFS[n] !== void 0;
  }, e.addFileToVFS = function(n, r) {
    return t.call(this), this.internal.vFS[n] = r, this;
  }, e.getFileFromVFS = function(n) {
    return t.call(this), this.internal.vFS[n] !== void 0 ? this.internal.vFS[n] : null;
  };
})(et.API), /**
 * @license
 * Unicode Bidi Engine based on the work of Alex Shensis (@asthensis)
 * MIT License
 */
(function(e) {
  e.__bidiEngine__ = e.prototype.__bidiEngine__ = function(r) {
    var i, a, s, o, u, c, f, p = t, E = [[0, 3, 0, 1, 0, 0, 0], [0, 3, 0, 1, 2, 2, 0], [0, 3, 0, 17, 2, 0, 1], [0, 3, 5, 5, 4, 1, 0], [0, 3, 21, 21, 4, 0, 1], [0, 3, 5, 5, 4, 2, 0]], d = [[2, 0, 1, 1, 0, 1, 0], [2, 0, 1, 1, 0, 2, 0], [2, 0, 2, 1, 3, 2, 0], [2, 0, 2, 33, 3, 1, 1]], A = { L: 0, R: 1, EN: 2, AN: 3, N: 4, B: 5, S: 6 }, v = { 0: 0, 5: 1, 6: 2, 7: 3, 32: 4, 251: 5, 254: 6, 255: 7 }, C = ["(", ")", "(", "<", ">", "<", "[", "]", "[", "{", "}", "{", "Â«", "Â»", "Â«", "â€¹", "â€º", "â€¹", "â…", "â†", "â…", "â½", "â¾", "â½", "â‚", "â‚", "â‚", "â‰¤", "â‰¥", "â‰¤", "âŒ©", "âŒª", "âŒ©", "ï¹™", "ï¹š", "ï¹™", "ï¹›", "ï¹œ", "ï¹›", "ï¹", "ï¹", "ï¹", "ï¹¤", "ï¹¥", "ï¹¤"], _ = new RegExp(/^([1-4|9]|1[0-9]|2[0-9]|3[0168]|4[04589]|5[012]|7[78]|159|16[0-9]|17[0-2]|21[569]|22[03489]|250)$/), U = !1, B = 0;
    this.__bidiEngine__ = {};
    var V = function(N) {
      var I = N.charCodeAt(), $ = I >> 8, Y = v[$];
      return Y !== void 0 ? p[256 * Y + (255 & I)] : $ === 252 || $ === 253 ? "AL" : _.test($) ? "L" : $ === 8 ? "R" : "N";
    }, ie = function(N) {
      for (var I, $ = 0; $ < N.length; $++) {
        if ((I = V(N.charAt($))) === "L") return !1;
        if (I === "R") return !0;
      }
      return !1;
    }, K = function(N, I, $, Y) {
      var J, ue, me, se, Ee = I[Y];
      switch (Ee) {
        case "L":
        case "R":
        case "LRE":
        case "RLE":
        case "LRO":
        case "RLO":
        case "PDF":
          U = !1;
          break;
        case "N":
        case "AN":
          break;
        case "EN":
          U && (Ee = "AN");
          break;
        case "AL":
          U = !0, Ee = "R";
          break;
        case "WS":
        case "BN":
          Ee = "N";
          break;
        case "CS":
          Y < 1 || Y + 1 >= I.length || (J = $[Y - 1]) !== "EN" && J !== "AN" || (ue = I[Y + 1]) !== "EN" && ue !== "AN" ? Ee = "N" : U && (ue = "AN"), Ee = ue === J ? ue : "N";
          break;
        case "ES":
          Ee = (J = Y > 0 ? $[Y - 1] : "B") === "EN" && Y + 1 < I.length && I[Y + 1] === "EN" ? "EN" : "N";
          break;
        case "ET":
          if (Y > 0 && $[Y - 1] === "EN") {
            Ee = "EN";
            break;
          }
          if (U) {
            Ee = "N";
            break;
          }
          for (me = Y + 1, se = I.length; me < se && I[me] === "ET"; ) me++;
          Ee = me < se && I[me] === "EN" ? "EN" : "N";
          break;
        case "NSM":
          if (s && !o) {
            for (se = I.length, me = Y + 1; me < se && I[me] === "NSM"; ) me++;
            if (me < se) {
              var M = N[Y], xe = M >= 1425 && M <= 2303 || M === 64286;
              if (J = I[me], xe && (J === "R" || J === "AL")) {
                Ee = "R";
                break;
              }
            }
          }
          Ee = Y < 1 || (J = I[Y - 1]) === "B" ? "N" : $[Y - 1];
          break;
        case "B":
          U = !1, i = !0, Ee = B;
          break;
        case "S":
          a = !0, Ee = "N";
      }
      return Ee;
    }, fe = function(N, I, $) {
      var Y = N.split("");
      return $ && Z(Y, $, { hiLevel: B }), Y.reverse(), I && I.reverse(), Y.join("");
    }, Z = function(N, I, $) {
      var Y, J, ue, me, se, Ee = -1, M = N.length, xe = 0, L = [], T = B ? d : E, G = [];
      for (U = !1, i = !1, a = !1, J = 0; J < M; J++) G[J] = V(N[J]);
      for (ue = 0; ue < M; ue++) {
        if (se = xe, L[ue] = K(N, G, L, ue), Y = 240 & (xe = T[se][A[L[ue]]]), xe &= 15, I[ue] = me = T[xe][5], Y > 0) if (Y === 16) {
          for (J = Ee; J < ue; J++) I[J] = 1;
          Ee = -1;
        } else Ee = -1;
        if (T[xe][6]) Ee === -1 && (Ee = ue);
        else if (Ee > -1) {
          for (J = Ee; J < ue; J++) I[J] = me;
          Ee = -1;
        }
        G[ue] === "B" && (I[ue] = 0), $.hiLevel |= me;
      }
      a && (function(ee, te, le) {
        for (var ge = 0; ge < le; ge++) if (ee[ge] === "S") {
          te[ge] = B;
          for (var be = ge - 1; be >= 0 && ee[be] === "WS"; be--) te[be] = B;
        }
      })(G, I, M);
    }, z = function(N, I, $, Y, J) {
      if (!(J.hiLevel < N)) {
        if (N === 1 && B === 1 && !i) return I.reverse(), void ($ && $.reverse());
        for (var ue, me, se, Ee, M = I.length, xe = 0; xe < M; ) {
          if (Y[xe] >= N) {
            for (se = xe + 1; se < M && Y[se] >= N; ) se++;
            for (Ee = xe, me = se - 1; Ee < me; Ee++, me--) ue = I[Ee], I[Ee] = I[me], I[me] = ue, $ && (ue = $[Ee], $[Ee] = $[me], $[me] = ue);
            xe = se;
          }
          xe++;
        }
      }
    }, D = function(N, I, $) {
      var Y = N.split(""), J = { hiLevel: B };
      return $ || ($ = []), Z(Y, $, J), (function(ue, me, se) {
        if (se.hiLevel !== 0 && f) for (var Ee, M = 0; M < ue.length; M++) me[M] === 1 && (Ee = C.indexOf(ue[M])) >= 0 && (ue[M] = C[Ee + 1]);
      })(Y, $, J), z(2, Y, I, $, J), z(1, Y, I, $, J), Y.join("");
    };
    return this.__bidiEngine__.doBidiReorder = function(N, I, $) {
      if ((function(J, ue) {
        if (ue) for (var me = 0; me < J.length; me++) ue[me] = me;
        o === void 0 && (o = ie(J)), c === void 0 && (c = ie(J));
      })(N, I), s || !u || c) if (s && u && o ^ c) B = o ? 1 : 0, N = fe(N, I, $);
      else if (!s && u && c) B = o ? 1 : 0, N = D(N, I, $), N = fe(N, I);
      else if (!s || o || u || c) {
        if (s && !u && o ^ c) N = fe(N, I), o ? (B = 0, N = D(N, I, $)) : (B = 1, N = D(N, I, $), N = fe(N, I));
        else if (s && o && !u && c) B = 1, N = D(N, I, $), N = fe(N, I);
        else if (!s && !u && o ^ c) {
          var Y = f;
          o ? (B = 1, N = D(N, I, $), B = 0, f = !1, N = D(N, I, $), f = Y) : (B = 0, N = D(N, I, $), N = fe(N, I), B = 1, f = !1, N = D(N, I, $), f = Y, N = fe(N, I));
        }
      } else B = 0, N = D(N, I, $);
      else B = o ? 1 : 0, N = D(N, I, $);
      return N;
    }, this.__bidiEngine__.setOptions = function(N) {
      N && (s = N.isInputVisual, u = N.isOutputVisual, o = N.isInputRtl, c = N.isOutputRtl, f = N.isSymmetricSwapping);
    }, this.__bidiEngine__.setOptions(r), this.__bidiEngine__;
  };
  var t = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "N", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "L", "N", "N", "BN", "N", "N", "ET", "ET", "EN", "EN", "N", "L", "N", "N", "N", "EN", "L", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "N", "N", "N", "N", "N", "ET", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "NSM", "R", "NSM", "NSM", "R", "NSM", "NSM", "R", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AN", "AN", "AN", "AN", "AN", "AN", "N", "N", "AL", "ET", "ET", "AL", "CS", "AL", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "N", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "R", "N", "N", "N", "N", "R", "N", "N", "N", "N", "N", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "BN", "BN", "BN", "L", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "B", "LRE", "RLE", "PDF", "LRO", "RLO", "CS", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "BN", "BN", "BN", "BN", "BN", "N", "LRI", "RLI", "FSI", "PDI", "BN", "BN", "BN", "BN", "BN", "BN", "EN", "L", "N", "N", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "L", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "R", "NSM", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "ES", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "R", "R", "R", "R", "R", "N", "R", "N", "R", "R", "N", "R", "R", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "CS", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "ET", "N", "N", "ES", "ES", "N", "N", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "BN", "N", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "N", "N", "N", "ET", "ET", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N"], n = new e.__bidiEngine__({ isInputVisual: !0 });
  e.API.events.push(["postProcessText", function(r) {
    var i = r.text;
    r.x, r.y;
    var a = r.options || {};
    r.mutex, a.lang;
    var s = [];
    if (a.isInputVisual = typeof a.isInputVisual != "boolean" || a.isInputVisual, n.setOptions(a), Object.prototype.toString.call(i) === "[object Array]") {
      var o = 0;
      for (s = [], o = 0; o < i.length; o += 1) Object.prototype.toString.call(i[o]) === "[object Array]" ? s.push([n.doBidiReorder(i[o][0]), i[o][1], i[o][2]]) : s.push([n.doBidiReorder(i[o])]);
      r.text = s;
    } else r.text = n.doBidiReorder(i);
    n.setOptions({ isInputVisual: !0 });
  }]);
})(et), et.API.TTFFont = (function() {
  function e(t) {
    var n;
    if (this.rawData = t, n = this.contents = new Zi(t), this.contents.pos = 4, n.readString(4) === "ttcf") throw new Error("TTCF not supported.");
    n.pos = 0, this.parse(), this.subset = new N8(this), this.registerTTF();
  }
  return e.open = function(t) {
    return new e(t);
  }, e.prototype.parse = function() {
    return this.directory = new f8(this.contents), this.head = new d8(this), this.name = new E8(this), this.cmap = new Mp(this), this.toUnicode = {}, this.hhea = new p8(this), this.maxp = new y8(this), this.hmtx = new T8(this), this.post = new g8(this), this.os2 = new m8(this), this.loca = new x8(this), this.glyf = new _8(this), this.ascender = this.os2.exists && this.os2.ascender || this.hhea.ascender, this.decender = this.os2.exists && this.os2.decender || this.hhea.decender, this.lineGap = this.os2.exists && this.os2.lineGap || this.hhea.lineGap, this.bbox = [this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax];
  }, e.prototype.registerTTF = function() {
    var t, n, r, i, a;
    if (this.scaleFactor = 1e3 / this.head.unitsPerEm, this.bbox = (function() {
      var s, o, u, c;
      for (c = [], s = 0, o = (u = this.bbox).length; s < o; s++) t = u[s], c.push(Math.round(t * this.scaleFactor));
      return c;
    }).call(this), this.stemV = 0, this.post.exists ? (r = 255 & (i = this.post.italic_angle), 32768 & (n = i >> 16) && (n = -(1 + (65535 ^ n))), this.italicAngle = +(n + "." + r)) : this.italicAngle = 0, this.ascender = Math.round(this.ascender * this.scaleFactor), this.decender = Math.round(this.decender * this.scaleFactor), this.lineGap = Math.round(this.lineGap * this.scaleFactor), this.capHeight = this.os2.exists && this.os2.capHeight || this.ascender, this.xHeight = this.os2.exists && this.os2.xHeight || 0, this.familyClass = (this.os2.exists && this.os2.familyClass || 0) >> 8, this.isSerif = (a = this.familyClass) === 1 || a === 2 || a === 3 || a === 4 || a === 5 || a === 7, this.isScript = this.familyClass === 10, this.flags = 0, this.post.isFixedPitch && (this.flags |= 1), this.isSerif && (this.flags |= 2), this.isScript && (this.flags |= 8), this.italicAngle !== 0 && (this.flags |= 64), this.flags |= 32, !this.cmap.unicode) throw new Error("No unicode cmap for font");
  }, e.prototype.characterToGlyph = function(t) {
    var n;
    return ((n = this.cmap.unicode) != null ? n.codeMap[t] : void 0) || 0;
  }, e.prototype.widthOfGlyph = function(t) {
    var n;
    return n = 1e3 / this.head.unitsPerEm, this.hmtx.forGlyph(t).advance * n;
  }, e.prototype.widthOfString = function(t, n, r) {
    var i, a, s, o;
    for (s = 0, a = 0, o = (t = "" + t).length; 0 <= o ? a < o : a > o; a = 0 <= o ? ++a : --a) i = t.charCodeAt(a), s += this.widthOfGlyph(this.characterToGlyph(i)) + r * (1e3 / n) || 0;
    return s * (n / 1e3);
  }, e.prototype.lineHeight = function(t, n) {
    var r;
    return n == null && (n = !1), r = n ? this.lineGap : 0, (this.ascender + r - this.decender) / 1e3 * t;
  }, e;
})();
var jr, Zi = (function() {
  function e(t) {
    this.data = t ?? [], this.pos = 0, this.length = this.data.length;
  }
  return e.prototype.readByte = function() {
    return this.data[this.pos++];
  }, e.prototype.writeByte = function(t) {
    return this.data[this.pos++] = t;
  }, e.prototype.readUInt32 = function() {
    return 16777216 * this.readByte() + (this.readByte() << 16) + (this.readByte() << 8) + this.readByte();
  }, e.prototype.writeUInt32 = function(t) {
    return this.writeByte(t >>> 24 & 255), this.writeByte(t >> 16 & 255), this.writeByte(t >> 8 & 255), this.writeByte(255 & t);
  }, e.prototype.readInt32 = function() {
    var t;
    return (t = this.readUInt32()) >= 2147483648 ? t - 4294967296 : t;
  }, e.prototype.writeInt32 = function(t) {
    return t < 0 && (t += 4294967296), this.writeUInt32(t);
  }, e.prototype.readUInt16 = function() {
    return this.readByte() << 8 | this.readByte();
  }, e.prototype.writeUInt16 = function(t) {
    return this.writeByte(t >> 8 & 255), this.writeByte(255 & t);
  }, e.prototype.readInt16 = function() {
    var t;
    return (t = this.readUInt16()) >= 32768 ? t - 65536 : t;
  }, e.prototype.writeInt16 = function(t) {
    return t < 0 && (t += 65536), this.writeUInt16(t);
  }, e.prototype.readString = function(t) {
    var n, r;
    for (r = [], n = 0; 0 <= t ? n < t : n > t; n = 0 <= t ? ++n : --n) r[n] = String.fromCharCode(this.readByte());
    return r.join("");
  }, e.prototype.writeString = function(t) {
    var n, r, i;
    for (i = [], n = 0, r = t.length; 0 <= r ? n < r : n > r; n = 0 <= r ? ++n : --n) i.push(this.writeByte(t.charCodeAt(n)));
    return i;
  }, e.prototype.readShort = function() {
    return this.readInt16();
  }, e.prototype.writeShort = function(t) {
    return this.writeInt16(t);
  }, e.prototype.readLongLong = function() {
    var t, n, r, i, a, s, o, u;
    return t = this.readByte(), n = this.readByte(), r = this.readByte(), i = this.readByte(), a = this.readByte(), s = this.readByte(), o = this.readByte(), u = this.readByte(), 128 & t ? -1 * (72057594037927940 * (255 ^ t) + 281474976710656 * (255 ^ n) + 1099511627776 * (255 ^ r) + 4294967296 * (255 ^ i) + 16777216 * (255 ^ a) + 65536 * (255 ^ s) + 256 * (255 ^ o) + (255 ^ u) + 1) : 72057594037927940 * t + 281474976710656 * n + 1099511627776 * r + 4294967296 * i + 16777216 * a + 65536 * s + 256 * o + u;
  }, e.prototype.writeLongLong = function(t) {
    var n, r;
    return n = Math.floor(t / 4294967296), r = 4294967295 & t, this.writeByte(n >> 24 & 255), this.writeByte(n >> 16 & 255), this.writeByte(n >> 8 & 255), this.writeByte(255 & n), this.writeByte(r >> 24 & 255), this.writeByte(r >> 16 & 255), this.writeByte(r >> 8 & 255), this.writeByte(255 & r);
  }, e.prototype.readInt = function() {
    return this.readInt32();
  }, e.prototype.writeInt = function(t) {
    return this.writeInt32(t);
  }, e.prototype.read = function(t) {
    var n, r;
    for (n = [], r = 0; 0 <= t ? r < t : r > t; r = 0 <= t ? ++r : --r) n.push(this.readByte());
    return n;
  }, e.prototype.write = function(t) {
    var n, r, i, a;
    for (a = [], r = 0, i = t.length; r < i; r++) n = t[r], a.push(this.writeByte(n));
    return a;
  }, e;
})(), f8 = (function() {
  var e;
  function t(n) {
    var r, i, a;
    for (this.scalarType = n.readInt(), this.tableCount = n.readShort(), this.searchRange = n.readShort(), this.entrySelector = n.readShort(), this.rangeShift = n.readShort(), this.tables = {}, i = 0, a = this.tableCount; 0 <= a ? i < a : i > a; i = 0 <= a ? ++i : --i) r = { tag: n.readString(4), checksum: n.readInt(), offset: n.readInt(), length: n.readInt() }, this.tables[r.tag] = r;
  }
  return t.prototype.encode = function(n) {
    var r, i, a, s, o, u, c, f, p, E, d, A, v;
    for (v in d = Object.keys(n).length, u = Math.log(2), p = 16 * Math.floor(Math.log(d) / u), s = Math.floor(p / u), f = 16 * d - p, (i = new Zi()).writeInt(this.scalarType), i.writeShort(d), i.writeShort(p), i.writeShort(s), i.writeShort(f), a = 16 * d, c = i.pos + a, o = null, A = [], n) for (E = n[v], i.writeString(v), i.writeInt(e(E)), i.writeInt(c), i.writeInt(E.length), A = A.concat(E), v === "head" && (o = c), c += E.length; c % 4; ) A.push(0), c++;
    return i.write(A), r = 2981146554 - e(i.data), i.pos = o + 8, i.writeUInt32(r), i.data;
  }, e = function(n) {
    var r, i, a, s;
    for (n = Fp.call(n); n.length % 4; ) n.push(0);
    for (a = new Zi(n), i = 0, r = 0, s = n.length; r < s; r = r += 4) i += a.readUInt32();
    return 4294967295 & i;
  }, t;
})(), h8 = {}.hasOwnProperty, ii = function(e, t) {
  for (var n in t) h8.call(t, n) && (e[n] = t[n]);
  function r() {
    this.constructor = e;
  }
  return r.prototype = t.prototype, e.prototype = new r(), e.__super__ = t.prototype, e;
};
jr = (function() {
  function e(t) {
    var n;
    this.file = t, n = this.file.directory.tables[this.tag], this.exists = !!n, n && (this.offset = n.offset, this.length = n.length, this.parse(this.file.contents));
  }
  return e.prototype.parse = function() {
  }, e.prototype.encode = function() {
  }, e.prototype.raw = function() {
    return this.exists ? (this.file.contents.pos = this.offset, this.file.contents.read(this.length)) : null;
  }, e;
})();
var d8 = (function() {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return ii(e, jr), e.prototype.tag = "head", e.prototype.parse = function(t) {
    return t.pos = this.offset, this.version = t.readInt(), this.revision = t.readInt(), this.checkSumAdjustment = t.readInt(), this.magicNumber = t.readInt(), this.flags = t.readShort(), this.unitsPerEm = t.readShort(), this.created = t.readLongLong(), this.modified = t.readLongLong(), this.xMin = t.readShort(), this.yMin = t.readShort(), this.xMax = t.readShort(), this.yMax = t.readShort(), this.macStyle = t.readShort(), this.lowestRecPPEM = t.readShort(), this.fontDirectionHint = t.readShort(), this.indexToLocFormat = t.readShort(), this.glyphDataFormat = t.readShort();
  }, e.prototype.encode = function(t) {
    var n;
    return (n = new Zi()).writeInt(this.version), n.writeInt(this.revision), n.writeInt(this.checkSumAdjustment), n.writeInt(this.magicNumber), n.writeShort(this.flags), n.writeShort(this.unitsPerEm), n.writeLongLong(this.created), n.writeLongLong(this.modified), n.writeShort(this.xMin), n.writeShort(this.yMin), n.writeShort(this.xMax), n.writeShort(this.yMax), n.writeShort(this.macStyle), n.writeShort(this.lowestRecPPEM), n.writeShort(this.fontDirectionHint), n.writeShort(t), n.writeShort(this.glyphDataFormat), n.data;
  }, e;
})(), Yd = (function() {
  function e(t, n) {
    var r, i, a, s, o, u, c, f, p, E, d, A, v, C, _, U, B;
    switch (this.platformID = t.readUInt16(), this.encodingID = t.readShort(), this.offset = n + t.readInt(), p = t.pos, t.pos = this.offset, this.format = t.readUInt16(), this.length = t.readUInt16(), this.language = t.readUInt16(), this.isUnicode = this.platformID === 3 && this.encodingID === 1 && this.format === 4 || this.platformID === 0 && this.format === 4, this.codeMap = {}, this.format) {
      case 0:
        for (u = 0; u < 256; ++u) this.codeMap[u] = t.readByte();
        break;
      case 4:
        for (d = t.readUInt16(), E = d / 2, t.pos += 6, a = (function() {
          var V, ie;
          for (ie = [], u = V = 0; 0 <= E ? V < E : V > E; u = 0 <= E ? ++V : --V) ie.push(t.readUInt16());
          return ie;
        })(), t.pos += 2, v = (function() {
          var V, ie;
          for (ie = [], u = V = 0; 0 <= E ? V < E : V > E; u = 0 <= E ? ++V : --V) ie.push(t.readUInt16());
          return ie;
        })(), c = (function() {
          var V, ie;
          for (ie = [], u = V = 0; 0 <= E ? V < E : V > E; u = 0 <= E ? ++V : --V) ie.push(t.readUInt16());
          return ie;
        })(), f = (function() {
          var V, ie;
          for (ie = [], u = V = 0; 0 <= E ? V < E : V > E; u = 0 <= E ? ++V : --V) ie.push(t.readUInt16());
          return ie;
        })(), i = (this.length - t.pos + this.offset) / 2, o = (function() {
          var V, ie;
          for (ie = [], u = V = 0; 0 <= i ? V < i : V > i; u = 0 <= i ? ++V : --V) ie.push(t.readUInt16());
          return ie;
        })(), u = _ = 0, B = a.length; _ < B; u = ++_) for (C = a[u], r = U = A = v[u]; A <= C ? U <= C : U >= C; r = A <= C ? ++U : --U) f[u] === 0 ? s = r + c[u] : (s = o[f[u] / 2 + (r - A) - (E - u)] || 0) !== 0 && (s += c[u]), this.codeMap[r] = 65535 & s;
    }
    t.pos = p;
  }
  return e.encode = function(t, n) {
    var r, i, a, s, o, u, c, f, p, E, d, A, v, C, _, U, B, V, ie, K, fe, Z, z, D, N, I, $, Y, J, ue, me, se, Ee, M, xe, L, T, G, ee, te, le, ge, be, Ae, Ie, je;
    switch (Y = new Zi(), s = Object.keys(t).sort(function(He, tt) {
      return He - tt;
    }), n) {
      case "macroman":
        for (v = 0, C = (function() {
          var He = [];
          for (A = 0; A < 256; ++A) He.push(0);
          return He;
        })(), U = { 0: 0 }, a = {}, J = 0, Ee = s.length; J < Ee; J++) U[be = t[i = s[J]]] == null && (U[be] = ++v), a[i] = { old: t[i], new: U[t[i]] }, C[i] = U[t[i]];
        return Y.writeUInt16(1), Y.writeUInt16(0), Y.writeUInt32(12), Y.writeUInt16(0), Y.writeUInt16(262), Y.writeUInt16(0), Y.write(C), { charMap: a, subtable: Y.data, maxGlyphID: v + 1 };
      case "unicode":
        for (I = [], p = [], B = 0, U = {}, r = {}, _ = c = null, ue = 0, M = s.length; ue < M; ue++) U[ie = t[i = s[ue]]] == null && (U[ie] = ++B), r[i] = { old: ie, new: U[ie] }, o = U[ie] - i, _ != null && o === c || (_ && p.push(_), I.push(i), c = o), _ = i;
        for (_ && p.push(_), p.push(65535), I.push(65535), D = 2 * (z = I.length), Z = 2 * Math.pow(Math.log(z) / Math.LN2, 2), E = Math.log(Z / 2) / Math.LN2, fe = 2 * z - Z, u = [], K = [], d = [], A = me = 0, xe = I.length; me < xe; A = ++me) {
          if (N = I[A], f = p[A], N === 65535) {
            u.push(0), K.push(0);
            break;
          }
          if (N - ($ = r[N].new) >= 32768) for (u.push(0), K.push(2 * (d.length + z - A)), i = se = N; N <= f ? se <= f : se >= f; i = N <= f ? ++se : --se) d.push(r[i].new);
          else u.push($ - N), K.push(0);
        }
        for (Y.writeUInt16(3), Y.writeUInt16(1), Y.writeUInt32(12), Y.writeUInt16(4), Y.writeUInt16(16 + 8 * z + 2 * d.length), Y.writeUInt16(0), Y.writeUInt16(D), Y.writeUInt16(Z), Y.writeUInt16(E), Y.writeUInt16(fe), le = 0, L = p.length; le < L; le++) i = p[le], Y.writeUInt16(i);
        for (Y.writeUInt16(0), ge = 0, T = I.length; ge < T; ge++) i = I[ge], Y.writeUInt16(i);
        for (Ae = 0, G = u.length; Ae < G; Ae++) o = u[Ae], Y.writeUInt16(o);
        for (Ie = 0, ee = K.length; Ie < ee; Ie++) V = K[Ie], Y.writeUInt16(V);
        for (je = 0, te = d.length; je < te; je++) v = d[je], Y.writeUInt16(v);
        return { charMap: r, subtable: Y.data, maxGlyphID: B + 1 };
    }
  }, e;
})(), Mp = (function() {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return ii(e, jr), e.prototype.tag = "cmap", e.prototype.parse = function(t) {
    var n, r, i;
    for (t.pos = this.offset, this.version = t.readUInt16(), i = t.readUInt16(), this.tables = [], this.unicode = null, r = 0; 0 <= i ? r < i : r > i; r = 0 <= i ? ++r : --r) n = new Yd(t, this.offset), this.tables.push(n), n.isUnicode && this.unicode == null && (this.unicode = n);
    return !0;
  }, e.encode = function(t, n) {
    var r, i;
    return n == null && (n = "macroman"), r = Yd.encode(t, n), (i = new Zi()).writeUInt16(0), i.writeUInt16(1), r.table = i.data.concat(r.subtable), r;
  }, e;
})(), p8 = (function() {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return ii(e, jr), e.prototype.tag = "hhea", e.prototype.parse = function(t) {
    return t.pos = this.offset, this.version = t.readInt(), this.ascender = t.readShort(), this.decender = t.readShort(), this.lineGap = t.readShort(), this.advanceWidthMax = t.readShort(), this.minLeftSideBearing = t.readShort(), this.minRightSideBearing = t.readShort(), this.xMaxExtent = t.readShort(), this.caretSlopeRise = t.readShort(), this.caretSlopeRun = t.readShort(), this.caretOffset = t.readShort(), t.pos += 8, this.metricDataFormat = t.readShort(), this.numberOfMetrics = t.readUInt16();
  }, e;
})(), m8 = (function() {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return ii(e, jr), e.prototype.tag = "OS/2", e.prototype.parse = function(t) {
    if (t.pos = this.offset, this.version = t.readUInt16(), this.averageCharWidth = t.readShort(), this.weightClass = t.readUInt16(), this.widthClass = t.readUInt16(), this.type = t.readShort(), this.ySubscriptXSize = t.readShort(), this.ySubscriptYSize = t.readShort(), this.ySubscriptXOffset = t.readShort(), this.ySubscriptYOffset = t.readShort(), this.ySuperscriptXSize = t.readShort(), this.ySuperscriptYSize = t.readShort(), this.ySuperscriptXOffset = t.readShort(), this.ySuperscriptYOffset = t.readShort(), this.yStrikeoutSize = t.readShort(), this.yStrikeoutPosition = t.readShort(), this.familyClass = t.readShort(), this.panose = (function() {
      var n, r;
      for (r = [], n = 0; n < 10; ++n) r.push(t.readByte());
      return r;
    })(), this.charRange = (function() {
      var n, r;
      for (r = [], n = 0; n < 4; ++n) r.push(t.readInt());
      return r;
    })(), this.vendorID = t.readString(4), this.selection = t.readShort(), this.firstCharIndex = t.readShort(), this.lastCharIndex = t.readShort(), this.version > 0 && (this.ascent = t.readShort(), this.descent = t.readShort(), this.lineGap = t.readShort(), this.winAscent = t.readShort(), this.winDescent = t.readShort(), this.codePageRange = (function() {
      var n, r;
      for (r = [], n = 0; n < 2; n = ++n) r.push(t.readInt());
      return r;
    })(), this.version > 1)) return this.xHeight = t.readShort(), this.capHeight = t.readShort(), this.defaultChar = t.readShort(), this.breakChar = t.readShort(), this.maxContext = t.readShort();
  }, e;
})(), g8 = (function() {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return ii(e, jr), e.prototype.tag = "post", e.prototype.parse = function(t) {
    var n, r, i;
    switch (t.pos = this.offset, this.format = t.readInt(), this.italicAngle = t.readInt(), this.underlinePosition = t.readShort(), this.underlineThickness = t.readShort(), this.isFixedPitch = t.readInt(), this.minMemType42 = t.readInt(), this.maxMemType42 = t.readInt(), this.minMemType1 = t.readInt(), this.maxMemType1 = t.readInt(), this.format) {
      case 65536:
      case 196608:
        break;
      case 131072:
        var a;
        for (r = t.readUInt16(), this.glyphNameIndex = [], a = 0; 0 <= r ? a < r : a > r; a = 0 <= r ? ++a : --a) this.glyphNameIndex.push(t.readUInt16());
        for (this.names = [], i = []; t.pos < this.offset + this.length; ) n = t.readByte(), i.push(this.names.push(t.readString(n)));
        return i;
      case 151552:
        return r = t.readUInt16(), this.offsets = t.read(r);
      case 262144:
        return this.map = (function() {
          var s, o, u;
          for (u = [], a = s = 0, o = this.file.maxp.numGlyphs; 0 <= o ? s < o : s > o; a = 0 <= o ? ++s : --s) u.push(t.readUInt32());
          return u;
        }).call(this);
    }
  }, e;
})(), b8 = function(e, t) {
  this.raw = e, this.length = e.length, this.platformID = t.platformID, this.encodingID = t.encodingID, this.languageID = t.languageID;
}, E8 = (function() {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return ii(e, jr), e.prototype.tag = "name", e.prototype.parse = function(t) {
    var n, r, i, a, s, o, u, c, f, p, E;
    for (t.pos = this.offset, t.readShort(), n = t.readShort(), o = t.readShort(), r = [], a = 0; 0 <= n ? a < n : a > n; a = 0 <= n ? ++a : --a) r.push({ platformID: t.readShort(), encodingID: t.readShort(), languageID: t.readShort(), nameID: t.readShort(), length: t.readShort(), offset: this.offset + o + t.readShort() });
    for (u = {}, a = f = 0, p = r.length; f < p; a = ++f) i = r[a], t.pos = i.offset, c = t.readString(i.length), s = new b8(c, i), u[E = i.nameID] == null && (u[E] = []), u[i.nameID].push(s);
    this.strings = u, this.copyright = u[0], this.fontFamily = u[1], this.fontSubfamily = u[2], this.uniqueSubfamily = u[3], this.fontName = u[4], this.version = u[5];
    try {
      this.postscriptName = u[6][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    } catch {
      this.postscriptName = u[4][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    }
    return this.trademark = u[7], this.manufacturer = u[8], this.designer = u[9], this.description = u[10], this.vendorUrl = u[11], this.designerUrl = u[12], this.license = u[13], this.licenseUrl = u[14], this.preferredFamily = u[15], this.preferredSubfamily = u[17], this.compatibleFull = u[18], this.sampleText = u[19];
  }, e;
})(), y8 = (function() {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return ii(e, jr), e.prototype.tag = "maxp", e.prototype.parse = function(t) {
    return t.pos = this.offset, this.version = t.readInt(), this.numGlyphs = t.readUInt16(), this.maxPoints = t.readUInt16(), this.maxContours = t.readUInt16(), this.maxCompositePoints = t.readUInt16(), this.maxComponentContours = t.readUInt16(), this.maxZones = t.readUInt16(), this.maxTwilightPoints = t.readUInt16(), this.maxStorage = t.readUInt16(), this.maxFunctionDefs = t.readUInt16(), this.maxInstructionDefs = t.readUInt16(), this.maxStackElements = t.readUInt16(), this.maxSizeOfInstructions = t.readUInt16(), this.maxComponentElements = t.readUInt16(), this.maxComponentDepth = t.readUInt16();
  }, e;
})(), T8 = (function() {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return ii(e, jr), e.prototype.tag = "hmtx", e.prototype.parse = function(t) {
    var n, r, i, a, s, o, u;
    for (t.pos = this.offset, this.metrics = [], n = 0, o = this.file.hhea.numberOfMetrics; 0 <= o ? n < o : n > o; n = 0 <= o ? ++n : --n) this.metrics.push({ advance: t.readUInt16(), lsb: t.readInt16() });
    for (i = this.file.maxp.numGlyphs - this.file.hhea.numberOfMetrics, this.leftSideBearings = (function() {
      var c, f;
      for (f = [], n = c = 0; 0 <= i ? c < i : c > i; n = 0 <= i ? ++c : --c) f.push(t.readInt16());
      return f;
    })(), this.widths = (function() {
      var c, f, p, E;
      for (E = [], c = 0, f = (p = this.metrics).length; c < f; c++) a = p[c], E.push(a.advance);
      return E;
    }).call(this), r = this.widths[this.widths.length - 1], u = [], n = s = 0; 0 <= i ? s < i : s > i; n = 0 <= i ? ++s : --s) u.push(this.widths.push(r));
    return u;
  }, e.prototype.forGlyph = function(t) {
    return t in this.metrics ? this.metrics[t] : { advance: this.metrics[this.metrics.length - 1].advance, lsb: this.leftSideBearings[t - this.metrics.length] };
  }, e;
})(), Fp = [].slice, _8 = (function() {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return ii(e, jr), e.prototype.tag = "glyf", e.prototype.parse = function() {
    return this.cache = {};
  }, e.prototype.glyphFor = function(t) {
    var n, r, i, a, s, o, u, c, f, p;
    return t in this.cache ? this.cache[t] : (a = this.file.loca, n = this.file.contents, r = a.indexOf(t), (i = a.lengthOf(t)) === 0 ? this.cache[t] = null : (n.pos = this.offset + r, s = (o = new Zi(n.read(i))).readShort(), c = o.readShort(), p = o.readShort(), u = o.readShort(), f = o.readShort(), this.cache[t] = s === -1 ? new w8(o, c, p, u, f) : new A8(o, s, c, p, u, f), this.cache[t]));
  }, e.prototype.encode = function(t, n, r) {
    var i, a, s, o, u;
    for (s = [], a = [], o = 0, u = n.length; o < u; o++) i = t[n[o]], a.push(s.length), i && (s = s.concat(i.encode(r)));
    return a.push(s.length), { table: s, offsets: a };
  }, e;
})(), A8 = (function() {
  function e(t, n, r, i, a, s) {
    this.raw = t, this.numberOfContours = n, this.xMin = r, this.yMin = i, this.xMax = a, this.yMax = s, this.compound = !1;
  }
  return e.prototype.encode = function() {
    return this.raw.data;
  }, e;
})(), w8 = (function() {
  function e(t, n, r, i, a) {
    var s, o;
    for (this.raw = t, this.xMin = n, this.yMin = r, this.xMax = i, this.yMax = a, this.compound = !0, this.glyphIDs = [], this.glyphOffsets = [], s = this.raw; o = s.readShort(), this.glyphOffsets.push(s.pos), this.glyphIDs.push(s.readUInt16()), 32 & o; ) s.pos += 1 & o ? 4 : 2, 128 & o ? s.pos += 8 : 64 & o ? s.pos += 4 : 8 & o && (s.pos += 2);
  }
  return e.prototype.encode = function() {
    var t, n, r;
    for (n = new Zi(Fp.call(this.raw.data)), t = 0, r = this.glyphIDs.length; t < r; ++t) n.pos = this.glyphOffsets[t];
    return n.data;
  }, e;
})(), x8 = (function() {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return ii(e, jr), e.prototype.tag = "loca", e.prototype.parse = function(t) {
    var n, r;
    return t.pos = this.offset, n = this.file.head.indexToLocFormat, this.offsets = n === 0 ? (function() {
      var i, a;
      for (a = [], r = 0, i = this.length; r < i; r += 2) a.push(2 * t.readUInt16());
      return a;
    }).call(this) : (function() {
      var i, a;
      for (a = [], r = 0, i = this.length; r < i; r += 4) a.push(t.readUInt32());
      return a;
    }).call(this);
  }, e.prototype.indexOf = function(t) {
    return this.offsets[t];
  }, e.prototype.lengthOf = function(t) {
    return this.offsets[t + 1] - this.offsets[t];
  }, e.prototype.encode = function(t, n) {
    for (var r = new Uint32Array(this.offsets.length), i = 0, a = 0, s = 0; s < r.length; ++s) if (r[s] = i, a < n.length && n[a] == s) {
      ++a, r[s] = i;
      var o = this.offsets[s], u = this.offsets[s + 1] - o;
      u > 0 && (i += u);
    }
    for (var c = new Array(4 * r.length), f = 0; f < r.length; ++f) c[4 * f + 3] = 255 & r[f], c[4 * f + 2] = (65280 & r[f]) >> 8, c[4 * f + 1] = (16711680 & r[f]) >> 16, c[4 * f] = (4278190080 & r[f]) >> 24;
    return c;
  }, e;
})(), N8 = (function() {
  function e(t) {
    this.font = t, this.subset = {}, this.unicodes = {}, this.next = 33;
  }
  return e.prototype.generateCmap = function() {
    var t, n, r, i, a;
    for (n in i = this.font.cmap.tables[0].codeMap, t = {}, a = this.subset) r = a[n], t[n] = i[r];
    return t;
  }, e.prototype.glyphsFor = function(t) {
    var n, r, i, a, s, o, u;
    for (i = {}, s = 0, o = t.length; s < o; s++) i[a = t[s]] = this.font.glyf.glyphFor(a);
    for (a in n = [], i) (r = i[a]) != null && r.compound && n.push.apply(n, r.glyphIDs);
    if (n.length > 0) for (a in u = this.glyphsFor(n)) r = u[a], i[a] = r;
    return i;
  }, e.prototype.encode = function(t, n) {
    var r, i, a, s, o, u, c, f, p, E, d, A, v, C, _;
    for (i in r = Mp.encode(this.generateCmap(), "unicode"), s = this.glyphsFor(t), d = { 0: 0 }, _ = r.charMap) d[(u = _[i]).old] = u.new;
    for (A in E = r.maxGlyphID, s) A in d || (d[A] = E++);
    return f = (function(U) {
      var B, V;
      for (B in V = {}, U) V[U[B]] = B;
      return V;
    })(d), p = Object.keys(f).sort(function(U, B) {
      return U - B;
    }), v = (function() {
      var U, B, V;
      for (V = [], U = 0, B = p.length; U < B; U++) o = p[U], V.push(f[o]);
      return V;
    })(), a = this.font.glyf.encode(s, v, d), c = this.font.loca.encode(a.offsets, v), C = { cmap: this.font.cmap.raw(), glyf: a.table, loca: c, hmtx: this.font.hmtx.raw(), hhea: this.font.hhea.raw(), maxp: this.font.maxp.raw(), post: this.font.post.raw(), name: this.font.name.raw(), head: this.font.head.encode(n) }, this.font.os2.exists && (C["OS/2"] = this.font.os2.raw()), this.font.directory.encode(C);
  }, e;
})();
et.API.PDFObject = (function() {
  var e;
  function t() {
  }
  return e = function(n, r) {
    return (Array(r + 1).join("0") + n).slice(-r);
  }, t.convert = function(n) {
    var r, i, a, s;
    if (Array.isArray(n)) return "[" + (function() {
      var o, u, c;
      for (c = [], o = 0, u = n.length; o < u; o++) r = n[o], c.push(t.convert(r));
      return c;
    })().join(" ") + "]";
    if (typeof n == "string") return "/" + n;
    if (n != null && n.isString) return "(" + n + ")";
    if (n instanceof Date) return "(D:" + e(n.getUTCFullYear(), 4) + e(n.getUTCMonth(), 2) + e(n.getUTCDate(), 2) + e(n.getUTCHours(), 2) + e(n.getUTCMinutes(), 2) + e(n.getUTCSeconds(), 2) + "Z)";
    if ({}.toString.call(n) === "[object Object]") {
      for (i in a = ["<<"], n) s = n[i], a.push("/" + i + " " + t.convert(s));
      return a.push(">>"), a.join(`
`);
    }
    return "" + n;
  }, t;
})();
const Kc = {
  quality: 1,
  pixelRatio: 2.5,
  cacheBust: !0
}, v8 = async (e, t) => {
  const n = [];
  for (const r of e)
    if (r)
      try {
        const i = t === "png" ? await k0(r, Kc) : await C0(r, Kc);
        n.push(i);
      } catch (i) {
        console.error("å›¾ç‰‡ç”Ÿæˆå¤±è´¥:", i);
        const a = t === "png" ? await k0(r, { pixelRatio: 1.5 }) : await C0(r, { pixelRatio: 1.5 });
        n.push(a);
      }
  n.forEach((r, i) => {
    const a = document.createElement("a");
    a.download = `è§†è§‰å¤§å¸ˆ-å¯¼å‡º-${i + 1}.${t}`, a.href = r, a.click();
  });
}, S8 = async (e) => {
  const t = e.filter((r) => r !== null);
  if (t.length === 0) return;
  let n = null;
  for (let r = 0; r < t.length; r++) {
    const i = t[r], a = i.offsetWidth, s = i.offsetHeight;
    try {
      const u = (await _f(i, { ...Kc, pixelRatio: 2 })).toDataURL("image/png");
      n ? n.addPage([a, s], a > s ? "landscape" : "portrait") : n = new et({
        orientation: a > s ? "landscape" : "portrait",
        unit: "px",
        format: [a, s],
        hotfixes: ["px_scaling"]
      }), n.addImage(u, "PNG", 0, 0, a, s);
    } catch (o) {
      console.error("PDF é¡µé¢ç”Ÿæˆå¤±è´¥:", o);
    }
  }
  n && n.save("è§†è§‰å¤§å¸ˆ-Markdownå¯¼å‡º.pdf");
}, P8 = ({
  markdown: e,
  onMarkdownChange: t,
  config: n,
  onConfigChange: r,
  initialMarkdown: i = vm,
  initialConfig: a = Nm,
  className: s,
  onExportError: o
}) => {
  const [u, c] = Yi(i), [f, p] = Yi(a), E = e ?? u, d = t ?? c, A = n ?? f, v = r ?? p, [C, _] = Yi(!0), [U, B] = Yi(!1), [V, ie] = Yi(!1), [K, fe] = Yi("edit"), [Z, z] = Yi("#EF4444"), [D, N] = Yi("#FEF08A"), I = ch([]), $ = ch(null), Y = async (ue) => {
    ie(!0);
    try {
      ue === "png" ? await v8(I.current, "png") : await S8(I.current);
    } catch (me) {
      o == null || o(me), o || alert("å¯¼å‡ºå¤±è´¥ï¼Œè¯·é‡è¯•ã€‚å¦‚æœé”™è¯¯æŒç»­ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–å°è¯•ç®€åŒ–æ–‡æ¡£å†…å®¹ã€‚");
    } finally {
      ie(!1);
    }
  }, J = (ue) => {
    const me = $.current;
    if (!me) return;
    const se = me.selectionStart, Ee = me.selectionEnd, M = E.substring(se, Ee);
    if (!M) {
      alert("è¯·å…ˆåœ¨ç¼–è¾‘å™¨ä¸­é€‰ä¸­ä¸€æ®µæ–‡å­—");
      return;
    }
    let xe = "";
    xe = `color: ${Z}; background-color: ${D}; padding: 0 4px; border-radius: 4px;`;
    const L = `<span style="${xe}">${M}</span>`, T = E.substring(0, se) + L + E.substring(Ee);
    d(T), setTimeout(() => {
      me.focus(), me.setSelectionRange(se, se + L.length);
    }, 0);
  };
  return /* @__PURE__ */ Ke("div", { className: `flex w-full h-full bg-slate-50 overflow-hidden font-sans antialiased ${s ?? ""}`, children: [
    /* @__PURE__ */ De(
      "aside",
      {
        className: `${C ? "w-80" : "w-0"} transition-all duration-300 bg-white border-r border-slate-200 flex flex-col overflow-hidden relative z-40 shadow-sm`,
        children: /* @__PURE__ */ De(d5, { config: A, onChange: v })
      }
    ),
    /* @__PURE__ */ Ke("main", { className: "flex-1 flex flex-col h-full relative overflow-hidden", children: [
      /* @__PURE__ */ Ke("header", { className: "h-16 bg-white border-b border-slate-200 flex items-center justify-between px-4 sm:px-6 shadow-sm z-30", children: [
        /* @__PURE__ */ Ke("div", { className: "flex items-center gap-4", children: [
          /* @__PURE__ */ De(
            "button",
            {
              onClick: () => _(!C),
              className: "p-2 hover:bg-slate-100 rounded-lg text-slate-600 transition-colors",
              title: "åˆ‡æ¢ä¾§è¾¹æ ",
              children: /* @__PURE__ */ De(Gm, { size: 20 })
            }
          ),
          /* @__PURE__ */ Ke("div", { className: "hidden sm:flex items-center gap-2", children: [
            /* @__PURE__ */ De("div", { className: "w-8 h-8 bg-blue-600 rounded-lg flex items-center justify-center text-white shadow-lg shadow-blue-200", children: /* @__PURE__ */ De($d, { size: 18 }) }),
            /* @__PURE__ */ De("h1", { className: "font-bold text-slate-800 tracking-tight", children: "è§†è§‰å¤§å¸ˆ" })
          ] })
        ] }),
        /* @__PURE__ */ Ke("div", { className: "flex items-center gap-2", children: [
          /* @__PURE__ */ Ke("div", { className: "bg-slate-100 p-1 rounded-lg flex mr-4 md:hidden", children: [
            /* @__PURE__ */ Ke(
              "button",
              {
                onClick: () => fe("edit"),
                className: `flex items-center gap-1.5 px-4 py-1.5 rounded-md text-sm font-medium transition-all ${K === "edit" ? "bg-white shadow text-blue-600" : "text-slate-600 hover:text-slate-900"}`,
                children: [
                  /* @__PURE__ */ De(Zm, { size: 14 }),
                  " ç¼–è¾‘"
                ]
              }
            ),
            /* @__PURE__ */ Ke(
              "button",
              {
                onClick: () => fe("preview"),
                className: `flex items-center gap-1.5 px-4 py-1.5 rounded-md text-sm font-medium transition-all ${K === "preview" ? "bg-white shadow text-blue-600" : "text-slate-600 hover:text-slate-900"}`,
                children: [
                  /* @__PURE__ */ De(Fm, { size: 14 }),
                  " é¢„è§ˆ"
                ]
              }
            )
          ] }),
          /* @__PURE__ */ Ke(
            "button",
            {
              onClick: () => B(!U),
              className: `hidden sm:flex items-center gap-2 px-3 py-2 rounded-lg text-sm font-medium transition-all border ${U ? "bg-blue-50 border-blue-200 text-blue-700" : "bg-white border-slate-200 text-slate-600 hover:bg-slate-50"}`,
              children: [
                /* @__PURE__ */ De(a5, { size: 16 }),
                " ",
                U ? "åˆ†é¡µæ¨¡å¼å¼€å¯" : "æ™®é€šæ¨¡å¼"
              ]
            }
          ),
          /* @__PURE__ */ De("div", { className: "h-6 w-px bg-slate-200 mx-1 hidden sm:block" }),
          /* @__PURE__ */ Ke("div", { className: "flex gap-2", children: [
            /* @__PURE__ */ Ke(
              "button",
              {
                disabled: V,
                onClick: () => Y("png"),
                className: "flex items-center gap-2 bg-slate-900 text-white px-4 py-2 rounded-lg text-sm font-semibold hover:bg-slate-800 transition-all disabled:opacity-50 disabled:cursor-not-allowed shadow-md hover:shadow-lg",
                children: [
                  V ? /* @__PURE__ */ De(hh, { size: 16, className: "animate-spin" }) : /* @__PURE__ */ De(Um, { size: 16 }),
                  "å¯¼å‡ºå›¾ç‰‡"
                ]
              }
            ),
            /* @__PURE__ */ Ke(
              "button",
              {
                disabled: V,
                onClick: () => Y("pdf"),
                className: "flex items-center gap-2 bg-blue-600 text-white px-4 py-2 rounded-lg text-sm font-semibold hover:bg-blue-700 transition-all disabled:opacity-50 disabled:cursor-not-allowed shadow-md hover:shadow-lg",
                children: [
                  V ? /* @__PURE__ */ De(hh, { size: 16, className: "animate-spin" }) : /* @__PURE__ */ De(Dm, { size: 16 }),
                  "å¯¼å‡º PDF"
                ]
              }
            )
          ] })
        ] })
      ] }),
      /* @__PURE__ */ Ke("div", { className: "flex-1 flex overflow-hidden", children: [
        /* @__PURE__ */ De("div", { className: `${K === "edit" ? "flex" : "hidden md:flex"} flex-1 border-r border-slate-200 bg-slate-50 flex-col`, children: /* @__PURE__ */ Ke("div", { className: "bg-white m-6 flex-1 rounded-2xl border border-slate-200 shadow-sm overflow-hidden flex flex-col ring-1 ring-slate-200/50", children: [
          /* @__PURE__ */ Ke("div", { className: "bg-slate-50/80 backdrop-blur-sm border-b border-slate-100 px-5 py-3 flex justify-between items-center shrink-0", children: [
            /* @__PURE__ */ Ke("div", { className: "flex items-center gap-4", children: [
              /* @__PURE__ */ Ke("div", { className: "flex items-center gap-1.5 px-2 py-1 bg-white border border-slate-200 rounded-md shadow-sm", children: [
                /* @__PURE__ */ De(Xd, { size: 14, className: "text-slate-400" }),
                /* @__PURE__ */ De(
                  "input",
                  {
                    type: "color",
                    value: Z,
                    onChange: (ue) => z(ue.target.value),
                    className: "w-5 h-5 border-none cursor-pointer rounded overflow-hidden",
                    title: "é€‰ä¸­æ–‡æœ¬é¢œè‰²"
                  }
                ),
                /* @__PURE__ */ De("div", { className: "w-px h-3 bg-slate-200 mx-1" }),
                /* @__PURE__ */ De(qm, { size: 14, className: "text-slate-400" }),
                /* @__PURE__ */ De(
                  "input",
                  {
                    type: "color",
                    value: D,
                    onChange: (ue) => N(ue.target.value),
                    className: "w-5 h-5 border-none cursor-pointer rounded overflow-hidden",
                    title: "é€‰ä¸­é«˜äº®é¢œè‰²"
                  }
                ),
                /* @__PURE__ */ De(
                  "button",
                  {
                    onClick: () => J(),
                    className: "ml-2 bg-blue-600 text-white p-1 rounded hover:bg-blue-700 transition-colors",
                    title: "åº”ç”¨åˆ°é€‰ä¸­æ–‡å­—",
                    children: /* @__PURE__ */ De(Om, { size: 14 })
                  }
                )
              ] }),
              /* @__PURE__ */ De("span", { className: "text-[10px] text-slate-400 font-medium italic hidden lg:block", children: "æç¤ºï¼šé€‰ä¸­æ–‡å­—åç‚¹å‡»å‹¾å·å³å¯åº”ç”¨é¢œè‰²" })
            ] }),
            /* @__PURE__ */ Ke("div", { className: "flex items-center gap-4", children: [
              /* @__PURE__ */ Ke("span", { className: "text-xs text-slate-400 font-mono", children: [
                E.split(/\s+/).filter((ue) => ue).length,
                " è¯"
              ] }),
              /* @__PURE__ */ Ke("span", { className: "text-xs text-slate-400 font-mono", children: [
                E.length,
                " å­—ç¬¦"
              ] })
            ] })
          ] }),
          /* @__PURE__ */ De(
            "textarea",
            {
              ref: $,
              value: E,
              onChange: (ue) => d(ue.target.value),
              placeholder: "åœ¨æ­¤è¾“å…¥æ‚¨çš„ Markdown å†…å®¹...",
              className: "w-full flex-1 p-8 text-slate-800 text-[13px] leading-relaxed resize-none focus:outline-none focus:ring-0 selection:bg-blue-100 placeholder:text-slate-300 placeholder:italic",
              spellCheck: !1
            }
          ),
          /* @__PURE__ */ Ke("div", { className: "bg-slate-50/50 px-5 py-2 text-[10px] text-slate-400 border-t border-slate-100 flex justify-between", children: [
            /* @__PURE__ */ De("span", { children: 'æ”¯æŒ HTML æ ·å¼ï¼š<span style="...">æ–‡å­—</span>' }),
            /* @__PURE__ */ De("span", { children: "UTF-8 Encoding" })
          ] })
        ] }) }),
        /* @__PURE__ */ De("div", { className: `${K === "preview" ? "flex" : "hidden md:flex"} flex-1 bg-slate-200/70 overflow-y-auto scroll-smooth overflow-x-hidden`, children: /* @__PURE__ */ De(V_, { markdown: E, config: A, splitPages: U, pageRefs: I }) })
      ] }),
      U && /* @__PURE__ */ Ke("div", { className: "absolute bottom-10 left-1/2 -translate-x-1/2 px-6 py-3 bg-blue-600 text-white rounded-full shadow-2xl text-sm font-semibold z-50 flex items-center gap-3 animate-in fade-in slide-in-from-bottom-6 duration-500 ring-4 ring-blue-600/20", children: [
        /* @__PURE__ */ Ke("span", { className: "flex h-2 w-2 relative", children: [
          /* @__PURE__ */ De("span", { className: "animate-ping absolute inline-flex h-full w-full rounded-full bg-white opacity-75" }),
          /* @__PURE__ */ De("span", { className: "relative inline-flex rounded-full h-2 w-2 bg-white" })
        ] }),
        "åˆ†é¡µæ¨¡å¼å·²å¯ç”¨ï¼šæ–‡æ¡£å°†æ ¹æ®åˆ†å‰²çº¿æˆ–äºŒçº§ä»¥ä¸Šæ ‡é¢˜è‡ªåŠ¨åˆ‡å‰²ã€‚"
      ] })
    ] })
  ] });
};
export {
  Nm as D,
  vm as I,
  P8 as M,
  V_ as P,
  d5 as S,
  Vd as T,
  qt as _,
  S8 as a,
  I8 as c,
  v8 as e,
  a1 as g
};
